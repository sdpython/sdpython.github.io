
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/plot_op_tree_ensemble_optim.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_plot_op_tree_ensemble_optim.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_plot_op_tree_ensemble_optim.py:


.. _l-plot-optim-tree-ensemble:

TreeEnsemble optimization
=========================

The execution of a TreeEnsembleRegressor can lead to very different results
depending on how the computation is parallelized. By trees,
by rows, by both, for only one row, for a short batch of rows, a longer one.
The implementation in :epkg:`onnxruntime` does not let the user changed
the predetermined settings but a custom kernel might. That's what this example
is measuring.

The default set of optimized parameters is very short and is meant to be executed
fast. Many more parameters can be tried.

::

    python plot_op_tree_ensemble_optim --scenario=LONG

To change the training parameters:

::

    python plot_op_tree_ensemble_optim.py
        --n_trees=100
        --max_depth=10
        --n_features=50
        --batch_size=100000
    
Another example with a full list of parameters:

    python plot_op_tree_ensemble_optim.py
        --n_trees=100
        --max_depth=10
        --n_features=50
        --batch_size=100000
        --tries=3
        --scenario=CUSTOM
        --parallel_tree=80,40
        --parallel_tree_N=128,64
        --parallel_N=50,25
        --batch_size_tree=1,2
        --batch_size_rows=1,2
        --use_node3=0

Another example:

::

    python plot_op_tree_ensemble_optim.py
        --n_trees=100 --n_features=10 --batch_size=10000 --max_depth=8 -s SHORT        

.. GENERATED FROM PYTHON SOURCE LINES 54-107

.. code-block:: Python


    import logging
    import os
    import timeit
    from typing import Tuple
    import numpy
    import onnx
    from onnx import ModelProto
    from onnx.helper import make_graph, make_model
    from onnx.reference import ReferenceEvaluator
    from pandas import DataFrame
    from sklearn.datasets import make_regression
    from sklearn.ensemble import RandomForestRegressor
    from skl2onnx import to_onnx
    from onnxruntime import InferenceSession, SessionOptions
    from onnx_array_api.plotting.text_plot import onnx_simple_text_plot
    from onnx_extended.reference import CReferenceEvaluator
    from onnx_extended.ortops.optim.cpu import get_ort_ext_libs
    from onnx_extended.ortops.optim.optimize import (
        change_onnx_operator_domain,
        get_node_attribute,
        optimize_model,
    )
    from onnx_extended.tools.onnx_nodes import multiply_tree
    from onnx_extended.args import get_parsed_args
    from onnx_extended.ext_test_case import unit_test_going
    from onnx_extended.plotting.benchmark import hhistograms

    logging.getLogger("matplotlib.font_manager").setLevel(logging.ERROR)

    script_args = get_parsed_args(
        "plot_op_tree_ensemble_optim",
        description=__doc__,
        scenarios={
            "SHORT": "short optimization (default)",
            "LONG": "test more options",
            "CUSTOM": "use values specified by the command line",
        },
        n_features=(2 if unit_test_going() else 5, "number of features to generate"),
        n_trees=(3 if unit_test_going() else 10, "number of trees to train"),
        max_depth=(2 if unit_test_going() else 5, "max_depth"),
        batch_size=(1000 if unit_test_going() else 10000, "batch size"),
        parallel_tree=("80,160,40", "values to try for parallel_tree"),
        parallel_tree_N=("256,128,64", "values to try for parallel_tree_N"),
        parallel_N=("100,50,25", "values to try for parallel_N"),
        batch_size_tree=("2,4,8", "values to try for batch_size_tree"),
        batch_size_rows=("2,4,8", "values to try for batch_size_rows"),
        use_node3=("0,1", "values to try for use_node3"),
        expose="",
        n_jobs=("-1", "number of jobs to train the RandomForestRegressor"),
    )









.. GENERATED FROM PYTHON SOURCE LINES 108-110

Training a model
++++++++++++++++

.. GENERATED FROM PYTHON SOURCE LINES 110-159

.. code-block:: Python



    def train_model(
        batch_size: int, n_features: int, n_trees: int, max_depth: int
    ) -> Tuple[str, numpy.ndarray, numpy.ndarray]:
        filename = f"plot_op_tree_ensemble_optim-f{n_features}-{n_trees}-d{max_depth}.onnx"
        if not os.path.exists(filename):
            X, y = make_regression(
                batch_size + max(batch_size, 2 ** (max_depth + 1)),
                n_features=n_features,
                n_targets=1,
            )
            print(f"Training to get {filename!r} with X.shape={X.shape}")
            X, y = X.astype(numpy.float32), y.astype(numpy.float32)
            # To be faster, we train only 1 tree.
            model = RandomForestRegressor(
                1, max_depth=max_depth, verbose=2, n_jobs=int(script_args.n_jobs)
            )
            model.fit(X[:-batch_size], y[:-batch_size])
            onx = to_onnx(model, X[:1], target_opset={"": 18, "ai.onnx.ml": 3})

            # And wd multiply the trees.
            node = multiply_tree(onx.graph.node[0], n_trees)
            onx = make_model(
                make_graph([node], onx.graph.name, onx.graph.input, onx.graph.output),
                domain=onx.domain,
                opset_imports=onx.opset_import,
                ir_version=onx.ir_version,
            )

            with open(filename, "wb") as f:
                f.write(onx.SerializeToString())
        else:
            X, y = make_regression(batch_size, n_features=n_features, n_targets=1)
            X, y = X.astype(numpy.float32), y.astype(numpy.float32)
        Xb, yb = X[-batch_size:].copy(), y[-batch_size:].copy()
        return filename, Xb, yb


    batch_size = script_args.batch_size
    n_features = script_args.n_features
    n_trees = script_args.n_trees
    max_depth = script_args.max_depth

    print(f"batch_size={batch_size}")
    print(f"n_features={n_features}")
    print(f"n_trees={n_trees}")
    print(f"max_depth={max_depth}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    batch_size=10000
    n_features=5
    n_trees=10
    max_depth=5




.. GENERATED FROM PYTHON SOURCE LINES 160-161

training

.. GENERATED FROM PYTHON SOURCE LINES 161-167

.. code-block:: Python


    filename, Xb, yb = train_model(batch_size, n_features, n_trees, max_depth)

    print(f"Xb.shape={Xb.shape}")
    print(f"yb.shape={yb.shape}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Training to get 'plot_op_tree_ensemble_optim-f5-10-d5.onnx' with X.shape=(20000, 5)
    [Parallel(n_jobs=-1)]: Using backend ThreadingBackend with 30 concurrent workers.
    building tree 1 of 1
    Xb.shape=(10000, 5)
    yb.shape=(10000,)




.. GENERATED FROM PYTHON SOURCE LINES 168-175

Rewrite the onnx file to use a different kernel
+++++++++++++++++++++++++++++++++++++++++++++++

The custom kernel is mapped to a custom operator with the same name
the attributes and domain = `"onnx_extended.ortops.optim.cpu"`.
We call a function to do that replacement.
First the current model.

.. GENERATED FROM PYTHON SOURCE LINES 175-180

.. code-block:: Python


    with open(filename, "rb") as f:
        onx = onnx.load(f)
    print(onnx_simple_text_plot(onx))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    opset: domain='ai.onnx.ml' version=1
    opset: domain='' version=18
    input: name='X' type=dtype('float32') shape=['', 5]
    TreeEnsembleRegressor(X, n_targets=1, nodes_falsenodeids=630:[32,17,10...62,0,0], nodes_featureids=630:[4,0,1...0,2,0], nodes_hitrates=630:[1.0,1.0...1.0,1.0], nodes_missing_value_tracks_true=630:[0,0,0...0,0,0], nodes_modes=630:[b'BRANCH_LEQ',b'BRANCH_LEQ'...b'LEAF',b'LEAF'], nodes_nodeids=630:[0,1,2...60,61,62], nodes_treeids=630:[0,0,0...9,9,9], nodes_truenodeids=630:[1,2,3...61,0,0], nodes_values=630:[0.25236639380455017,0.06544898450374603...0.027037980034947395,0.0], post_transform=b'NONE', target_ids=320:[0,0,0...0,0,0], target_nodeids=320:[5,6,8...59,61,62], target_treeids=320:[0,0,0...9,9,9], target_weights=320:[-343.1815185546875,-239.66676330566406...296.36181640625,408.35235595703125]) -> variable
    output: name='variable' type=dtype('float32') shape=['', 1]




.. GENERATED FROM PYTHON SOURCE LINES 181-182

And then the modified model.

.. GENERATED FROM PYTHON SOURCE LINES 182-209

.. code-block:: Python



    def transform_model(model, **kwargs):
        onx = ModelProto()
        onx.ParseFromString(model.SerializeToString())
        att = get_node_attribute(onx.graph.node[0], "nodes_modes")
        modes = ",".join(map(lambda s: s.decode("ascii"), att.strings)).replace(
            "BRANCH_", ""
        )
        return change_onnx_operator_domain(
            onx,
            op_type="TreeEnsembleRegressor",
            op_domain="ai.onnx.ml",
            new_op_domain="onnx_extended.ortops.optim.cpu",
            nodes_modes=modes,
            **kwargs,
        )


    print("Tranform model to add a custom node.")
    onx_modified = transform_model(onx)
    print(f"Save into {filename + 'modified.onnx'!r}.")
    with open(filename + "modified.onnx", "wb") as f:
        f.write(onx_modified.SerializeToString())
    print("done.")
    print(onnx_simple_text_plot(onx_modified))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Tranform model to add a custom node.
    Save into 'plot_op_tree_ensemble_optim-f5-10-d5.onnxmodified.onnx'.
    done.
    opset: domain='ai.onnx.ml' version=1
    opset: domain='' version=18
    opset: domain='onnx_extended.ortops.optim.cpu' version=1
    input: name='X' type=dtype('float32') shape=['', 5]
    TreeEnsembleRegressor[onnx_extended.ortops.optim.cpu](X, nodes_modes=b'LEQ,LEQ,LEQ,LEQ,LEQ,LEAF,LEAF,LEQ,LEAF...LEAF,LEAF', n_targets=1, nodes_falsenodeids=630:[32,17,10...62,0,0], nodes_featureids=630:[4,0,1...0,2,0], nodes_hitrates=630:[1.0,1.0...1.0,1.0], nodes_missing_value_tracks_true=630:[0,0,0...0,0,0], nodes_nodeids=630:[0,1,2...60,61,62], nodes_treeids=630:[0,0,0...9,9,9], nodes_truenodeids=630:[1,2,3...61,0,0], nodes_values=630:[0.25236639380455017,0.06544898450374603...0.027037980034947395,0.0], post_transform=b'NONE', target_ids=320:[0,0,0...0,0,0], target_nodeids=320:[5,6,8...59,61,62], target_treeids=320:[0,0,0...9,9,9], target_weights=320:[-343.1815185546875,-239.66676330566406...296.36181640625,408.35235595703125]) -> variable
    output: name='variable' type=dtype('float32') shape=['', 1]




.. GENERATED FROM PYTHON SOURCE LINES 210-212

Comparing onnxruntime and the custom kernel
+++++++++++++++++++++++++++++++++++++++++++

.. GENERATED FROM PYTHON SOURCE LINES 212-233

.. code-block:: Python


    print(f"Loading {filename!r}")
    sess_ort = InferenceSession(filename, providers=["CPUExecutionProvider"])

    r = get_ort_ext_libs()
    print(f"Creating SessionOptions with {r!r}")
    opts = SessionOptions()
    if r is not None:
        opts.register_custom_ops_library(r[0])

    print(f"Loading modified {filename!r}")
    sess_cus = InferenceSession(
        onx_modified.SerializeToString(), opts, providers=["CPUExecutionProvider"]
    )

    print(f"Running once with shape {Xb.shape}.")
    base = sess_ort.run(None, {"X": Xb})[0]
    print(f"Running modified with shape {Xb.shape}.")
    got = sess_cus.run(None, {"X": Xb})[0]
    print("done.")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Loading 'plot_op_tree_ensemble_optim-f5-10-d5.onnx'
    Creating SessionOptions with ['/home/onyxia/work/github/onnx-extended/onnx_extended/ortops/optim/cpu/libortops_optim_cpu.so']
    Loading modified 'plot_op_tree_ensemble_optim-f5-10-d5.onnx'
    Running once with shape (10000, 5).
    Running modified with shape (10000, 5).
    done.




.. GENERATED FROM PYTHON SOURCE LINES 234-235

Discrepancies?

.. GENERATED FROM PYTHON SOURCE LINES 235-240

.. code-block:: Python


    d = numpy.abs(base - got)
    ya = numpy.abs(base).mean()
    print(f"Discrepancies: max={d.max() / ya}, mean={d.mean() / ya} (A={ya})")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Discrepancies: max=3.2832107876856753e-07, mean=5.714701956094359e-08 (A=2230.809814453125)




.. GENERATED FROM PYTHON SOURCE LINES 241-245

Simple verification
+++++++++++++++++++

Baseline with onnxruntime.

.. GENERATED FROM PYTHON SOURCE LINES 245-248

.. code-block:: Python

    t1 = timeit.timeit(lambda: sess_ort.run(None, {"X": Xb}), number=50)
    print(f"baseline: {t1}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    baseline: 0.009866680949926376




.. GENERATED FROM PYTHON SOURCE LINES 249-250

The custom implementation.

.. GENERATED FROM PYTHON SOURCE LINES 250-253

.. code-block:: Python

    t2 = timeit.timeit(lambda: sess_cus.run(None, {"X": Xb}), number=50)
    print(f"new time: {t2}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    new time: 0.18835443072021008




.. GENERATED FROM PYTHON SOURCE LINES 254-255

The same implementation but ran from the onnx python backend.

.. GENERATED FROM PYTHON SOURCE LINES 255-260

.. code-block:: Python

    ref = CReferenceEvaluator(filename)
    ref.run(None, {"X": Xb})
    t3 = timeit.timeit(lambda: ref.run(None, {"X": Xb}), number=50)
    print(f"CReferenceEvaluator: {t3}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    CReferenceEvaluator: 0.006378265097737312




.. GENERATED FROM PYTHON SOURCE LINES 261-262

The python implementation but from the onnx python backend.

.. GENERATED FROM PYTHON SOURCE LINES 262-270

.. code-block:: Python

    if n_trees < 50:
        # It is usully slow.
        ref = ReferenceEvaluator(filename)
        ref.run(None, {"X": Xb})
        t4 = timeit.timeit(lambda: ref.run(None, {"X": Xb}), number=5)
        print(f"ReferenceEvaluator: {t4} (only 5 times instead of 50)")






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ReferenceEvaluator: 3.8289853613823652 (only 5 times instead of 50)




.. GENERATED FROM PYTHON SOURCE LINES 271-280

Time for comparison
+++++++++++++++++++

The custom kernel supports the same attributes as *TreeEnsembleRegressor*
plus new ones to tune the parallelization. They can be seen in
`tree_ensemble.cc <https://github.com/sdpython/onnx-extended/
blob/main/onnx_extended/ortops/optim/cpu/tree_ensemble.cc#L102>`_.
Let's try out many possibilities.
The default values are the first ones.

.. GENERATED FROM PYTHON SOURCE LINES 280-328

.. code-block:: Python


    if unit_test_going():
        optim_params = dict(
            parallel_tree=[40],  # default is 80
            parallel_tree_N=[128],  # default is 128
            parallel_N=[50, 25],  # default is 50
            batch_size_tree=[1],  # default is 1
            batch_size_rows=[1],  # default is 1
            use_node3=[0],  # default is 0
        )
    elif script_args.scenario in (None, "SHORT"):
        optim_params = dict(
            parallel_tree=[80, 40],  # default is 80
            parallel_tree_N=[128, 64],  # default is 128
            parallel_N=[50, 25],  # default is 50
            batch_size_tree=[1],  # default is 1
            batch_size_rows=[1],  # default is 1
            use_node3=[0],  # default is 0
        )
    elif script_args.scenario == "LONG":
        optim_params = dict(
            parallel_tree=[80, 160, 40],
            parallel_tree_N=[256, 128, 64],
            parallel_N=[100, 50, 25],
            batch_size_tree=[1, 2, 4, 8],
            batch_size_rows=[1, 2, 4, 8],
            use_node3=[0, 1],
        )
    elif script_args.scenario == "CUSTOM":
        optim_params = dict(
            parallel_tree=list(int(i) for i in script_args.parallel_tree.split(",")),
            parallel_tree_N=list(int(i) for i in script_args.parallel_tree_N.split(",")),
            parallel_N=list(int(i) for i in script_args.parallel_N.split(",")),
            batch_size_tree=list(int(i) for i in script_args.batch_size_tree.split(",")),
            batch_size_rows=list(int(i) for i in script_args.batch_size_rows.split(",")),
            use_node3=list(int(i) for i in script_args.use_node3.split(",")),
        )
    else:
        raise ValueError(
            f"Unknown scenario {script_args.scenario!r}, use --help to get them."
        )

    cmds = []
    for att, value in optim_params.items():
        cmds.append(f"--{att}={','.join(map(str, value))}")
    print("Full list of optimization parameters:")
    print(" ".join(cmds))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Full list of optimization parameters:
    --parallel_tree=80,40 --parallel_tree_N=128,64 --parallel_N=50,25 --batch_size_tree=1 --batch_size_rows=1 --use_node3=0




.. GENERATED FROM PYTHON SOURCE LINES 329-330

Then the optimization.

.. GENERATED FROM PYTHON SOURCE LINES 330-360

.. code-block:: Python



    def create_session(onx):
        opts = SessionOptions()
        r = get_ort_ext_libs()
        if r is None:
            raise RuntimeError("No custom implementation available.")
        opts.register_custom_ops_library(r[0])
        return InferenceSession(
            onx.SerializeToString(), opts, providers=["CPUExecutionProvider"]
        )


    res = optimize_model(
        onx,
        feeds={"X": Xb},
        transform=transform_model,
        session=create_session,
        baseline=lambda onx: InferenceSession(
            onx.SerializeToString(), providers=["CPUExecutionProvider"]
        ),
        params=optim_params,
        verbose=True,
        number=script_args.number,
        repeat=script_args.repeat,
        warmup=script_args.warmup,
        sleep=script_args.sleep,
        n_tries=script_args.tries,
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          | 0/16 [00:00<?, ?it/s]    i=1/16 TRY=0 //tree=80 //tree_N=128 //N=50 bs_tree=1 batch_size_rows=1 n3=0:   0%|          | 0/16 [00:00<?, ?it/s]    i=1/16 TRY=0 //tree=80 //tree_N=128 //N=50 bs_tree=1 batch_size_rows=1 n3=0:   6%|▋         | 1/16 [00:00<00:04,  3.47it/s]    i=2/16 TRY=0 //tree=80 //tree_N=128 //N=25 bs_tree=1 batch_size_rows=1 n3=0  ~=1.06x:   6%|▋         | 1/16 [00:00<00:04,  3.47it/s]    i=2/16 TRY=0 //tree=80 //tree_N=128 //N=25 bs_tree=1 batch_size_rows=1 n3=0  ~=1.06x:  12%|█▎        | 2/16 [00:00<00:02,  4.88it/s]    i=3/16 TRY=0 //tree=80 //tree_N=64 //N=50 bs_tree=1 batch_size_rows=1 n3=0  ~=1.12x:  12%|█▎        | 2/16 [00:00<00:02,  4.88it/s]     i=3/16 TRY=0 //tree=80 //tree_N=64 //N=50 bs_tree=1 batch_size_rows=1 n3=0  ~=1.12x:  19%|█▉        | 3/16 [00:00<00:02,  5.59it/s]    i=4/16 TRY=0 //tree=80 //tree_N=64 //N=25 bs_tree=1 batch_size_rows=1 n3=0  ~=1.17x:  19%|█▉        | 3/16 [00:00<00:02,  5.59it/s]    i=4/16 TRY=0 //tree=80 //tree_N=64 //N=25 bs_tree=1 batch_size_rows=1 n3=0  ~=1.17x:  25%|██▌       | 4/16 [00:00<00:01,  6.03it/s]    i=5/16 TRY=0 //tree=40 //tree_N=128 //N=50 bs_tree=1 batch_size_rows=1 n3=0  ~=1.17x:  25%|██▌       | 4/16 [00:00<00:01,  6.03it/s]    i=5/16 TRY=0 //tree=40 //tree_N=128 //N=50 bs_tree=1 batch_size_rows=1 n3=0  ~=1.17x:  31%|███▏      | 5/16 [00:00<00:01,  6.19it/s]    i=6/16 TRY=0 //tree=40 //tree_N=128 //N=25 bs_tree=1 batch_size_rows=1 n3=0  ~=1.17x:  31%|███▏      | 5/16 [00:00<00:01,  6.19it/s]    i=6/16 TRY=0 //tree=40 //tree_N=128 //N=25 bs_tree=1 batch_size_rows=1 n3=0  ~=1.17x:  38%|███▊      | 6/16 [00:01<00:01,  6.31it/s]    i=7/16 TRY=0 //tree=40 //tree_N=64 //N=50 bs_tree=1 batch_size_rows=1 n3=0  ~=1.17x:  38%|███▊      | 6/16 [00:01<00:01,  6.31it/s]     i=7/16 TRY=0 //tree=40 //tree_N=64 //N=50 bs_tree=1 batch_size_rows=1 n3=0  ~=1.17x:  44%|████▍     | 7/16 [00:01<00:01,  6.50it/s]    i=8/16 TRY=0 //tree=40 //tree_N=64 //N=25 bs_tree=1 batch_size_rows=1 n3=0  ~=1.17x:  44%|████▍     | 7/16 [00:01<00:01,  6.50it/s]    i=8/16 TRY=0 //tree=40 //tree_N=64 //N=25 bs_tree=1 batch_size_rows=1 n3=0  ~=1.17x:  50%|█████     | 8/16 [00:01<00:01,  6.58it/s]    i=9/16 TRY=1 //tree=80 //tree_N=128 //N=50 bs_tree=1 batch_size_rows=1 n3=0  ~=1.17x:  50%|█████     | 8/16 [00:01<00:01,  6.58it/s]    i=9/16 TRY=1 //tree=80 //tree_N=128 //N=50 bs_tree=1 batch_size_rows=1 n3=0  ~=1.17x:  56%|█████▋    | 9/16 [00:01<00:01,  6.66it/s]    i=10/16 TRY=1 //tree=80 //tree_N=128 //N=25 bs_tree=1 batch_size_rows=1 n3=0  ~=1.17x:  56%|█████▋    | 9/16 [00:01<00:01,  6.66it/s]    i=10/16 TRY=1 //tree=80 //tree_N=128 //N=25 bs_tree=1 batch_size_rows=1 n3=0  ~=1.17x:  62%|██████▎   | 10/16 [00:01<00:00,  6.70it/s]    i=11/16 TRY=1 //tree=80 //tree_N=64 //N=50 bs_tree=1 batch_size_rows=1 n3=0  ~=1.17x:  62%|██████▎   | 10/16 [00:01<00:00,  6.70it/s]     i=11/16 TRY=1 //tree=80 //tree_N=64 //N=50 bs_tree=1 batch_size_rows=1 n3=0  ~=1.17x:  69%|██████▉   | 11/16 [00:01<00:00,  6.71it/s]    i=12/16 TRY=1 //tree=80 //tree_N=64 //N=25 bs_tree=1 batch_size_rows=1 n3=0  ~=1.17x:  69%|██████▉   | 11/16 [00:01<00:00,  6.71it/s]    i=12/16 TRY=1 //tree=80 //tree_N=64 //N=25 bs_tree=1 batch_size_rows=1 n3=0  ~=1.17x:  75%|███████▌  | 12/16 [00:01<00:00,  6.72it/s]    i=13/16 TRY=1 //tree=40 //tree_N=128 //N=50 bs_tree=1 batch_size_rows=1 n3=0  ~=1.17x:  75%|███████▌  | 12/16 [00:01<00:00,  6.72it/s]    i=13/16 TRY=1 //tree=40 //tree_N=128 //N=50 bs_tree=1 batch_size_rows=1 n3=0  ~=1.17x:  81%|████████▏ | 13/16 [00:02<00:00,  6.71it/s]    i=14/16 TRY=1 //tree=40 //tree_N=128 //N=25 bs_tree=1 batch_size_rows=1 n3=0  ~=1.17x:  81%|████████▏ | 13/16 [00:02<00:00,  6.71it/s]    i=14/16 TRY=1 //tree=40 //tree_N=128 //N=25 bs_tree=1 batch_size_rows=1 n3=0  ~=1.17x:  88%|████████▊ | 14/16 [00:02<00:00,  6.77it/s]    i=15/16 TRY=1 //tree=40 //tree_N=64 //N=50 bs_tree=1 batch_size_rows=1 n3=0  ~=1.17x:  88%|████████▊ | 14/16 [00:02<00:00,  6.77it/s]     i=15/16 TRY=1 //tree=40 //tree_N=64 //N=50 bs_tree=1 batch_size_rows=1 n3=0  ~=1.17x:  94%|█████████▍| 15/16 [00:02<00:00,  6.81it/s]    i=16/16 TRY=1 //tree=40 //tree_N=64 //N=25 bs_tree=1 batch_size_rows=1 n3=0  ~=1.67x:  94%|█████████▍| 15/16 [00:02<00:00,  6.81it/s]    i=16/16 TRY=1 //tree=40 //tree_N=64 //N=25 bs_tree=1 batch_size_rows=1 n3=0  ~=1.67x: 100%|██████████| 16/16 [00:02<00:00,  6.69it/s]    i=16/16 TRY=1 //tree=40 //tree_N=64 //N=25 bs_tree=1 batch_size_rows=1 n3=0  ~=1.67x: 100%|██████████| 16/16 [00:02<00:00,  6.37it/s]




.. GENERATED FROM PYTHON SOURCE LINES 361-362

And the results.

.. GENERATED FROM PYTHON SOURCE LINES 362-369

.. code-block:: Python


    df = DataFrame(res)
    df.to_csv("plot_op_tree_ensemble_optim.csv", index=False)
    df.to_excel("plot_op_tree_ensemble_optim.xlsx", index=False)
    print(df.columns)
    print(df.head(5))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Index(['average', 'deviation', 'min_exec', 'max_exec', 'repeat', 'number',
           'ttime', 'context_size', 'warmup_time', 'n_exp', 'n_exp_name',
           'short_name', 'TRY', 'name', 'parallel_tree', 'parallel_tree_N',
           'parallel_N', 'batch_size_tree', 'batch_size_rows', 'use_node3'],
          dtype='object')
        average  deviation  min_exec  max_exec  repeat  number  ...  parallel_tree  parallel_tree_N  parallel_N  batch_size_tree batch_size_rows use_node3
    0  0.000155   0.000050  0.000109  0.000247      10      10  ...            NaN              NaN         NaN              NaN             NaN       NaN
    1  0.000147   0.000046  0.000081  0.000215      10      10  ...           80.0            128.0        50.0              1.0             1.0       0.0
    2  0.000138   0.000037  0.000089  0.000188      10      10  ...           80.0            128.0        25.0              1.0             1.0       0.0
    3  0.000133   0.000052  0.000085  0.000206      10      10  ...           80.0             64.0        50.0              1.0             1.0       0.0
    4  0.000148   0.000077  0.000084  0.000330      10      10  ...           80.0             64.0        25.0              1.0             1.0       0.0

    [5 rows x 20 columns]




.. GENERATED FROM PYTHON SOURCE LINES 370-372

Sorting
+++++++

.. GENERATED FROM PYTHON SOURCE LINES 372-387

.. code-block:: Python


    small_df = df.drop(
        [
            "min_exec",
            "max_exec",
            "repeat",
            "number",
            "context_size",
            "n_exp_name",
        ],
        axis=1,
    ).sort_values("average")
    print(small_df.head(n=10))






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

         average  deviation     ttime  warmup_time  n_exp         short_name  ...  parallel_tree parallel_tree_N  parallel_N  batch_size_tree  batch_size_rows  use_node3
    15  0.000093   0.000003  0.000930     0.001203     14   1,40,64,50,1,1,0  ...           40.0            64.0        50.0              1.0              1.0        0.0
    3   0.000133   0.000052  0.001326     0.001507      2   0,80,64,50,1,1,0  ...           80.0            64.0        50.0              1.0              1.0        0.0
    5   0.000136   0.000046  0.001362     0.001514      4  0,40,128,50,1,1,0  ...           40.0           128.0        50.0              1.0              1.0        0.0
    6   0.000137   0.000053  0.001365     0.001501      5  0,40,128,25,1,1,0  ...           40.0           128.0        25.0              1.0              1.0        0.0
    8   0.000137   0.000045  0.001367     0.001614      7   0,40,64,25,1,1,0  ...           40.0            64.0        25.0              1.0              1.0        0.0
    2   0.000138   0.000037  0.001382     0.001349      1  0,80,128,25,1,1,0  ...           80.0           128.0        25.0              1.0              1.0        0.0
    14  0.000139   0.000049  0.001392     0.001600     13  1,40,128,25,1,1,0  ...           40.0           128.0        25.0              1.0              1.0        0.0
    17  0.000142   0.000008  0.001424     0.001486      0         1,baseline  ...            NaN             NaN         NaN              NaN              NaN        NaN
    12  0.000146   0.000046  0.001465     0.001598     11   1,80,64,25,1,1,0  ...           80.0            64.0        25.0              1.0              1.0        0.0
    1   0.000147   0.000046  0.001471     0.002009      0  0,80,128,50,1,1,0  ...           80.0           128.0        50.0              1.0              1.0        0.0

    [10 rows x 14 columns]




.. GENERATED FROM PYTHON SOURCE LINES 388-390

Worst
+++++

.. GENERATED FROM PYTHON SOURCE LINES 390-394

.. code-block:: Python


    print(small_df.tail(n=10))






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

         average  deviation     ttime  warmup_time  n_exp         short_name  ...  parallel_tree parallel_tree_N  parallel_N  batch_size_tree  batch_size_rows  use_node3
    12  0.000146   0.000046  0.001465     0.001598     11   1,80,64,25,1,1,0  ...           80.0            64.0        25.0              1.0              1.0        0.0
    1   0.000147   0.000046  0.001471     0.002009      0  0,80,128,50,1,1,0  ...           80.0           128.0        50.0              1.0              1.0        0.0
    13  0.000147   0.000047  0.001474     0.001677     12  1,40,128,50,1,1,0  ...           40.0           128.0        50.0              1.0              1.0        0.0
    16  0.000147   0.000048  0.001474     0.001651     15   1,40,64,25,1,1,0  ...           40.0            64.0        25.0              1.0              1.0        0.0
    4   0.000148   0.000077  0.001477     0.001493      3   0,80,64,25,1,1,0  ...           80.0            64.0        25.0              1.0              1.0        0.0
    9   0.000149   0.000047  0.001489     0.001557      8  1,80,128,50,1,1,0  ...           80.0           128.0        50.0              1.0              1.0        0.0
    11  0.000151   0.000045  0.001507     0.001640     10   1,80,64,50,1,1,0  ...           80.0            64.0        50.0              1.0              1.0        0.0
    10  0.000152   0.000096  0.001523     0.001498      9  1,80,128,25,1,1,0  ...           80.0           128.0        25.0              1.0              1.0        0.0
    7   0.000154   0.000093  0.001544     0.001526      6   0,40,64,50,1,1,0  ...           40.0            64.0        50.0              1.0              1.0        0.0
    0   0.000155   0.000050  0.001554     0.001777      0         0,baseline  ...            NaN             NaN         NaN              NaN              NaN        NaN

    [10 rows x 14 columns]




.. GENERATED FROM PYTHON SOURCE LINES 395-397

Plot
++++

.. GENERATED FROM PYTHON SOURCE LINES 397-403

.. code-block:: Python


    skeys = ",".join(optim_params.keys())
    title = f"TreeEnsemble tuning, n_tries={script_args.tries}\n{skeys}\nlower is better"
    ax = hhistograms(df, title=title, keys=("name",))
    fig = ax.get_figure()
    fig.savefig("plot_op_tree_ensemble_optim.png")



.. image-sg:: /auto_examples/images/sphx_glr_plot_op_tree_ensemble_optim_001.png
   :alt: TreeEnsemble tuning, n_tries=2 parallel_tree,parallel_tree_N,parallel_N,batch_size_tree,batch_size_rows,use_node3 lower is better
   :srcset: /auto_examples/images/sphx_glr_plot_op_tree_ensemble_optim_001.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 9.362 seconds)


.. _sphx_glr_download_auto_examples_plot_op_tree_ensemble_optim.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_op_tree_ensemble_optim.ipynb <plot_op_tree_ensemble_optim.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_op_tree_ensemble_optim.py <plot_op_tree_ensemble_optim.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
