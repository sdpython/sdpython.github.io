
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/plot_op_einsum.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_plot_op_einsum.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_plot_op_einsum.py:


.. _l-plot-op-einsum:

Compares implementations of Einsum
==================================

This example compares different equations for function :func:`numpy.einsum`.
It compares *numpy* implementation to a custom implementation,
:epkg:`onnxruntime` implementation and :epkg:`opt-einsum` optimisation.
If available, :epkg:`tensorflow` and :epkg:`pytorch` are included as well.
The custom implementation does not do any transpose.
It uses parallelisation and SIMD optimization when the summation
happens on the last axis of both matrices. It only implements
matrix multiplication. We also measure the improvment made with
function :func:`einsum <onnx_extended.tools.einsum.einsum_fct.einsum>`.

Available optimisation
++++++++++++++++++++++

The code shows which optimisation is used for the custom
implementation, *AVX* or *SSE* and the number of available processors,
equal to the default number of used threads to parallelize.

.. GENERATED FROM PYTHON SOURCE LINES 24-47

.. code-block:: default

    import logging
    import numpy
    import pandas
    import matplotlib.pyplot as plt
    from onnx import TensorProto
    from onnx.helper import (
        make_model,
        make_graph,
        make_node,
        make_tensor_value_info,
        make_opsetid,
    )
    from onnxruntime import InferenceSession
    from onnx_extended.ext_test_case import measure_time, unit_test_going
    from tqdm import tqdm
    from opt_einsum import contract
    from onnx_extended.tools.einsum.einsum_fct import _einsum

    logging.getLogger("matplotlib.font_manager").setLevel(logging.ERROR)
    logging.getLogger("matplotlib.ticker").setLevel(logging.ERROR)
    logging.getLogger("PIL.PngImagePlugin").setLevel(logging.ERROR)
    logging.getLogger("onnx-extended").setLevel(logging.ERROR)








.. GENERATED FROM PYTHON SOURCE LINES 48-50

Einsum: common code
+++++++++++++++++++

.. GENERATED FROM PYTHON SOURCE LINES 50-212

.. code-block:: default


    try:
        from tensorflow import einsum as tf_einsum, convert_to_tensor
    except ImportError:
        tf_einsum = None
    try:
        from torch import einsum as torch_einsum, from_numpy
    except ImportError:
        torch_einsum = None


    def build_ort_einsum(equation, op_version=18):  # opset=13, 14, ...
        onx = make_model(
            make_graph(
                [make_node("Einsum", ["x", "y"], ["z"], equation=equation)],
                equation,
                [
                    make_tensor_value_info("x", TensorProto.FLOAT, None),
                    make_tensor_value_info("y", TensorProto.FLOAT, None),
                ],
                [make_tensor_value_info("z", TensorProto.FLOAT, None)],
            ),
            opset_imports=[make_opsetid("", op_version)],
        )
        sess = InferenceSession(onx.SerializeToString(), providers=["CPUExecutionProvider"])
        return lambda x, y: sess.run(None, {"x": x, "y": y})


    def build_ort_decomposed(equation, op_version=18):  # opset=13, 14, ...
        cache = _einsum(
            equation,
            numpy.float32,
            opset=op_version,
            optimize=True,
            verbose=True,
            runtime="python",
        )
        if not hasattr(cache, "onnx_"):
            cache.build()
        sess = InferenceSession(
            cache.onnx_.SerializeToString(), providers=["CPUExecutionProvider"]
        )
        return lambda x, y: sess.run(None, {"X0": x, "X1": y})


    def loop_einsum_eq(fct, equation, xs, ys):
        for x, y in zip(xs, ys):
            fct(equation, x, y)


    def loop_einsum_eq_th(fct, equation, xs, ys):
        for x, y in zip(xs, ys):
            fct(equation, x, y, nthread=-1)


    def loop_einsum(fct, xs, ys):
        for x, y in zip(xs, ys):
            fct(x, y)


    def timeit(stmt, ctx, dim, name):
        obs = measure_time(stmt, div_by_number=True, context=ctx, repeat=5, number=1)
        obs["dim"] = dim
        obs["fct"] = name
        return obs


    def benchmark_equation(equation):
        # equations
        ort_einsum = build_ort_einsum(equation)
        ort_einsum_decomposed = build_ort_decomposed(equation)
        res = []
        for dim in tqdm([8, 16, 32, 64, 100, 128, 200, 256]):  # , 500, 512]):
            if unit_test_going() and dim > 64:
                break
            xs = [numpy.random.rand(2, dim, 12, 64).astype(numpy.float32) for _ in range(5)]
            ys = [numpy.random.rand(2, dim, 12, 64).astype(numpy.float32) for _ in range(5)]

            # numpy
            ctx = dict(
                equation=equation,
                xs=xs,
                ys=ys,
                einsum=numpy.einsum,
                loop_einsum=loop_einsum,
                loop_einsum_eq=loop_einsum_eq,
                loop_einsum_eq_th=loop_einsum_eq_th,
            )
            obs = timeit(
                "loop_einsum_eq(einsum, equation, xs, ys)", ctx, dim, "numpy.einsum"
            )
            res.append(obs)

            # opt-einsum
            ctx["einsum"] = contract
            obs = timeit("loop_einsum_eq(einsum, equation, xs, ys)", ctx, dim, "opt-einsum")
            res.append(obs)

            # onnxruntime
            ctx["einsum"] = ort_einsum
            obs = timeit("loop_einsum(einsum, xs, ys)", ctx, dim, "ort-einsum")
            res.append(obs)

            # onnxruntime decomposed
            ctx["einsum"] = ort_einsum_decomposed
            obs = timeit("loop_einsum(einsum, xs, ys)", ctx, dim, "ort-dec")
            res.append(obs)

            if tf_einsum is not None:
                # tensorflow
                ctx["einsum"] = tf_einsum
                ctx["xs"] = [convert_to_tensor(x) for x in xs]
                ctx["ys"] = [convert_to_tensor(y) for y in ys]
                obs = timeit(
                    "loop_einsum_eq(einsum, equation, xs, ys)", ctx, dim, "tf-einsum"
                )
                res.append(obs)

            if torch_einsum is not None:
                # torch
                ctx["einsum"] = torch_einsum
                ctx["xs"] = [from_numpy(x) for x in xs]
                ctx["ys"] = [from_numpy(y) for y in ys]
                obs = timeit(
                    "loop_einsum_eq(einsum, equation, xs, ys)", ctx, dim, "torch-einsum"
                )
                res.append(obs)

        # Dataframes
        df = pandas.DataFrame(res)
        piv = df.pivot(index="dim", columns="fct", values="average")

        rs = piv.copy()
        for c in ["ort-einsum", "ort-dec", "tf-einsum", "torch-einsum", "opt-einsum"]:
            if c not in rs.columns:
                continue
            rs[c] = rs["numpy.einsum"] / rs[c]
        rs["numpy.einsum"] = 1.0

        # Graphs.
        fig, ax = plt.subplots(1, 2, figsize=(14, 5))
        piv.plot(
            logx=True,
            logy=True,
            ax=ax[0],
            title=f"Einsum benchmark\n{equation} -- (2, N, 12, 64) lower better",
        )
        ax[0].legend(prop={"size": 9})
        rs.plot(
            logx=True,
            logy=True,
            ax=ax[1],
            title="Einsum Speedup, baseline=numpy\n%s -- (2, N, 12, 64)"
            " higher better" % equation,
        )
        ax[1].plot([min(rs.index), max(rs.index)], [0.5, 0.5], "g--")
        ax[1].plot([min(rs.index), max(rs.index)], [2.0, 2.0], "g--")
        ax[1].legend(prop={"size": 9})

        return df, rs, ax









.. GENERATED FROM PYTHON SOURCE LINES 213-226

First equation: bsnh,btnh->bnts
+++++++++++++++++++++++++++++++

The decomposition of this equation without einsum function gives
the following.

 .. gdot::
      :script:

      from onnx_extended.tools.einsum import decompose_einsum_equation
      dec = decompose_einsum_equation(
          'bsnh,btnh->bnts', strategy='numpy', clean=True)
      print(dec.to_dot())

.. GENERATED FROM PYTHON SOURCE LINES 226-233

.. code-block:: default


    dfs = []
    equation = "bsnh,btnh->bnts"
    df, piv, ax = benchmark_equation(equation)
    df.pivot(index="fct", columns="dim", values="average")
    dfs.append(df)




.. image-sg:: /auto_examples/images/sphx_glr_plot_op_einsum_001.png
   :alt: Einsum benchmark bsnh,btnh->bnts -- (2, N, 12, 64) lower better, Einsum Speedup, baseline=numpy bsnh,btnh->bnts -- (2, N, 12, 64) higher better
   :srcset: /auto_examples/images/sphx_glr_plot_op_einsum_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          | 0/121 [00:00<?, ?it/s]    0.011 rtbest='bsnh,btnh->bnts':   0%|          | 0/121 [00:00<?, ?it/s]    0.011 rtbest='bsnh,btnh->bnts':   1%|          | 1/121 [00:00<00:16,  7.41it/s]    0.0098 rtbest='bsnh,btnh->bnts':   1%|          | 1/121 [00:00<00:16,  7.41it/s]    0.009 rtbest='bnsh,btsh->bstn':   1%|          | 1/121 [00:00<00:16,  7.41it/s]     0.0077 rtbest='bnth,bsth->btsn':   1%|          | 1/121 [00:00<00:16,  7.41it/s]    0.0069 rtbest='btsh,bnsh->bsnt':   1%|          | 1/121 [00:00<00:16,  7.41it/s]    0.0066 rtbest='bsth,bnth->btns':   1%|          | 1/121 [00:00<00:16,  7.41it/s]    0.0062 rtbest='bthn,bshn->bhst':   1%|          | 1/121 [00:00<00:16,  7.41it/s]    0.0062 rtbest='bnhs,bths->bhtn':   1%|          | 1/121 [00:00<00:16,  7.41it/s]    0.0062 rtbest='bnhs,bths->bhtn':   8%|▊         | 10/121 [00:00<00:02, 48.47it/s]    0.0061 rtbest='bths,bnhs->bhnt':   8%|▊         | 10/121 [00:00<00:02, 48.47it/s]    0.006 rtbest='bsht,bnht->bhns':   8%|▊         | 10/121 [00:00<00:02, 48.47it/s]     0.006 rtbest='bsht,bnht->bhns':  18%|█▊        | 22/121 [00:00<00:01, 76.08it/s]    0.006 rtbest='bsht,bnht->bhns':  28%|██▊       | 34/121 [00:00<00:00, 90.16it/s]    0.006 rtbest='bsht,bnht->bhns':  37%|███▋      | 45/121 [00:00<00:00, 96.31it/s]    0.006 rtbest='bsht,bnht->bhns':  46%|████▋     | 56/121 [00:00<00:00, 100.04it/s]    0.006 rtbest='bsht,bnht->bhns':  55%|█████▌    | 67/121 [00:00<00:00, 99.18it/s]     0.006 rtbest='bsht,bnht->bhns':  64%|██████▍   | 78/121 [00:00<00:00, 99.53it/s]    0.006 rtbest='bsht,bnht->bhns':  74%|███████▎  | 89/121 [00:00<00:00, 100.25it/s]    0.006 rtbest='bsht,bnht->bhns':  83%|████████▎ | 100/121 [00:01<00:00, 100.60it/s]    0.006 rtbest='bsht,bnht->bhns':  92%|█████████▏| 111/121 [00:01<00:00, 101.20it/s]    0.006 rtbest='bsht,bnht->bhns': 100%|██████████| 121/121 [00:01<00:00, 93.04it/s] 
      0%|          | 0/8 [00:00<?, ?it/s]     12%|█▎        | 1/8 [00:00<00:01,  6.20it/s]     38%|███▊      | 3/8 [00:00<00:00, 11.43it/s]     62%|██████▎   | 5/8 [00:01<00:00,  4.12it/s]     75%|███████▌  | 6/8 [00:02<00:00,  2.16it/s]     88%|████████▊ | 7/8 [00:04<00:01,  1.04s/it]    100%|██████████| 8/8 [00:08<00:00,  1.83s/it]    100%|██████████| 8/8 [00:08<00:00,  1.06s/it]




.. GENERATED FROM PYTHON SOURCE LINES 234-250

Second equation: bshn,bthn->bnts
++++++++++++++++++++++++++++++++

The summation does not happen on the last axis but
on the previous one.
Is it worth transposing before doing the summation...
The decomposition of this equation without einsum function gives
the following.

 .. gdot::
      :script:

      from onnx_extended.tools.einsum import decompose_einsum_equation
      dec = decompose_einsum_equation(
          'bshn,bthn->bnts', strategy='numpy', clean=True)
      print(dec.to_dot())

.. GENERATED FROM PYTHON SOURCE LINES 250-256

.. code-block:: default


    equation = "bshn,bthn->bnts"
    df, piv, ax = benchmark_equation(equation)
    df.pivot(index="fct", columns="dim", values="average")
    dfs.append(df)




.. image-sg:: /auto_examples/images/sphx_glr_plot_op_einsum_002.png
   :alt: Einsum benchmark bshn,bthn->bnts -- (2, N, 12, 64) lower better, Einsum Speedup, baseline=numpy bshn,bthn->bnts -- (2, N, 12, 64) higher better
   :srcset: /auto_examples/images/sphx_glr_plot_op_einsum_002.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          | 0/121 [00:00<?, ?it/s]    0.0081 rtbest='bshn,bthn->bnts':   0%|          | 0/121 [00:00<?, ?it/s]    0.008 rtbest='bthn,bshn->bnst':   0%|          | 0/121 [00:00<?, ?it/s]     0.008 rtbest='btnh,bsnh->bhst':   0%|          | 0/121 [00:00<?, ?it/s]    0.008 rtbest='btnh,bsnh->bhst':   7%|▋         | 9/121 [00:00<00:01, 89.94it/s]    0.0079 rtbest='bhns,btns->bsth':   7%|▋         | 9/121 [00:00<00:01, 89.94it/s]    0.0079 rtbest='bhst,bnst->btnh':   7%|▋         | 9/121 [00:00<00:01, 89.94it/s]    0.0079 rtbest='bhts,bnts->bsnh':   7%|▋         | 9/121 [00:00<00:01, 89.94it/s]    0.0079 rtbest='bhts,bnts->bsnh':  16%|█▌        | 19/121 [00:00<00:01, 90.50it/s]    0.0076 rtbest='btns,bhns->bsht':  16%|█▌        | 19/121 [00:00<00:01, 90.50it/s]    0.0076 rtbest='btns,bhns->bsht':  24%|██▍       | 29/121 [00:00<00:00, 92.49it/s]    0.0075 rtbest='nhbs,ntbs->nsth':  24%|██▍       | 29/121 [00:00<00:00, 92.49it/s]    0.0075 rtbest='nhbs,ntbs->nsth':  32%|███▏      | 39/121 [00:00<00:00, 94.14it/s]    0.0074 rtbest='ntbs,nhbs->nsht':  32%|███▏      | 39/121 [00:00<00:00, 94.14it/s]    0.0074 rtbest='ntbs,nhbs->nsht':  40%|████      | 49/121 [00:00<00:00, 94.49it/s]    0.0074 rtbest='ntbs,nhbs->nsht':  49%|████▉     | 59/121 [00:00<00:00, 96.14it/s]    0.0074 rtbest='shnb,stnb->sbth':  49%|████▉     | 59/121 [00:00<00:00, 96.14it/s]    0.0074 rtbest='shnb,stnb->sbth':  58%|█████▊    | 70/121 [00:00<00:00, 97.53it/s]    0.0074 rtbest='hbns,htns->hstb':  58%|█████▊    | 70/121 [00:00<00:00, 97.53it/s]    0.0071 rtbest='hbnt,hsnt->htsb':  58%|█████▊    | 70/121 [00:00<00:00, 97.53it/s]    0.0071 rtbest='nbht,nsht->ntsb':  58%|█████▊    | 70/121 [00:00<00:00, 97.53it/s]    0.0071 rtbest='nbht,nsht->ntsb':  67%|██████▋   | 81/121 [00:00<00:00, 98.63it/s]    0.0071 rtbest='nbht,nsht->ntsb':  76%|███████▌  | 92/121 [00:00<00:00, 99.60it/s]    0.007 rtbest='sbnt,shnt->sthb':  76%|███████▌  | 92/121 [00:00<00:00, 99.60it/s]     0.007 rtbest='sbnt,shnt->sthb':  84%|████████▍ | 102/121 [00:01<00:00, 99.24it/s]    0.007 rtbest='sbnt,shnt->sthb':  93%|█████████▎| 112/121 [00:01<00:00, 97.03it/s]    0.007 rtbest='sbnt,shnt->sthb': 100%|██████████| 121/121 [00:01<00:00, 96.47it/s]
      0%|          | 0/8 [00:00<?, ?it/s]     38%|███▊      | 3/8 [00:00<00:00, 20.83it/s]     75%|███████▌  | 6/8 [00:02<00:01,  1.88it/s]     88%|████████▊ | 7/8 [00:07<00:01,  1.46s/it]    100%|██████████| 8/8 [00:27<00:00,  5.96s/it]    100%|██████████| 8/8 [00:27<00:00,  3.48s/it]




.. GENERATED FROM PYTHON SOURCE LINES 257-272

Third equation: bhsn,bhtn->bnts
+++++++++++++++++++++++++++++++

The summation does not happen on the last axis but
on the second one. It is worth transposing before multiplying.
The decomposition of this equation without einsum function gives
the following.

 .. gdot::
      :script:

      from onnx_extended.tools.einsum import decompose_einsum_equation
      dec = decompose_einsum_equation(
          'bhsn,bhtn->bnts', strategy='numpy', clean=True)
      print(dec.to_dot())

.. GENERATED FROM PYTHON SOURCE LINES 272-278

.. code-block:: default


    equation = "bhsn,bhtn->bnts"
    df, piv, ax = benchmark_equation(equation)
    df.pivot(index="fct", columns="dim", values="average")
    dfs.append(df)




.. image-sg:: /auto_examples/images/sphx_glr_plot_op_einsum_003.png
   :alt: Einsum benchmark bhsn,bhtn->bnts -- (2, N, 12, 64) lower better, Einsum Speedup, baseline=numpy bhsn,bhtn->bnts -- (2, N, 12, 64) higher better
   :srcset: /auto_examples/images/sphx_glr_plot_op_einsum_003.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          | 0/121 [00:00<?, ?it/s]    0.0079 rtbest='bhsn,bhtn->bnts':   0%|          | 0/121 [00:00<?, ?it/s]    0.0078 rtbest='bhsn,bhtn->bnts':   0%|          | 0/121 [00:00<?, ?it/s]    0.0078 rtbest='bhsn,bhtn->bnts':   7%|▋         | 9/121 [00:00<00:01, 84.95it/s]    0.0078 rtbest='bhsn,bhtn->bnts':  15%|█▍        | 18/121 [00:00<00:01, 86.52it/s]    0.0078 rtbest='bhsn,bhtn->bnts':  22%|██▏       | 27/121 [00:00<00:01, 84.92it/s]    0.0078 rtbest='bhsn,bhtn->bnts':  30%|██▉       | 36/121 [00:00<00:01, 82.04it/s]    0.0078 rtbest='bhsn,bhtn->bnts':  37%|███▋      | 45/121 [00:00<00:00, 77.47it/s]    0.0078 rtbest='bhsn,bhtn->bnts':  45%|████▍     | 54/121 [00:00<00:00, 79.63it/s]    0.0078 rtbest='bhsn,bhtn->bnts':  52%|█████▏    | 63/121 [00:00<00:00, 80.44it/s]    0.0078 rtbest='bhsn,bhtn->bnts':  60%|█████▉    | 72/121 [00:00<00:00, 76.63it/s]    0.0078 rtbest='bhsn,bhtn->bnts':  66%|██████▌   | 80/121 [00:01<00:00, 76.95it/s]    0.0078 rtbest='bhsn,bhtn->bnts':  74%|███████▎  | 89/121 [00:01<00:00, 79.08it/s]    0.0078 rtbest='bhsn,bhtn->bnts':  81%|████████  | 98/121 [00:01<00:00, 81.26it/s]    0.0078 rtbest='bhsn,bhtn->bnts':  88%|████████▊ | 107/121 [00:01<00:00, 83.76it/s]    0.0078 rtbest='bhsn,bhtn->bnts':  97%|█████████▋| 117/121 [00:01<00:00, 86.06it/s]    0.0078 rtbest='bhsn,bhtn->bnts': 100%|██████████| 121/121 [00:01<00:00, 82.20it/s]
      0%|          | 0/8 [00:00<?, ?it/s]     38%|███▊      | 3/8 [00:00<00:00, 14.90it/s]     62%|██████▎   | 5/8 [00:00<00:00,  6.29it/s]     75%|███████▌  | 6/8 [00:01<00:00,  4.57it/s]     88%|████████▊ | 7/8 [00:01<00:00,  3.05it/s]    100%|██████████| 8/8 [00:02<00:00,  2.21it/s]    100%|██████████| 8/8 [00:02<00:00,  3.20it/s]




.. GENERATED FROM PYTHON SOURCE LINES 279-285

Conclusion
++++++++++

pytorch seems quite efficient on these examples.
The custom implementation was a way to investigate
the implementation of einsum and find some ways to optimize it.

.. GENERATED FROM PYTHON SOURCE LINES 285-293

.. code-block:: default


    merged = pandas.concat(dfs)
    name = "einsum"
    merged.to_csv(f"plot_{name}.csv", index=False)
    merged.to_excel(f"plot_{name}.xlsx", index=False)
    plt.savefig(f"plot_{name}.png")

    # plt.show()



.. image-sg:: /auto_examples/images/sphx_glr_plot_op_einsum_004.png
   :alt: plot op einsum
   :srcset: /auto_examples/images/sphx_glr_plot_op_einsum_004.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 45.029 seconds)


.. _sphx_glr_download_auto_examples_plot_op_einsum.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_op_einsum.py <plot_op_einsum.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_op_einsum.ipynb <plot_op_einsum.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
