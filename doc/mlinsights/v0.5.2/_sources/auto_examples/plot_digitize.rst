
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/plot_digitize.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_plot_digitize.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_plot_digitize.py:


========================
numpy.digitize as a tree
========================

Function :func:`numpy.digitize` transforms a real variable
into a discrete one by returning the buckets the variable
falls into. This bucket can be efficiently retrieved by doing a
binary search over the bins. That's equivalent to decision tree.
Function :func:`digitize2tree
<mlinsights.mltree.tree_digitize.digitize2tree>`.

Simple example
==============

.. GENERATED FROM PYTHON SOURCE LINES 16-34

.. code-block:: Python


    import numpy
    import matplotlib.pyplot as plt
    from onnxruntime import InferenceSession
    from pandas import DataFrame, pivot, pivot_table
    from skl2onnx import to_onnx
    from sklearn.tree import export_text
    from tqdm import tqdm
    from mlinsights.ext_test_case import measure_time
    from mlinsights.mltree import digitize2tree

    x = numpy.array([0.2, 6.4, 3.0, 1.6])
    bins = numpy.array([0.0, 1.0, 2.5, 4.0, 7.0])
    expected = numpy.digitize(x, bins, right=True)
    tree = digitize2tree(bins, right=True)
    pred = tree.predict(x.reshape((-1, 1)))
    print(expected, pred)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [1 4 3 2] [1. 4. 3. 2.]




.. GENERATED FROM PYTHON SOURCE LINES 35-36

The tree looks like the following.

.. GENERATED FROM PYTHON SOURCE LINES 36-39

.. code-block:: Python


    print(export_text(tree, feature_names=["x"]))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    |--- x <= 2.50
    |   |--- x <= 1.00
    |   |   |--- x <= 0.00
    |   |   |   |--- value: [0.00]
    |   |   |--- x >  0.00
    |   |   |   |--- value: [1.00]
    |   |--- x >  1.00
    |   |   |--- value: [2.00]
    |--- x >  2.50
    |   |--- x <= 4.00
    |   |   |--- x <= 2.50
    |   |   |   |--- value: [2.00]
    |   |   |--- x >  2.50
    |   |   |   |--- value: [3.00]
    |   |--- x >  4.00
    |   |   |--- x <= 7.00
    |   |   |   |--- x <= 4.00
    |   |   |   |   |--- value: [3.00]
    |   |   |   |--- x >  4.00
    |   |   |   |   |--- value: [4.00]
    |   |   |--- x >  7.00
    |   |   |   |--- value: [5.00]





.. GENERATED FROM PYTHON SOURCE LINES 40-47

Benchmark
=========

Let's measure the processing time. *numpy* should be
much faster than *scikit-learn* as it is adding many verification.
However, the benchmark also includes a conversion of the tree into
ONNX and measure the processing time with :epkg:`onnxruntime`.

.. GENERATED FROM PYTHON SOURCE LINES 47-111

.. code-block:: Python


    obs = []

    for shape in tqdm([1, 10, 100, 1000, 10000, 100000]):
        x = numpy.random.random(shape).astype(numpy.float32)
        if shape < 1000:
            repeat = number = 100
        else:
            repeat = number = 10

        for n_bins in [1, 10, 100]:
            bins = (numpy.arange(n_bins) / n_bins).astype(numpy.float32)

            ti = measure_time(
                "numpy.digitize(x, bins, right=True)",
                context={"numpy": numpy, "x": x, "bins": bins},
                div_by_number=True,
                repeat=repeat,
                number=number,
            )
            ti["name"] = "numpy"
            ti["n_bins"] = n_bins
            ti["shape"] = shape
            obs.append(ti)

            tree = digitize2tree(bins, right=True)

            ti = measure_time(
                "tree.predict(x)",
                context={"numpy": numpy, "x": x.reshape((-1, 1)), "tree": tree},
                div_by_number=True,
                repeat=repeat,
                number=number,
            )
            ti["name"] = "sklearn"
            ti["n_bins"] = n_bins
            ti["shape"] = shape
            obs.append(ti)

            onx = to_onnx(tree, x.reshape((-1, 1)), target_opset=15)

            sess = InferenceSession(
                onx.SerializeToString(), providers=["CPUExecutionProvider"]
            )

            ti = measure_time(
                "sess.run(None, {'X': x})",
                context={"numpy": numpy, "x": x.reshape((-1, 1)), "sess": sess},
                div_by_number=True,
                repeat=repeat,
                number=number,
            )
            ti["name"] = "ort"
            ti["n_bins"] = n_bins
            ti["shape"] = shape
            obs.append(ti)


    df = DataFrame(obs)
    piv = pivot_table(
        data=df, index="shape", columns=["n_bins", "name"], values=["average"]
    )
    print(piv)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          | 0/6 [00:00<?, ?it/s]     17%|█▋        | 1/6 [00:02<00:13,  2.67s/it]     33%|███▎      | 2/6 [00:04<00:09,  2.40s/it]     50%|█████     | 3/6 [00:07<00:07,  2.45s/it]     83%|████████▎ | 5/6 [00:07<00:01,  1.17s/it]    100%|██████████| 6/6 [00:10<00:00,  1.55s/it]    100%|██████████| 6/6 [00:10<00:00,  1.71s/it]
             average                                                                                
    n_bins       1                             10                            100                    
    name       numpy       ort   sklearn     numpy       ort   sklearn     numpy       ort   sklearn
    shape                                                                                           
    1       0.000003  0.000008  0.000056  0.000003  0.000010  0.000056  0.000004  0.000010  0.000059
    10      0.000004  0.000010  0.000061  0.000003  0.000009  0.000060  0.000003  0.000010  0.000059
    100     0.000004  0.000018  0.000056  0.000003  0.000018  0.000061  0.000005  0.000020  0.000062
    1000    0.000008  0.000019  0.000077  0.000014  0.000052  0.000076  0.000076  0.000051  0.000102
    10000   0.000133  0.000031  0.000257  0.000261  0.000071  0.000404  0.000643  0.000114  0.000799
    100000  0.000753  0.000156  0.000531  0.003036  0.000469  0.003952  0.006437  0.000906  0.008225




.. GENERATED FROM PYTHON SOURCE LINES 112-114

Plotting
========

.. GENERATED FROM PYTHON SOURCE LINES 114-128

.. code-block:: Python


    n_bins = list(sorted(set(df.n_bins)))
    fig, ax = plt.subplots(1, len(n_bins), figsize=(14, 4))

    for i, nb in enumerate(n_bins):
        piv = pivot(
            data=df[df.n_bins == nb], index="shape", columns="name", values="average"
        )
        piv.plot(
            title="Benchmark digitize / onnxruntime\nn_bins=%d" % nb,
            logx=True,
            logy=True,
            ax=ax[i],
        )



.. image-sg:: /auto_examples/images/sphx_glr_plot_digitize_001.png
   :alt: Benchmark digitize / onnxruntime n_bins=1, Benchmark digitize / onnxruntime n_bins=10, Benchmark digitize / onnxruntime n_bins=100
   :srcset: /auto_examples/images/sphx_glr_plot_digitize_001.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 12.002 seconds)


.. _sphx_glr_download_auto_examples_plot_digitize.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_digitize.ipynb <plot_digitize.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_digitize.py <plot_digitize.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_digitize.zip <plot_digitize.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
