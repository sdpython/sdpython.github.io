
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/plot_export_with_args_kwargs.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_plot_export_with_args_kwargs.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_plot_export_with_args_kwargs.py:


.. _l-plot-export-with-args-kwargs:

==========================================
Dynamic Shapes for ``*args``, ``**kwargs``
==========================================

Quick tour of dynamic shapes.
We first look at examples playing positional and names parameters
to understand how :func:`torch.export.export` works.

args
====

.. GENERATED FROM PYTHON SOURCE LINES 15-35

.. code-block:: Python


    import pprint
    import torch
    from onnx_diagnostic import doc
    from onnx_diagnostic.export import ModelInputs


    class Model(torch.nn.Module):
        def forward(self, x, y):
            return x + y


    model = Model()
    x = torch.randn((5, 6))
    y = torch.randn((1, 6))
    model(x, y)  # to check it works

    ep = torch.export.export(model, (x, y))
    print(ep)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ExportedProgram:
        class GraphModule(torch.nn.Module):
            def forward(self, x: "f32[5, 6]", y: "f32[1, 6]"):
                 # File: /home/xadupre/github/onnx-diagnostic/_doc/examples/plot_export_with_args_kwargs.py:24 in forward, code: return x + y
                add: "f32[5, 6]" = torch.ops.aten.add.Tensor(x, y);  x = y = None
                return (add,)
            
    Graph signature: 
        # inputs
        x: USER_INPUT
        y: USER_INPUT
    
        # outputs
        add: USER_OUTPUT
    
    Range constraints: {}





.. GENERATED FROM PYTHON SOURCE LINES 36-41

As expected there is no dynamic shapes.
We use :class:`onnx_diagnostic.export.ModelInputs`
to define them from two set of valid inputs.
These inputs must have different value for the dynamic
dimensions.

.. GENERATED FROM PYTHON SOURCE LINES 41-47

.. code-block:: Python


    inputs = [(x, y), (torch.randn((7, 8)), torch.randn((1, 8)))]
    mi = ModelInputs(Model(), inputs)
    ds = mi.guess_dynamic_shapes()
    pprint.pprint(ds)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    (({0: _DimHint(type=<_DimHintType.DYNAMIC: 3>,
                   min=None,
                   max=None,
                   _factory=True),
       1: _DimHint(type=<_DimHintType.DYNAMIC: 3>,
                   min=None,
                   max=None,
                   _factory=True)},
      {1: _DimHint(type=<_DimHintType.DYNAMIC: 3>,
                   min=None,
                   max=None,
                   _factory=True)}),
     {})




.. GENERATED FROM PYTHON SOURCE LINES 48-52

The function returns a tuple with two objects.
The first one for the positional arguments, the other one
for the named arguments. There is no named arguments. We
we used the first result to export.

.. GENERATED FROM PYTHON SOURCE LINES 52-56

.. code-block:: Python


    ep = torch.export.export(model, (x, y), dynamic_shapes=ds[0])
    print(ep)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ExportedProgram:
        class GraphModule(torch.nn.Module):
            def forward(self, x: "f32[s77, s27]", y: "f32[1, s27]"):
                 # 
                sym_size_int_1: "Sym(s27)" = torch.ops.aten.sym_size.int(x, 1)
                sym_size_int_2: "Sym(s27)" = torch.ops.aten.sym_size.int(y, 1)
            
                 # File: /home/xadupre/github/onnx-diagnostic/_doc/examples/plot_export_with_args_kwargs.py:24 in forward, code: return x + y
                add: "f32[s77, s27]" = torch.ops.aten.add.Tensor(x, y);  x = y = None
            
                 # 
                eq: "Sym(True)" = sym_size_int_1 == sym_size_int_2;  sym_size_int_1 = sym_size_int_2 = None
                _assert_scalar_default = torch.ops.aten._assert_scalar.default(eq, "Runtime assertion failed for expression Eq(s27, s94) on node 'eq'");  eq = _assert_scalar_default = None
                return (add,)
            
    Graph signature: 
        # inputs
        x: USER_INPUT
        y: USER_INPUT
    
        # outputs
        add: USER_OUTPUT
    
    Range constraints: {s77: VR[2, int_oo], s27: VR[2, int_oo]}





.. GENERATED FROM PYTHON SOURCE LINES 57-61

kwargs
======

We do the same with named arguments.

.. GENERATED FROM PYTHON SOURCE LINES 61-73

.. code-block:: Python



    class Model(torch.nn.Module):
        def forward(self, x, y):
            return x + y


    model = Model()
    x = torch.randn((5, 6))
    y = torch.randn((1, 6))
    model(x=x, y=y)  # to check it works





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    tensor([[-0.1002, -1.9162, -1.5394,  0.2893,  0.2786, -1.5349],
            [-0.2344,  0.9411, -0.8879,  0.9317,  2.3995, -0.9200],
            [-2.0846,  1.4635,  1.3546, -0.4796,  3.1035,  0.0673],
            [-1.1907, -2.0710,  0.5817, -1.3090,  0.3714, -1.0278],
            [ 0.7187,  0.9313,  0.0831, -0.2877,  1.3310, -2.0918]])



.. GENERATED FROM PYTHON SOURCE LINES 74-75

Two sets of valid inputs.

.. GENERATED FROM PYTHON SOURCE LINES 75-80

.. code-block:: Python

    inputs = [dict(x=x, y=y), dict(x=torch.randn((7, 8)), y=torch.randn((1, 8)))]
    mi = ModelInputs(Model(), inputs)
    ds = mi.guess_dynamic_shapes()
    pprint.pprint(ds)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ((),
     {'x': {0: _DimHint(type=<_DimHintType.DYNAMIC: 3>,
                        min=None,
                        max=None,
                        _factory=True),
            1: _DimHint(type=<_DimHintType.DYNAMIC: 3>,
                        min=None,
                        max=None,
                        _factory=True)},
      'y': {1: _DimHint(type=<_DimHintType.DYNAMIC: 3>,
                        min=None,
                        max=None,
                        _factory=True)}})




.. GENERATED FROM PYTHON SOURCE LINES 81-82

And we export.

.. GENERATED FROM PYTHON SOURCE LINES 82-85

.. code-block:: Python

    ep = torch.export.export(model, (), kwargs=dict(x=x, y=y), dynamic_shapes=ds[1])
    print(ep)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ExportedProgram:
        class GraphModule(torch.nn.Module):
            def forward(self, x: "f32[s77, s27]", y: "f32[1, s27]"):
                 # 
                sym_size_int_1: "Sym(s27)" = torch.ops.aten.sym_size.int(x, 1)
                sym_size_int_2: "Sym(s27)" = torch.ops.aten.sym_size.int(y, 1)
            
                 # File: /home/xadupre/github/onnx-diagnostic/_doc/examples/plot_export_with_args_kwargs.py:65 in forward, code: return x + y
                add: "f32[s77, s27]" = torch.ops.aten.add.Tensor(x, y);  x = y = None
            
                 # 
                eq: "Sym(True)" = sym_size_int_1 == sym_size_int_2;  sym_size_int_1 = sym_size_int_2 = None
                _assert_scalar_default = torch.ops.aten._assert_scalar.default(eq, "Runtime assertion failed for expression Eq(s27, s94) on node 'eq'");  eq = _assert_scalar_default = None
                return (add,)
            
    Graph signature: 
        # inputs
        x: USER_INPUT
        y: USER_INPUT
    
        # outputs
        add: USER_OUTPUT
    
    Range constraints: {s77: VR[2, int_oo], s27: VR[2, int_oo]}





.. GENERATED FROM PYTHON SOURCE LINES 86-91

args and kwargs
===============

:func:`torch.export.export` does not like having dynami shapes
for both args and kwargs. We need to define them using one mechanism.

.. GENERATED FROM PYTHON SOURCE LINES 91-103

.. code-block:: Python



    class Model(torch.nn.Module):
        def forward(self, x, y):
            return x + y


    model = Model()
    x = torch.randn((5, 6))
    y = torch.randn((1, 6))
    model(x, y=y)  # to check it works





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    tensor([[ 1.3323e+00,  1.3445e+00,  6.2509e-01,  2.0291e+00, -6.3673e-02,
              6.0260e-01],
            [ 3.5890e-01,  1.4775e+00,  3.1665e-02, -1.1861e+00, -5.9757e-02,
              1.6030e+00],
            [ 7.7259e-01,  3.9483e+00,  1.1811e+00, -1.8552e+00, -9.0907e-01,
              6.3399e-01],
            [-1.3266e-03,  1.3671e+00, -1.7281e+00, -1.5904e+00, -7.8454e-01,
              1.6444e+00],
            [ 2.8657e+00,  2.2118e+00,  2.6365e+00, -1.4831e+00, -8.6056e-01,
              2.8761e-02]])



.. GENERATED FROM PYTHON SOURCE LINES 104-105

Two sets of valid inputs with positional and names arguments.

.. GENERATED FROM PYTHON SOURCE LINES 105-111

.. code-block:: Python


    inputs = [((x,), dict(y=y)), ((torch.randn((7, 8)),), dict(y=torch.randn((1, 8))))]
    mi = ModelInputs(Model(), inputs)
    ds = mi.guess_dynamic_shapes()
    pprint.pprint(ds)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    (({0: _DimHint(type=<_DimHintType.DYNAMIC: 3>,
                   min=None,
                   max=None,
                   _factory=True),
       1: _DimHint(type=<_DimHintType.DYNAMIC: 3>,
                   min=None,
                   max=None,
                   _factory=True)},),
     {'y': {1: _DimHint(type=<_DimHintType.DYNAMIC: 3>,
                        min=None,
                        max=None,
                        _factory=True)}})




.. GENERATED FROM PYTHON SOURCE LINES 112-116

This does not work with :func:`torch.export.export` so
we use a method to move the positional dynamic shapes to
named one. The method relies on the signature of the
forward method.

.. GENERATED FROM PYTHON SOURCE LINES 116-120

.. code-block:: Python


    new_args, new_kwargs, new_ds = mi.move_to_kwargs(*mi.inputs[0], ds)
    pprint.pprint(new_ds)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ((),
     {'x': {0: _DimHint(type=<_DimHintType.DYNAMIC: 3>,
                        min=None,
                        max=None,
                        _factory=True),
            1: _DimHint(type=<_DimHintType.DYNAMIC: 3>,
                        min=None,
                        max=None,
                        _factory=True)},
      'y': {1: _DimHint(type=<_DimHintType.DYNAMIC: 3>,
                        min=None,
                        max=None,
                        _factory=True)}})




.. GENERATED FROM PYTHON SOURCE LINES 121-122

And we export.

.. GENERATED FROM PYTHON SOURCE LINES 122-126

.. code-block:: Python


    ep = torch.export.export(model, new_args, kwargs=new_kwargs, dynamic_shapes=new_ds[1])
    print(ep)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ExportedProgram:
        class GraphModule(torch.nn.Module):
            def forward(self, x: "f32[s77, s27]", y: "f32[1, s27]"):
                 # 
                sym_size_int_1: "Sym(s27)" = torch.ops.aten.sym_size.int(x, 1)
                sym_size_int_2: "Sym(s27)" = torch.ops.aten.sym_size.int(y, 1)
            
                 # File: /home/xadupre/github/onnx-diagnostic/_doc/examples/plot_export_with_args_kwargs.py:95 in forward, code: return x + y
                add: "f32[s77, s27]" = torch.ops.aten.add.Tensor(x, y);  x = y = None
            
                 # 
                eq: "Sym(True)" = sym_size_int_1 == sym_size_int_2;  sym_size_int_1 = sym_size_int_2 = None
                _assert_scalar_default = torch.ops.aten._assert_scalar.default(eq, "Runtime assertion failed for expression Eq(s27, s94) on node 'eq'");  eq = _assert_scalar_default = None
                return (add,)
            
    Graph signature: 
        # inputs
        x: USER_INPUT
        y: USER_INPUT
    
        # outputs
        add: USER_OUTPUT
    
    Range constraints: {s77: VR[2, int_oo], s27: VR[2, int_oo]}





.. GENERATED FROM PYTHON SOURCE LINES 127-129

.. code-block:: Python


    doc.plot_legend("dynamic shapes\n*args, **kwargs", "torch.export.export", "tomato")



.. image-sg:: /auto_examples/images/sphx_glr_plot_export_with_args_kwargs_001.png
   :alt: plot export with args kwargs
   :srcset: /auto_examples/images/sphx_glr_plot_export_with_args_kwargs_001.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.394 seconds)


.. _sphx_glr_download_auto_examples_plot_export_with_args_kwargs.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_export_with_args_kwargs.ipynb <plot_export_with_args_kwargs.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_export_with_args_kwargs.py <plot_export_with_args_kwargs.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_export_with_args_kwargs.zip <plot_export_with_args_kwargs.zip>`


.. include:: plot_export_with_args_kwargs.recommendations


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
