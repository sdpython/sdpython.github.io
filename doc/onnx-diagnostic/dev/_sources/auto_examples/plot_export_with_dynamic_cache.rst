
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/plot_export_with_dynamic_cache.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_plot_export_with_dynamic_cache.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_plot_export_with_dynamic_cache.py:


.. _l-plot-export-with-dynamic-shape:

===========================================
Export with DynamicCache and dynamic shapes
===========================================

Every LLMs implemented in :epkg:`transformers` use cache.
One of the most used is :class:`transformers.cache_utils.DynamicCache`.
The cache size is dynamic to cope with the growing context.
The example shows a tool which determines the dynamic shapes
for :func:`torch.export.export` based on a set of valid inputs.

Simple Examples
===============

We first look at examples playing positional and names parameters
to understand how :func:`torch.export.export` works.

args
++++

.. GENERATED FROM PYTHON SOURCE LINES 23-44

.. code-block:: Python


    import pprint
    import torch
    from onnx_diagnostic.cache_helpers import make_dynamic_cache
    from onnx_diagnostic.helpers import string_type
    from onnx_diagnostic.export import ModelInputs


    class Model(torch.nn.Module):
        def forward(self, x, y):
            return x + y


    model = Model()
    x = torch.randn((5, 6))
    y = torch.randn((1, 6))
    model(x, y)  # to check it works

    ep = torch.export.export(model, (x, y))
    print(ep)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/xadupre/vv/this312/lib/python3.12/site-packages/torch/backends/mkldnn/__init__.py:78: UserWarning: TF32 acceleration on top of oneDNN is available for Intel GPUs. The current Torch version does not have Intel GPU Support. (Triggered internally at /pytorch/aten/src/ATen/Context.cpp:148.)
      torch._C._set_onednn_allow_tf32(_allow_tf32)
    ExportedProgram:
        class GraphModule(torch.nn.Module):
            def forward(self, x: "f32[5, 6]", y: "f32[1, 6]"):
                 # File: /home/xadupre/github/onnx-diagnostic/_doc/examples/plot_export_with_dynamic_cache.py:33 in forward, code: return x + y
                add: "f32[5, 6]" = torch.ops.aten.add.Tensor(x, y);  x = y = None
                return (add,)
            
    Graph signature: ExportGraphSignature(input_specs=[InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='x'), target=None, persistent=None), InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='y'), target=None, persistent=None)], output_specs=[OutputSpec(kind=<OutputKind.USER_OUTPUT: 1>, arg=TensorArgument(name='add'), target=None)])
    Range constraints: {}





.. GENERATED FROM PYTHON SOURCE LINES 45-50

As expected there is no dynamic shapes.
We use :class:`onnx_diagnostic.export.ModelInputs`
to define them from two set of valid inputs.
These inputs must have different value for the dynamic
dimensions.

.. GENERATED FROM PYTHON SOURCE LINES 50-56

.. code-block:: Python


    inputs = [(x, y), (torch.randn((7, 8)), torch.randn((1, 8)))]
    mi = ModelInputs(Model(), inputs)
    ds = mi.guess_dynamic_shapes()
    pprint.pprint(ds)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    (({0: <_DimHint.DYNAMIC: 3>, 1: <_DimHint.DYNAMIC: 3>},
      {1: <_DimHint.DYNAMIC: 3>}),
     {})




.. GENERATED FROM PYTHON SOURCE LINES 57-61

The function returns a tuple with two objets.
The first one for the positional arguments, the other one
for the named arguments. There is no named argements. We
we used the first result to export.

.. GENERATED FROM PYTHON SOURCE LINES 61-65

.. code-block:: Python


    ep = torch.export.export(model, (x, y), dynamic_shapes=ds[0])
    print(ep)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/xadupre/vv/this312/lib/python3.12/site-packages/torch/backends/mkldnn/__init__.py:78: UserWarning: TF32 acceleration on top of oneDNN is available for Intel GPUs. The current Torch version does not have Intel GPU Support. (Triggered internally at /pytorch/aten/src/ATen/Context.cpp:148.)
      torch._C._set_onednn_allow_tf32(_allow_tf32)
    ExportedProgram:
        class GraphModule(torch.nn.Module):
            def forward(self, x: "f32[s0, s1]", y: "f32[1, s1]"):
                 # File: /home/xadupre/github/onnx-diagnostic/_doc/examples/plot_export_with_dynamic_cache.py:33 in forward, code: return x + y
                add: "f32[s0, s1]" = torch.ops.aten.add.Tensor(x, y);  x = y = None
                return (add,)
            
    Graph signature: ExportGraphSignature(input_specs=[InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='x'), target=None, persistent=None), InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='y'), target=None, persistent=None)], output_specs=[OutputSpec(kind=<OutputKind.USER_OUTPUT: 1>, arg=TensorArgument(name='add'), target=None)])
    Range constraints: {s0: VR[2, int_oo], s1: VR[2, int_oo]}





.. GENERATED FROM PYTHON SOURCE LINES 66-70

kwargs
++++++

We do the same with named argments.

.. GENERATED FROM PYTHON SOURCE LINES 70-82

.. code-block:: Python



    class Model(torch.nn.Module):
        def forward(self, x, y):
            return x + y


    model = Model()
    x = torch.randn((5, 6))
    y = torch.randn((1, 6))
    model(x=x, y=y)  # to check it works





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    tensor([[ 0.9397, -0.8473, -0.5034,  0.9102, -2.5114, -1.2287],
            [ 0.5103,  0.8842, -0.3986,  0.4618, -1.0431, -0.2724],
            [ 0.8794, -0.0992, -1.4024,  0.4944, -2.1435, -1.1627],
            [-0.5496,  0.0733,  1.3360, -0.3264, -0.6669,  1.5105],
            [ 0.9307, -0.6816,  0.0449,  2.1082, -1.4683, -2.3057]])



.. GENERATED FROM PYTHON SOURCE LINES 83-84

Two sets of valid inputs.

.. GENERATED FROM PYTHON SOURCE LINES 84-89

.. code-block:: Python

    inputs = [dict(x=x, y=y), dict(x=torch.randn((7, 8)), y=torch.randn((1, 8)))]
    mi = ModelInputs(Model(), inputs)
    ds = mi.guess_dynamic_shapes()
    pprint.pprint(ds)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ((),
     {'x': {0: <_DimHint.DYNAMIC: 3>, 1: <_DimHint.DYNAMIC: 3>},
      'y': {1: <_DimHint.DYNAMIC: 3>}})




.. GENERATED FROM PYTHON SOURCE LINES 90-91

And we export.

.. GENERATED FROM PYTHON SOURCE LINES 91-94

.. code-block:: Python

    ep = torch.export.export(model, (), kwargs=dict(x=x, y=y), dynamic_shapes=ds[1])
    print(ep)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/xadupre/vv/this312/lib/python3.12/site-packages/torch/backends/mkldnn/__init__.py:78: UserWarning: TF32 acceleration on top of oneDNN is available for Intel GPUs. The current Torch version does not have Intel GPU Support. (Triggered internally at /pytorch/aten/src/ATen/Context.cpp:148.)
      torch._C._set_onednn_allow_tf32(_allow_tf32)
    ExportedProgram:
        class GraphModule(torch.nn.Module):
            def forward(self, x: "f32[s0, s1]", y: "f32[1, s1]"):
                 # File: /home/xadupre/github/onnx-diagnostic/_doc/examples/plot_export_with_dynamic_cache.py:74 in forward, code: return x + y
                add: "f32[s0, s1]" = torch.ops.aten.add.Tensor(x, y);  x = y = None
                return (add,)
            
    Graph signature: ExportGraphSignature(input_specs=[InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='x'), target=None, persistent=None), InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='y'), target=None, persistent=None)], output_specs=[OutputSpec(kind=<OutputKind.USER_OUTPUT: 1>, arg=TensorArgument(name='add'), target=None)])
    Range constraints: {s0: VR[2, int_oo], s1: VR[2, int_oo]}





.. GENERATED FROM PYTHON SOURCE LINES 95-100

args and kwargs
+++++++++++++++

:func:`torch.export.export` does not like having dynami shapes
for both args and kwargs. We need to define them using one mechanism.

.. GENERATED FROM PYTHON SOURCE LINES 100-112

.. code-block:: Python



    class Model(torch.nn.Module):
        def forward(self, x, y):
            return x + y


    model = Model()
    x = torch.randn((5, 6))
    y = torch.randn((1, 6))
    model(x, y=y)  # to check it works





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    tensor([[ 2.1573, -3.0716,  0.1404, -0.1607,  0.6813,  0.7293],
            [ 2.0504,  0.7473, -0.8349, -1.8984, -0.5526,  2.5686],
            [ 2.1651, -1.6772,  1.7744, -1.2770,  1.5858,  1.9893],
            [ 0.9143, -2.0361,  0.5118, -1.4287,  0.3652,  0.7732],
            [ 2.3478, -1.0295,  0.2983, -1.6501, -1.9381,  1.0324]])



.. GENERATED FROM PYTHON SOURCE LINES 113-114

Two sets of valid inputs with positional and names arguments.

.. GENERATED FROM PYTHON SOURCE LINES 114-120

.. code-block:: Python


    inputs = [((x,), dict(y=y)), ((torch.randn((7, 8)),), dict(y=torch.randn((1, 8))))]
    mi = ModelInputs(Model(), inputs)
    ds = mi.guess_dynamic_shapes()
    pprint.pprint(ds)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    (({0: <_DimHint.DYNAMIC: 3>, 1: <_DimHint.DYNAMIC: 3>},),
     {'y': {1: <_DimHint.DYNAMIC: 3>}})




.. GENERATED FROM PYTHON SOURCE LINES 121-125

This does not work with :func:`torch.export.export` so
we use a method to move the positional dynamic shapes to
named one. The method relies on the signature of the
forward method.

.. GENERATED FROM PYTHON SOURCE LINES 125-129

.. code-block:: Python


    new_args, new_kwargs, new_ds = mi.move_to_kwargs(*mi.inputs[0], ds)
    pprint.pprint(new_ds)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ((),
     {'x': {0: <_DimHint.DYNAMIC: 3>, 1: <_DimHint.DYNAMIC: 3>},
      'y': {1: <_DimHint.DYNAMIC: 3>}})




.. GENERATED FROM PYTHON SOURCE LINES 130-131

And we export.

.. GENERATED FROM PYTHON SOURCE LINES 131-135

.. code-block:: Python


    ep = torch.export.export(model, new_args, kwargs=new_kwargs, dynamic_shapes=new_ds[1])
    print(ep)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/xadupre/vv/this312/lib/python3.12/site-packages/torch/backends/mkldnn/__init__.py:78: UserWarning: TF32 acceleration on top of oneDNN is available for Intel GPUs. The current Torch version does not have Intel GPU Support. (Triggered internally at /pytorch/aten/src/ATen/Context.cpp:148.)
      torch._C._set_onednn_allow_tf32(_allow_tf32)
    ExportedProgram:
        class GraphModule(torch.nn.Module):
            def forward(self, x: "f32[s0, s1]", y: "f32[1, s1]"):
                 # File: /home/xadupre/github/onnx-diagnostic/_doc/examples/plot_export_with_dynamic_cache.py:104 in forward, code: return x + y
                add: "f32[s0, s1]" = torch.ops.aten.add.Tensor(x, y);  x = y = None
                return (add,)
            
    Graph signature: ExportGraphSignature(input_specs=[InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='x'), target=None, persistent=None), InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='y'), target=None, persistent=None)], output_specs=[OutputSpec(kind=<OutputKind.USER_OUTPUT: 1>, arg=TensorArgument(name='add'), target=None)])
    Range constraints: {s0: VR[2, int_oo], s1: VR[2, int_oo]}





.. GENERATED FROM PYTHON SOURCE LINES 136-143

DynamicCache
============

:func:`torch.export.export` serializes caches and any custom class
if these serialization functions are provided with is the case for
:class:`transformers.cache_utils.DynamicCache` and ``transformers>=4.50``.
The dynamic shapes must be provided following the serialized form.

.. GENERATED FROM PYTHON SOURCE LINES 143-169

.. code-block:: Python



    class Model(torch.nn.Module):
        def forward(self, cache, z):
            return (
                z
                + cache.key_cache[0]
                + cache.key_cache[1]
                + cache.value_cache[0]
                + cache.value_cache[1]
            )


    model = Model()

    n_layers = 2
    bsize, nheads, slen, dim = 2, 4, 3, 7
    cache = make_dynamic_cache(
        [
            (torch.randn(bsize, nheads, slen, dim), torch.randn(bsize, nheads, slen, dim))
            for i in range(n_layers)
        ]
    )
    z = torch.randn((1, 1, 1, 7))
    model(cache, z)  # to check it works.





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    tensor([[[[-1.1431,  2.3284,  2.3974,  2.7028,  4.9293,  0.0161,  0.4889],
              [ 0.8503,  3.6956,  0.4889,  0.0231, -3.4395,  0.9987, -0.5340],
              [-2.3586, -2.9391, -0.1553,  0.3490, -3.6195, -1.5424,  1.0235]],

             [[ 0.6316, -1.3356,  2.1059,  1.5183,  1.6492, -0.2189,  0.9680],
              [ 0.5722,  1.2987,  0.5123, -0.6324,  1.5700, -3.8322, -0.8635],
              [-1.1962, -3.1115,  1.9584,  4.3009, -0.0111,  2.6433, -2.3269]],

             [[-0.8865, -2.6104,  2.6846,  1.2476,  1.2412,  2.5300, -0.2988],
              [-0.8718, -0.3521,  3.7740, -0.5624,  2.0850,  1.8227, -3.1276],
              [-3.2428, -1.2565, -7.1828,  2.9994,  2.9939,  0.7300, -0.6022]],

             [[-3.5825, -1.1629,  2.8675,  1.9814, -1.9751,  2.6606, -2.0394],
              [-0.6923, -2.0443,  2.7258,  0.7321,  3.0623,  0.2749, -7.3108],
              [-0.6976, -0.7569,  2.9739,  0.5011,  0.1659, -0.9227, -0.1379]]],


            [[[ 1.0686,  0.1134, -0.3604,  2.9398,  3.0537,  1.5776, -0.5598],
              [-2.6952, -2.1284, -0.1546,  2.5455, -1.6859, -1.6322,  1.0587],
              [ 1.1824, -4.9122, -2.4767,  1.9163,  0.1429, -1.7611, -4.7188]],

             [[ 1.5052,  1.9619,  0.5368,  2.1977, -1.2725,  3.0321, -4.0107],
              [-3.8034, -1.9102, -4.7145, -2.2813, -2.0478,  0.6743,  1.5437],
              [ 0.7011, -2.4175,  0.2163,  0.2147,  0.4007,  3.3688, -2.9403]],

             [[-3.3262, -1.9242,  0.9223,  0.6375,  2.2522,  0.4327, -0.7285],
              [-4.5837, -1.0164,  1.3768, -0.4510,  1.6262,  1.8539,  0.7194],
              [-1.3140,  1.4897, -1.3861, -2.0072, -1.7390,  0.3773, -3.0823]],

             [[ 1.0850,  3.7748, -2.8291,  0.8477,  1.2445,  1.1554,  1.5978],
              [-1.6408, -2.7787, -1.0065,  1.2231,  0.6352,  1.7034,  2.4903],
              [-3.3624, -0.3776,  1.7847,  1.9335,  2.0084,  2.7429,  0.8414]]]])



.. GENERATED FROM PYTHON SOURCE LINES 170-171

The cache looks like this:

.. GENERATED FROM PYTHON SOURCE LINES 171-175

.. code-block:: Python


    print(string_type(cache, with_shape=True))






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    DynamicCache(key_cache=#2[T1s2x4x3x7,T1s2x4x3x7], value_cache=#2[T1s2x4x3x7,T1s2x4x3x7])




.. GENERATED FROM PYTHON SOURCE LINES 176-191

.. code-block:: Python


    cache2 = make_dynamic_cache(
        [
            (
                torch.randn(bsize + 1, nheads, slen + 1, dim + 1),
                torch.randn(bsize + 1, nheads, slen + 1, dim + 1),
            )
            for i in range(n_layers)
        ]
    )
    inputs = [
        (cache, z),
        (cache2, torch.randn((1, 1, 1, 8))),
    ]








.. GENERATED FROM PYTHON SOURCE LINES 192-193

And the first set of inputs looks like:

.. GENERATED FROM PYTHON SOURCE LINES 193-195

.. code-block:: Python

    print(string_type(inputs[0], with_shape=True))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    (DynamicCache(key_cache=#2[T1s2x4x3x7,T1s2x4x3x7], value_cache=#2[T1s2x4x3x7,T1s2x4x3x7]),T1s1x1x1x7)




.. GENERATED FROM PYTHON SOURCE LINES 196-197

We can now compute the dynamic shapes.

.. GENERATED FROM PYTHON SOURCE LINES 197-202

.. code-block:: Python


    mi = ModelInputs(Model(), inputs)
    ds = mi.guess_dynamic_shapes()
    pprint.pprint(ds)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    (([[{0: <_DimHint.DYNAMIC: 3>,
         2: <_DimHint.DYNAMIC: 3>,
         3: <_DimHint.DYNAMIC: 3>},
        {0: <_DimHint.DYNAMIC: 3>,
         2: <_DimHint.DYNAMIC: 3>,
         3: <_DimHint.DYNAMIC: 3>}],
       [{0: <_DimHint.DYNAMIC: 3>,
         2: <_DimHint.DYNAMIC: 3>,
         3: <_DimHint.DYNAMIC: 3>},
        {0: <_DimHint.DYNAMIC: 3>,
         2: <_DimHint.DYNAMIC: 3>,
         3: <_DimHint.DYNAMIC: 3>}]],
      {3: <_DimHint.DYNAMIC: 3>}),
     {})




.. GENERATED FROM PYTHON SOURCE LINES 203-204

And finally the export.

.. GENERATED FROM PYTHON SOURCE LINES 204-207

.. code-block:: Python


    ep = torch.export.export(model, inputs[0], dynamic_shapes=ds[0], strict=False)
    print(ep)




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/xadupre/vv/this312/lib/python3.12/site-packages/torch/backends/mkldnn/__init__.py:78: UserWarning: TF32 acceleration on top of oneDNN is available for Intel GPUs. The current Torch version does not have Intel GPU Support. (Triggered internally at /pytorch/aten/src/ATen/Context.cpp:148.)
      torch._C._set_onednn_allow_tf32(_allow_tf32)
    ExportedProgram:
        class GraphModule(torch.nn.Module):
            def forward(self, cache_key_cache_0: "f32[s0, 4, s1, s11]", cache_key_cache_1: "f32[s0, 4, s1, s11]", cache_value_cache_0: "f32[s0, 4, s1, s11]", cache_value_cache_1: "f32[s0, 4, s1, s11]", z: "f32[1, 1, 1, s11]"):
                 # File: /home/xadupre/github/onnx-diagnostic/_doc/examples/plot_export_with_dynamic_cache.py:148 in forward, code: z
                add: "f32[s0, 4, s1, s11]" = torch.ops.aten.add.Tensor(z, cache_key_cache_0);  z = cache_key_cache_0 = None
                add_1: "f32[s0, 4, s1, s11]" = torch.ops.aten.add.Tensor(add, cache_key_cache_1);  add = cache_key_cache_1 = None
                add_2: "f32[s0, 4, s1, s11]" = torch.ops.aten.add.Tensor(add_1, cache_value_cache_0);  add_1 = cache_value_cache_0 = None
                add_3: "f32[s0, 4, s1, s11]" = torch.ops.aten.add.Tensor(add_2, cache_value_cache_1);  add_2 = cache_value_cache_1 = None
                return (add_3,)
            
    Graph signature: ExportGraphSignature(input_specs=[InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='cache_key_cache_0'), target=None, persistent=None), InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='cache_key_cache_1'), target=None, persistent=None), InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='cache_value_cache_0'), target=None, persistent=None), InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='cache_value_cache_1'), target=None, persistent=None), InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='z'), target=None, persistent=None)], output_specs=[OutputSpec(kind=<OutputKind.USER_OUTPUT: 1>, arg=TensorArgument(name='add_3'), target=None)])
    Range constraints: {s0: VR[2, int_oo], s1: VR[2, int_oo], s11: VR[2, int_oo]}






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 5.841 seconds)


.. _sphx_glr_download_auto_examples_plot_export_with_dynamic_cache.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_export_with_dynamic_cache.ipynb <plot_export_with_dynamic_cache.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_export_with_dynamic_cache.py <plot_export_with_dynamic_cache.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_export_with_dynamic_cache.zip <plot_export_with_dynamic_cache.zip>`


.. include:: plot_export_with_dynamic_cache.recommendations


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
