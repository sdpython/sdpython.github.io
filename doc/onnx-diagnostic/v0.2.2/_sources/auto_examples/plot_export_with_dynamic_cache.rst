
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/plot_export_with_dynamic_cache.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_plot_export_with_dynamic_cache.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_plot_export_with_dynamic_cache.py:


.. _l-plot-export-with-dynamic-shape:

===========================================
Export with DynamicCache and dynamic shapes
===========================================

Every LLMs implemented in :epkg:`transformers` use cache.
One of the most used is :class:`transformers.cache_utils.DynamicCache`.
The cache size is dynamic to cope with the growing context.
The example shows a tool which determines the dynamic shapes
for :func:`torch.export.export` based on a set of valid inputs.

Simple Examples
===============

We first look at examples playing positional and names parameters
to understand how :func:`torch.export.export` works.

args
++++

.. GENERATED FROM PYTHON SOURCE LINES 23-31

.. code-block:: Python


    import pprint
    import torch
    from onnx_diagnostic import doc
    from onnx_diagnostic.cache_helpers import make_dynamic_cache
    from onnx_diagnostic.helpers import string_type
    from onnx_diagnostic.export import ModelInputs








.. GENERATED FROM PYTHON SOURCE LINES 32-34

We need addition import in case ``transformers<4.50``.
Exporting DynamicCache is not supported before that.

.. GENERATED FROM PYTHON SOURCE LINES 34-51

.. code-block:: Python

    from onnx_diagnostic.ext_test_case import has_transformers
    from onnx_diagnostic.torch_export_patches import bypass_export_some_errors


    class Model(torch.nn.Module):
        def forward(self, x, y):
            return x + y


    model = Model()
    x = torch.randn((5, 6))
    y = torch.randn((1, 6))
    model(x, y)  # to check it works

    ep = torch.export.export(model, (x, y))
    print(ep)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/xadupre/vv/this312/lib/python3.12/site-packages/torch/backends/mkldnn/__init__.py:78: UserWarning: TF32 acceleration on top of oneDNN is available for Intel GPUs. The current Torch version does not have Intel GPU Support. (Triggered internally at /pytorch/aten/src/ATen/Context.cpp:148.)
      torch._C._set_onednn_allow_tf32(_allow_tf32)
    ExportedProgram:
        class GraphModule(torch.nn.Module):
            def forward(self, x: "f32[5, 6]", y: "f32[1, 6]"):
                 # File: /home/xadupre/github/onnx-diagnostic/_doc/examples/plot_export_with_dynamic_cache.py:40 in forward, code: return x + y
                add: "f32[5, 6]" = torch.ops.aten.add.Tensor(x, y);  x = y = None
                return (add,)
            
    Graph signature: 
        # inputs
        x: USER_INPUT
        y: USER_INPUT
    
        # outputs
        add: USER_OUTPUT
    
    Range constraints: {}





.. GENERATED FROM PYTHON SOURCE LINES 52-57

As expected there is no dynamic shapes.
We use :class:`onnx_diagnostic.export.ModelInputs`
to define them from two set of valid inputs.
These inputs must have different value for the dynamic
dimensions.

.. GENERATED FROM PYTHON SOURCE LINES 57-63

.. code-block:: Python


    inputs = [(x, y), (torch.randn((7, 8)), torch.randn((1, 8)))]
    mi = ModelInputs(Model(), inputs)
    ds = mi.guess_dynamic_shapes()
    pprint.pprint(ds)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    (({0: _DimHint(type=<_DimHintType.DYNAMIC: 3>),
       1: _DimHint(type=<_DimHintType.DYNAMIC: 3>)},
      {1: _DimHint(type=<_DimHintType.DYNAMIC: 3>)}),
     {})




.. GENERATED FROM PYTHON SOURCE LINES 64-68

The function returns a tuple with two objects.
The first one for the positional arguments, the other one
for the named arguments. There is no named arguments. We
we used the first result to export.

.. GENERATED FROM PYTHON SOURCE LINES 68-72

.. code-block:: Python


    ep = torch.export.export(model, (x, y), dynamic_shapes=ds[0])
    print(ep)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/xadupre/vv/this312/lib/python3.12/site-packages/torch/backends/mkldnn/__init__.py:78: UserWarning: TF32 acceleration on top of oneDNN is available for Intel GPUs. The current Torch version does not have Intel GPU Support. (Triggered internally at /pytorch/aten/src/ATen/Context.cpp:148.)
      torch._C._set_onednn_allow_tf32(_allow_tf32)
    ExportedProgram:
        class GraphModule(torch.nn.Module):
            def forward(self, x: "f32[s0, s1]", y: "f32[1, s1]"):
                 # File: /home/xadupre/github/onnx-diagnostic/_doc/examples/plot_export_with_dynamic_cache.py:40 in forward, code: return x + y
                add: "f32[s0, s1]" = torch.ops.aten.add.Tensor(x, y);  x = y = None
                return (add,)
            
    Graph signature: 
        # inputs
        x: USER_INPUT
        y: USER_INPUT
    
        # outputs
        add: USER_OUTPUT
    
    Range constraints: {s0: VR[2, int_oo], s1: VR[2, int_oo]}





.. GENERATED FROM PYTHON SOURCE LINES 73-77

kwargs
++++++

We do the same with named arguments.

.. GENERATED FROM PYTHON SOURCE LINES 77-89

.. code-block:: Python



    class Model(torch.nn.Module):
        def forward(self, x, y):
            return x + y


    model = Model()
    x = torch.randn((5, 6))
    y = torch.randn((1, 6))
    model(x=x, y=y)  # to check it works





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    tensor([[-0.1907, -0.7621, -0.9933, -0.4280,  0.2482, -0.8822],
            [ 1.1283, -0.6861, -1.4021, -0.4876, -1.6856, -0.7515],
            [ 0.5832, -1.2181, -1.8152,  1.0054,  0.0052, -1.4477],
            [ 1.4633, -0.9256, -2.0666, -2.9153,  0.2201,  0.0580],
            [ 1.8739, -0.1999, -2.0851, -0.7901,  0.6253, -1.8396]])



.. GENERATED FROM PYTHON SOURCE LINES 90-91

Two sets of valid inputs.

.. GENERATED FROM PYTHON SOURCE LINES 91-96

.. code-block:: Python

    inputs = [dict(x=x, y=y), dict(x=torch.randn((7, 8)), y=torch.randn((1, 8)))]
    mi = ModelInputs(Model(), inputs)
    ds = mi.guess_dynamic_shapes()
    pprint.pprint(ds)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ((),
     {'x': {0: _DimHint(type=<_DimHintType.DYNAMIC: 3>),
            1: _DimHint(type=<_DimHintType.DYNAMIC: 3>)},
      'y': {1: _DimHint(type=<_DimHintType.DYNAMIC: 3>)}})




.. GENERATED FROM PYTHON SOURCE LINES 97-98

And we export.

.. GENERATED FROM PYTHON SOURCE LINES 98-101

.. code-block:: Python

    ep = torch.export.export(model, (), kwargs=dict(x=x, y=y), dynamic_shapes=ds[1])
    print(ep)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/xadupre/vv/this312/lib/python3.12/site-packages/torch/backends/mkldnn/__init__.py:78: UserWarning: TF32 acceleration on top of oneDNN is available for Intel GPUs. The current Torch version does not have Intel GPU Support. (Triggered internally at /pytorch/aten/src/ATen/Context.cpp:148.)
      torch._C._set_onednn_allow_tf32(_allow_tf32)
    ExportedProgram:
        class GraphModule(torch.nn.Module):
            def forward(self, x: "f32[s0, s1]", y: "f32[1, s1]"):
                 # File: /home/xadupre/github/onnx-diagnostic/_doc/examples/plot_export_with_dynamic_cache.py:81 in forward, code: return x + y
                add: "f32[s0, s1]" = torch.ops.aten.add.Tensor(x, y);  x = y = None
                return (add,)
            
    Graph signature: 
        # inputs
        x: USER_INPUT
        y: USER_INPUT
    
        # outputs
        add: USER_OUTPUT
    
    Range constraints: {s0: VR[2, int_oo], s1: VR[2, int_oo]}





.. GENERATED FROM PYTHON SOURCE LINES 102-107

args and kwargs
+++++++++++++++

:func:`torch.export.export` does not like having dynami shapes
for both args and kwargs. We need to define them using one mechanism.

.. GENERATED FROM PYTHON SOURCE LINES 107-119

.. code-block:: Python



    class Model(torch.nn.Module):
        def forward(self, x, y):
            return x + y


    model = Model()
    x = torch.randn((5, 6))
    y = torch.randn((1, 6))
    model(x, y=y)  # to check it works





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    tensor([[ 2.1433,  1.7766,  1.4559,  0.2769,  3.0040, -0.6467],
            [ 2.5062,  1.5157,  0.2793,  0.2543,  1.9858,  2.7820],
            [ 3.0768, -0.5146,  1.6343, -0.5864,  1.9215,  1.3355],
            [ 1.6516,  1.2765, -0.8712,  0.9742,  2.0662, -0.8105],
            [ 0.9641,  0.8993,  1.9193,  1.6032,  2.7979,  0.5749]])



.. GENERATED FROM PYTHON SOURCE LINES 120-121

Two sets of valid inputs with positional and names arguments.

.. GENERATED FROM PYTHON SOURCE LINES 121-127

.. code-block:: Python


    inputs = [((x,), dict(y=y)), ((torch.randn((7, 8)),), dict(y=torch.randn((1, 8))))]
    mi = ModelInputs(Model(), inputs)
    ds = mi.guess_dynamic_shapes()
    pprint.pprint(ds)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    (({0: _DimHint(type=<_DimHintType.DYNAMIC: 3>),
       1: _DimHint(type=<_DimHintType.DYNAMIC: 3>)},),
     {'y': {1: _DimHint(type=<_DimHintType.DYNAMIC: 3>)}})




.. GENERATED FROM PYTHON SOURCE LINES 128-132

This does not work with :func:`torch.export.export` so
we use a method to move the positional dynamic shapes to
named one. The method relies on the signature of the
forward method.

.. GENERATED FROM PYTHON SOURCE LINES 132-136

.. code-block:: Python


    new_args, new_kwargs, new_ds = mi.move_to_kwargs(*mi.inputs[0], ds)
    pprint.pprint(new_ds)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ((),
     {'x': {0: _DimHint(type=<_DimHintType.DYNAMIC: 3>),
            1: _DimHint(type=<_DimHintType.DYNAMIC: 3>)},
      'y': {1: _DimHint(type=<_DimHintType.DYNAMIC: 3>)}})




.. GENERATED FROM PYTHON SOURCE LINES 137-138

And we export.

.. GENERATED FROM PYTHON SOURCE LINES 138-142

.. code-block:: Python


    ep = torch.export.export(model, new_args, kwargs=new_kwargs, dynamic_shapes=new_ds[1])
    print(ep)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/xadupre/vv/this312/lib/python3.12/site-packages/torch/backends/mkldnn/__init__.py:78: UserWarning: TF32 acceleration on top of oneDNN is available for Intel GPUs. The current Torch version does not have Intel GPU Support. (Triggered internally at /pytorch/aten/src/ATen/Context.cpp:148.)
      torch._C._set_onednn_allow_tf32(_allow_tf32)
    ExportedProgram:
        class GraphModule(torch.nn.Module):
            def forward(self, x: "f32[s0, s1]", y: "f32[1, s1]"):
                 # File: /home/xadupre/github/onnx-diagnostic/_doc/examples/plot_export_with_dynamic_cache.py:111 in forward, code: return x + y
                add: "f32[s0, s1]" = torch.ops.aten.add.Tensor(x, y);  x = y = None
                return (add,)
            
    Graph signature: 
        # inputs
        x: USER_INPUT
        y: USER_INPUT
    
        # outputs
        add: USER_OUTPUT
    
    Range constraints: {s0: VR[2, int_oo], s1: VR[2, int_oo]}





.. GENERATED FROM PYTHON SOURCE LINES 143-150

DynamicCache
============

:func:`torch.export.export` serializes caches and any custom class
if these serialization functions are provided with is the case for
:class:`transformers.cache_utils.DynamicCache` and ``transformers>=4.50``.
The dynamic shapes must be provided following the serialized form.

.. GENERATED FROM PYTHON SOURCE LINES 150-176

.. code-block:: Python



    class Model(torch.nn.Module):
        def forward(self, cache, z):
            return (
                z
                + cache.key_cache[0]
                + cache.key_cache[1]
                + cache.value_cache[0]
                + cache.value_cache[1]
            )


    model = Model()

    n_layers = 2
    bsize, nheads, slen, dim = 2, 4, 3, 7
    cache = make_dynamic_cache(
        [
            (torch.randn(bsize, nheads, slen, dim), torch.randn(bsize, nheads, slen, dim))
            for i in range(n_layers)
        ]
    )
    z = torch.randn((1, 1, 1, 7))
    model(cache, z)  # to check it works.





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    tensor([[[[ 3.2948, -2.3341,  5.5156, -3.3110,  1.1793,  3.0362, -2.0330],
              [ 2.0559, -0.8892,  7.8310, -1.2633,  0.7150, -0.1940, -3.1583],
              [ 4.6231, -1.2430,  3.3812, -5.5519, -0.4553,  1.0659, -3.7541]],

             [[ 1.0174, -1.7269,  2.9931, -3.9530, -1.7706, -0.7845, -2.4360],
              [-3.4887,  0.1838,  3.2544, -5.4428, -0.7190,  2.5350,  2.0892],
              [-2.5922,  3.5135,  2.8468, -1.4346,  1.1675,  0.5511, -2.0101]],

             [[-1.0250,  0.1240,  4.9803, -1.7021, -0.7457,  4.0490,  0.1044],
              [-0.3484,  4.7805,  1.3388,  0.8150,  0.8880, -0.0342,  1.0541],
              [ 0.5150,  1.4858,  1.7790,  0.0298,  2.8305,  0.2218, -1.0627]],

             [[-2.8092,  0.4966,  0.0133, -2.9528, -0.8390,  2.2329, -1.6891],
              [-1.9272, -3.6029,  1.1770, -3.0614, -0.8731,  0.8977, -4.1014],
              [ 0.6965,  5.1808,  2.0320,  1.2154, -2.2620,  1.4216, -2.2604]]],


            [[[ 1.3829,  1.4123,  2.3073, -3.8361, -0.4026,  2.7661, -0.8408],
              [ 3.4090,  0.6807,  1.2851, -3.3721,  0.1576, -1.4265, -0.3724],
              [ 3.2025,  2.2756,  3.4423, -2.3453,  0.6254, -0.0120,  2.9386]],

             [[-0.8063, -0.6773, -0.4880, -1.4387, -0.4266, -1.7512, -4.1522],
              [-0.7704, -3.5975,  3.8179, -1.7086,  3.1508, -1.6149, -2.5825],
              [ 2.0617,  1.4101, -0.0190, -1.3891,  2.7878,  2.3379, -4.9502]],

             [[ 0.2573, -2.6394,  3.7354, -0.7773, -0.2046, -0.7724, -0.3855],
              [ 0.4012,  0.7915,  1.9160, -4.8063,  1.7646,  2.1163,  0.1220],
              [ 0.7011, -1.2203,  1.5855, -0.5436,  0.3712, -2.4435, -2.1943]],

             [[ 1.8291, -2.8181,  3.0042, -3.8385,  0.8303, -0.6401, -1.5043],
              [ 1.3032, -1.8963,  5.6827, -2.4456,  0.4816, -0.1203, -2.6287],
              [-3.6489, -1.4924,  4.7003,  0.7011, -2.9314,  3.4291, -4.1461]]]])



.. GENERATED FROM PYTHON SOURCE LINES 177-178

The cache looks like this:

.. GENERATED FROM PYTHON SOURCE LINES 178-182

.. code-block:: Python


    print(string_type(cache, with_shape=True))






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    DynamicCache(key_cache=#2[T1s2x4x3x7,T1s2x4x3x7], value_cache=#2[T1s2x4x3x7,T1s2x4x3x7])




.. GENERATED FROM PYTHON SOURCE LINES 183-198

.. code-block:: Python


    cache2 = make_dynamic_cache(
        [
            (
                torch.randn(bsize + 1, nheads, slen + 1, dim + 1),
                torch.randn(bsize + 1, nheads, slen + 1, dim + 1),
            )
            for i in range(n_layers)
        ]
    )
    inputs = [
        (cache, z),
        (cache2, torch.randn((1, 1, 1, 8))),
    ]








.. GENERATED FROM PYTHON SOURCE LINES 199-200

And the first set of inputs looks like:

.. GENERATED FROM PYTHON SOURCE LINES 200-202

.. code-block:: Python

    print(string_type(inputs[0], with_shape=True))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    (DynamicCache(key_cache=#2[T1s2x4x3x7,T1s2x4x3x7], value_cache=#2[T1s2x4x3x7,T1s2x4x3x7]),T1s1x1x1x7)




.. GENERATED FROM PYTHON SOURCE LINES 203-204

We can now compute the dynamic shapes.

.. GENERATED FROM PYTHON SOURCE LINES 204-209

.. code-block:: Python


    mi = ModelInputs(Model(), inputs)
    ds = mi.guess_dynamic_shapes()
    pprint.pprint(ds)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    (([[{0: _DimHint(type=<_DimHintType.DYNAMIC: 3>),
         2: _DimHint(type=<_DimHintType.DYNAMIC: 3>),
         3: _DimHint(type=<_DimHintType.DYNAMIC: 3>)},
        {0: _DimHint(type=<_DimHintType.DYNAMIC: 3>),
         2: _DimHint(type=<_DimHintType.DYNAMIC: 3>),
         3: _DimHint(type=<_DimHintType.DYNAMIC: 3>)}],
       [{0: _DimHint(type=<_DimHintType.DYNAMIC: 3>),
         2: _DimHint(type=<_DimHintType.DYNAMIC: 3>),
         3: _DimHint(type=<_DimHintType.DYNAMIC: 3>)},
        {0: _DimHint(type=<_DimHintType.DYNAMIC: 3>),
         2: _DimHint(type=<_DimHintType.DYNAMIC: 3>),
         3: _DimHint(type=<_DimHintType.DYNAMIC: 3>)}]],
      {3: _DimHint(type=<_DimHintType.DYNAMIC: 3>)}),
     {})




.. GENERATED FROM PYTHON SOURCE LINES 210-216

And finally the export.
The export is simple if ``transformers>=4.50``, otherwise,
transformers needs to be patched.
:func:`onnx_diagnostic.torch_export_patches.bypass_export_some_errors`
registers functions to serialize ``DynamicCache``. This one is modified to make
the shape inference implemented in :epkg:`torch` happy.

.. GENERATED FROM PYTHON SOURCE LINES 216-226

.. code-block:: Python


    if has_transformers("4.50"):
        ep = torch.export.export(model, inputs[0], dynamic_shapes=ds[0], strict=False)
    else:
        with bypass_export_some_errors(patch_transformers=True) as modificator:
            ep = torch.export.export(
                model, modificator(inputs[0]), dynamic_shapes=ds[0], strict=False
            )
    print(ep)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/xadupre/vv/this312/lib/python3.12/site-packages/torch/backends/mkldnn/__init__.py:78: UserWarning: TF32 acceleration on top of oneDNN is available for Intel GPUs. The current Torch version does not have Intel GPU Support. (Triggered internally at /pytorch/aten/src/ATen/Context.cpp:148.)
      torch._C._set_onednn_allow_tf32(_allow_tf32)
    ExportedProgram:
        class GraphModule(torch.nn.Module):
            def forward(self, cache_key_cache_0: "f32[s0, 4, s1, s11]", cache_key_cache_1: "f32[s0, 4, s1, s11]", cache_value_cache_0: "f32[s0, 4, s1, s11]", cache_value_cache_1: "f32[s0, 4, s1, s11]", z: "f32[1, 1, 1, s11]"):
                 # File: /home/xadupre/github/onnx-diagnostic/_doc/examples/plot_export_with_dynamic_cache.py:155 in forward, code: z
                add: "f32[s0, 4, s1, s11]" = torch.ops.aten.add.Tensor(z, cache_key_cache_0);  z = cache_key_cache_0 = None
                add_1: "f32[s0, 4, s1, s11]" = torch.ops.aten.add.Tensor(add, cache_key_cache_1);  add = cache_key_cache_1 = None
                add_2: "f32[s0, 4, s1, s11]" = torch.ops.aten.add.Tensor(add_1, cache_value_cache_0);  add_1 = cache_value_cache_0 = None
                add_3: "f32[s0, 4, s1, s11]" = torch.ops.aten.add.Tensor(add_2, cache_value_cache_1);  add_2 = cache_value_cache_1 = None
                return (add_3,)
            
    Graph signature: 
        # inputs
        cache_key_cache_0: USER_INPUT
        cache_key_cache_1: USER_INPUT
        cache_value_cache_0: USER_INPUT
        cache_value_cache_1: USER_INPUT
        z: USER_INPUT
    
        # outputs
        add_3: USER_OUTPUT
    
    Range constraints: {s0: VR[2, int_oo], s1: VR[2, int_oo], s11: VR[2, int_oo]}





.. GENERATED FROM PYTHON SOURCE LINES 227-229

.. code-block:: Python


    doc.plot_legend("dynamic shapes\nfor cache", "torch.export.export", "tomato")



.. image-sg:: /auto_examples/images/sphx_glr_plot_export_with_dynamic_cache_001.png
   :alt: plot export with dynamic cache
   :srcset: /auto_examples/images/sphx_glr_plot_export_with_dynamic_cache_001.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 7.257 seconds)


.. _sphx_glr_download_auto_examples_plot_export_with_dynamic_cache.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_export_with_dynamic_cache.ipynb <plot_export_with_dynamic_cache.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_export_with_dynamic_cache.py <plot_export_with_dynamic_cache.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_export_with_dynamic_cache.zip <plot_export_with_dynamic_cache.zip>`


.. include:: plot_export_with_dynamic_cache.recommendations


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
