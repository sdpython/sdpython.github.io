
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/plot_tsp.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_plot_tsp.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_plot_tsp.py:


=============================================
Réflexions autour du voyage de commerce (TSP)
=============================================

Le `problème du voyageur de commerce
<https://fr.wikipedia.org/wiki/Probl%C3%A8me_du_voyageur_de_commerce)>`_
consiste à trouver le plus court chemin passant par toutes les villes.
On parle aussi de `circuit hamiltonien <https://en.wikipedia.org/wiki/Hamiltonian_path)>`_
qui consiste à trouver le plus court chemin passant par tous les noeuds d'un graphe.
Ce programme explore quelques solutions approchées et intuitives.

Ce problème est `NP-complet <http://fr.wikipedia.org/wiki/Probl%C3%A8me_NP-complet)>`_
à savoir qu'il n'existe pas d'algorithme qui permette de trouver la solution avec un
coût polynômial. C'est aussi un problème différent du `plus court chemin dans un graphe
<https://fr.wikipedia.org/wiki/Probl%C3%A8mes_de_cheminement)>`_
qui consiste à trouver le plus court chemin reliant deux noeuds d'un graphe
(mais pas forcément tous les noeuds de ce graphe).

Des villes tirées au hasard
===========================

.. GENERATED FROM PYTHON SOURCE LINES 24-35

.. code-block:: default


    import random
    import matplotlib.pyplot as plt

    n = 30
    x = [random.random() for _ in range(n)]
    y = [random.random() for _ in range(n)]

    plt.plot(x, y, "o")





.. image-sg:: /auto_examples/images/sphx_glr_plot_tsp_001.png
   :alt: plot tsp
   :srcset: /auto_examples/images/sphx_glr_plot_tsp_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    [<matplotlib.lines.Line2D object at 0x7f3ea07cb040>]



.. GENERATED FROM PYTHON SOURCE LINES 36-38

Un parcours aléatoire de tous les noeuds de graphe
donnera quelque chose de très éloigné de la solution optimale :

.. GENERATED FROM PYTHON SOURCE LINES 38-42

.. code-block:: default


    plt.plot(x + [x[0]], y + [y[0]], "o-")





.. image-sg:: /auto_examples/images/sphx_glr_plot_tsp_002.png
   :alt: plot tsp
   :srcset: /auto_examples/images/sphx_glr_plot_tsp_002.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    [<matplotlib.lines.Line2D object at 0x7f3ea401a170>]



.. GENERATED FROM PYTHON SOURCE LINES 43-53

Croisements
===========

La première constation est que le chemin ne peut pas être optimal
car des arcs se croisent. On en déduit qu'une façon d'améliorer ce
chemin est de *décroiser* certaines parties. On peut par exemple
choisir deux points au hasard, retourner la partie du chemin au milieu
de ces deux points et voir si la longueur du chemin s'en trouve diminuée.
On peut également parcourir toutes les paires de noeuds possibles.
C'est ce qui est implémenté ci-dessous.

.. GENERATED FROM PYTHON SOURCE LINES 53-69

.. code-block:: default



    def longueur(x, y, ordre):
        i = ordre[-1]
        x0, y0 = x[i], y[i]
        d = 0
        for o in ordre:
            x1, y1 = x[o], y[o]
            d += (x0 - x1) ** 2 + (y0 - y1) ** 2
            x0, y0 = x1, y1
        return d


    ordre = list(range(len(x)))
    print("longueur initiale", longueur(x, y, ordre))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    longueur initiale 7.591639460504804




.. GENERATED FROM PYTHON SOURCE LINES 70-71

Permutations.

.. GENERATED FROM PYTHON SOURCE LINES 71-99

.. code-block:: default



    def permutation(x, y, ordre):
        d = longueur(x, y, ordre)
        d0 = d + 1
        it = 1
        while d < d0:
            it += 1
            print("iteration", it, "d=", d)
            d0 = d
            for i in range(0, len(ordre) - 1):
                for j in range(i + 2, len(ordre)):
                    r = ordre[i:j].copy()
                    r.reverse()
                    ordre2 = ordre[:i] + r + ordre[j:]
                    t = longueur(x, y, ordre2)
                    if t < d:
                        d = t
                        ordre = ordre2
        return ordre


    ordre = permutation(x, y, list(range(len(x))))
    print("longueur min", longueur(x, y, ordre))
    xo = [x[o] for o in ordre + [ordre[0]]]
    yo = [y[o] for o in ordre + [ordre[0]]]
    plt.plot(xo, yo, "o-")




.. image-sg:: /auto_examples/images/sphx_glr_plot_tsp_003.png
   :alt: plot tsp
   :srcset: /auto_examples/images/sphx_glr_plot_tsp_003.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    iteration 2 d= 7.591639460504804
    iteration 3 d= 1.280245713990652
    iteration 4 d= 1.1021208511658813
    iteration 5 d= 1.0408569292868148
    longueur min 1.0408569292868148

    [<matplotlib.lines.Line2D object at 0x7f3ea32cd900>]



.. GENERATED FROM PYTHON SOURCE LINES 100-103

Voilà qui est mieux. Maintenant, supposons que nous faisons une
erreur lors du calcul de la distance : nous oublions le dernier
arc qui boucle le chemin du dernier noeud au premier.

.. GENERATED FROM PYTHON SOURCE LINES 103-120

.. code-block:: default



    def longueur(x, y, ordre):
        # on change cette fonction
        d = 0
        for i in range(1, len(ordre)):
            n = ordre[i - 1]
            o = ordre[i]
            x0, y0 = x[n], y[n]
            x1, y1 = x[o], y[o]
            d += (x0 - x1) ** 2 + (y0 - y1) ** 2
        return d


    ordre = list(range(len(x)))
    print("longueur initiale", longueur(x, y, ordre))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    longueur initiale 7.562135570495248




.. GENERATED FROM PYTHON SOURCE LINES 121-122

Et graphiquement.

.. GENERATED FROM PYTHON SOURCE LINES 122-130

.. code-block:: default


    ordre = permutation(x, y, list(range(len(x))))
    print("longueur min", longueur(x, y, ordre))
    xo = [x[o] for o in ordre]
    yo = [y[o] for o in ordre]
    plt.plot(xo, yo, "o-")





.. image-sg:: /auto_examples/images/sphx_glr_plot_tsp_004.png
   :alt: plot tsp
   :srcset: /auto_examples/images/sphx_glr_plot_tsp_004.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    iteration 2 d= 7.562135570495248
    iteration 3 d= 1.3299258378946244
    iteration 4 d= 1.0150035866963831
    iteration 5 d= 0.9821189553185677
    longueur min 0.9821189553185677

    [<matplotlib.lines.Line2D object at 0x7f3ea3db9f30>]



.. GENERATED FROM PYTHON SOURCE LINES 131-141

Noeud de départ constant
========================

Jusque ici, tout concorde. Le chemin est plus court en ce sens qu'il
oublie délibérément l'arc de bouclage que l'algorithme a tendance à
choisir grand. Pour gagner du temps de calcul, un développeur se dit
que le noeud de départ peut être constant. Après tout, le chemin est
une boucle, elle passera toujours par le premier noeud. Qu'il soit en
première position ne change rien et puis inverser une moitié, c'est
équivalent à inverser l'autre moitié. On fait donc juste une modification :

.. GENERATED FROM PYTHON SOURCE LINES 141-188

.. code-block:: default



    def longueur(x, y, ordre):
        i = ordre[-1]
        x0, y0 = x[i], y[i]
        d = 0
        for o in ordre:
            x1, y1 = x[o], y[o]
            d += (x0 - x1) ** 2 + (y0 - y1) ** 2
            x0, y0 = x1, y1
        return d


    ordre = list(range(len(x)))
    print("longueur initiale", longueur(x, y, ordre))


    def permutation(x, y, ordre):
        d = longueur(x, y, ordre)
        d0 = d + 1
        it = 1
        while d < d0:
            it += 1
            print("iteration", it, "d=", d, "ordre[0]", ordre[0])
            d0 = d
            for i in range(
                1, len(ordre) - 1
            ):  # on part de 1 et plus de 0, on est sûr que le premier noeud ne bouge pas
                for j in range(i + 2, len(ordre)):
                    r = ordre[i:j].copy()
                    r.reverse()
                    ordre2 = ordre[:i] + r + ordre[j:]
                    t = longueur(x, y, ordre2)
                    if t < d:
                        d = t
                        ordre = ordre2
        return ordre


    ordre = permutation(x, y, list(range(len(x))))
    print("longueur min", longueur(x, y, ordre))
    xo = [x[o] for o in ordre + [ordre[0]]]
    yo = [y[o] for o in ordre + [ordre[0]]]
    plt.plot(xo, yo, "o-")
    plt.text(xo[0], yo[0], "0", color="r", weight="bold", size="x-large")
    plt.text(xo[-2], yo[-2], "N-1", color="r", weight="bold", size="x-large")




.. image-sg:: /auto_examples/images/sphx_glr_plot_tsp_005.png
   :alt: plot tsp
   :srcset: /auto_examples/images/sphx_glr_plot_tsp_005.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    longueur initiale 7.591639460504804
    iteration 2 d= 7.591639460504804 ordre[0] 0
    iteration 3 d= 1.5434975610321982 ordre[0] 0
    iteration 4 d= 1.20274238713068 ordre[0] 0
    iteration 5 d= 1.1189504173875002 ordre[0] 0
    iteration 6 d= 1.0799367540546025 ordre[0] 0
    longueur min 1.0799367540546025

    Text(0.08569860217693148, 0.19602548484868, 'N-1')



.. GENERATED FROM PYTHON SOURCE LINES 189-198

Le résultat attendu n'est pas celui qu'on observe.
Est-ce une erreur d'implémentation ou
une erreur de raisonnement ? J'étais pourtant sûr que mon raisonnement était correct
et j'aurais tort d'en douter. C'est une erreur d'implémentation.
Lorsqu'on``for j in range(i+2,len(ordre)):`` et  ``r = ordre[i:j].copy()``,
on écrit que ``j`` va de ``i+2`` inclus à ``len(ordre)`` exclu. Puis
lorsqu'on écrit ``ordre[i:j]``, l'indice ``j`` est exclu ! Autrement dit,
dans cette implémentation, le premier noeud et le dernier noeud ne bougeront
jamais ! On s'empresse de corriger cela.

.. GENERATED FROM PYTHON SOURCE LINES 198-235

.. code-block:: default



    ordre = list(range(len(x)))
    print("longueur initiale", longueur(x, y, ordre))


    def permutation(x, y, ordre):
        d = longueur(x, y, ordre)
        d0 = d + 1
        it = 1
        while d < d0:
            it += 1
            print("iteration", it, "d=", d, "ordre[0]", ordre[0])
            d0 = d
            for i in range(
                1, len(ordre) - 1
            ):  # on part de 1 et plus de 0, on est sûr que le premier noeud ne bouge pas
                for j in range(i + 2, len(ordre) + 1):  # correction !
                    r = ordre[i:j].copy()
                    r.reverse()
                    ordre2 = ordre[:i] + r + ordre[j:]
                    t = longueur(x, y, ordre2)
                    if t < d:
                        d = t
                        ordre = ordre2
        return ordre


    ordre = permutation(x, y, list(range(len(x))))
    print("longueur min", longueur(x, y, ordre))
    xo = [x[o] for o in ordre + [ordre[0]]]
    yo = [y[o] for o in ordre + [ordre[0]]]
    plt.plot(xo, yo, "o-")
    plt.text(xo[0], yo[0], "0", color="r", weight="bold", size="x-large")
    plt.text(xo[-2], yo[-2], "N-1", color="r", weight="bold", size="x-large")





.. image-sg:: /auto_examples/images/sphx_glr_plot_tsp_006.png
   :alt: plot tsp
   :srcset: /auto_examples/images/sphx_glr_plot_tsp_006.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    longueur initiale 7.591639460504804
    iteration 2 d= 7.591639460504804 ordre[0] 0
    iteration 3 d= 1.505026971860366 ordre[0] 0
    iteration 4 d= 1.1784049778542287 ordre[0] 0
    iteration 5 d= 1.094613008111049 ordre[0] 0
    iteration 6 d= 1.055599344778151 ordre[0] 0
    longueur min 1.055599344778151

    Text(0.09092243836310065, 0.142781397955138, 'N-1')



.. GENERATED FROM PYTHON SOURCE LINES 236-250

Pas parfait mais conforme à nos attentes (les miennes en tout cas) !
Soit dit en passant, la première version de l'algorithme
laissait déjà le dernier noeud inchangé.

Un peu d'aléatoire en plus
==========================

La solution n'est pas parfaite en ce sens que visuellement, on voit que certaines
parties du chemin pourraient être facilement améliorées. Mais si la solution
était parfaite en toute circonstance, nous aurions
trouvé un algorithme à temps polynômial ce qui est
impossible. Dans notre cas, l'algorithme produit toujours la même
solution car il parcourt les noeuds toujours dans le même sens.
Un peu d'aléa devrait l'aider à trouver de meilleures solutions après quelques essais.

.. GENERATED FROM PYTHON SOURCE LINES 250-288

.. code-block:: default


    # In[8]:


    ordre = list(range(len(x)))
    print("longueur initiale", longueur(x, y, ordre))


    def permutation_rnd(x, y, ordre):
        d = longueur(x, y, ordre)
        d0 = d + 1
        it = 1
        while d < d0:
            it += 1
            print("iteration", it, "d=", d, "ordre[0]", ordre[0])
            d0 = d
            for i in range(1, len(ordre) - 1):
                for j in range(i + 2, len(ordre) + 1):
                    ik = random.randint(1, len(ordre) - 1)
                    il = random.randint(ik + 1, len(ordre))
                    r = ordre[ik:il].copy()
                    r.reverse()
                    ordre2 = ordre[:ik] + r + ordre[il:]
                    t = longueur(x, y, ordre2)
                    if t < d:
                        d = t
                        ordre = ordre2
        return ordre


    ordre = permutation_rnd(x, y, list(range(len(x))))
    print("longueur min", longueur(x, y, ordre))
    xo = [x[o] for o in ordre + [ordre[0]]]
    yo = [y[o] for o in ordre + [ordre[0]]]
    plt.plot(xo, yo, "o-")
    plt.text(xo[0], yo[0], "0", color="r", weight="bold", size="x-large")
    plt.text(xo[-2], yo[-2], "N-1", color="r", weight="bold", size="x-large")




.. image-sg:: /auto_examples/images/sphx_glr_plot_tsp_007.png
   :alt: plot tsp
   :srcset: /auto_examples/images/sphx_glr_plot_tsp_007.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    longueur initiale 7.591639460504804
    iteration 2 d= 7.591639460504804 ordre[0] 0
    iteration 3 d= 2.0530695790733606 ordre[0] 0
    iteration 4 d= 1.283775037703427 ordre[0] 0
    iteration 5 d= 1.0155592473472466 ordre[0] 0
    longueur min 1.0155592473472466

    Text(0.09092243836310065, 0.142781397955138, 'N-1')



.. GENERATED FROM PYTHON SOURCE LINES 289-292

Ca a l'air de marcher un peu mieux mais quelques aberrations car
l'aléatoire n'est pas un parcours systématique de toutes les pairs.
Par conséquent, il peut rester des croisements :

.. GENERATED FROM PYTHON SOURCE LINES 292-303

.. code-block:: default



    ordre = permutation_rnd(x, y, list(range(len(x))))
    print("longueur min", longueur(x, y, ordre))
    xo = [x[o] for o in ordre + [ordre[0]]]
    yo = [y[o] for o in ordre + [ordre[0]]]
    plt.plot(xo, yo, "o-")
    plt.text(xo[0], yo[0], "0", color="r", weight="bold", size="x-large")
    plt.text(xo[-2], yo[-2], "N-1", color="r", weight="bold", size="x-large")





.. image-sg:: /auto_examples/images/sphx_glr_plot_tsp_008.png
   :alt: plot tsp
   :srcset: /auto_examples/images/sphx_glr_plot_tsp_008.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    iteration 2 d= 7.591639460504804 ordre[0] 0
    iteration 3 d= 2.312884161399227 ordre[0] 0
    iteration 4 d= 1.5448580111257841 ordre[0] 0
    iteration 5 d= 1.1467149900714988 ordre[0] 0
    longueur min 1.1467149900714988

    Text(0.044255803643096, 0.4785909392917087, 'N-1')



.. GENERATED FROM PYTHON SOURCE LINES 304-306

Pour éviter cela, on peut imposer un nombre d'itérations minimum
et recommencer plusieurs à partir d'ordre initiaux aléatoires :

.. GENERATED FROM PYTHON SOURCE LINES 306-344

.. code-block:: default



    def permutation_rnd(x, y, ordre, miniter):
        d = longueur(x, y, ordre)
        d0 = d + 1
        it = 1
        while d < d0 or it < miniter:
            it += 1
            d0 = d
            for i in range(1, len(ordre) - 1):
                for j in range(i + 2, len(ordre) + 1):
                    ik = random.randint(1, len(ordre) - 1)
                    il = random.randint(ik + 1, len(ordre))
                    r = ordre[ik:il].copy()
                    r.reverse()
                    ordre2 = ordre[:ik] + r + ordre[il:]
                    t = longueur(x, y, ordre2)
                    if t < d:
                        d = t
                        ordre = ordre2
        return ordre


    def n_permutation(x, y, miniter):
        ordre = list(range(len(x)))
        bordre = ordre.copy()
        d0 = longueur(x, y, ordre)
        for i in range(0, 20):
            print("iteration", i, "d=", d0)
            random.shuffle(ordre)
            ordre = permutation_rnd(x, y, ordre, 20)
            d = longueur(x, y, ordre)
            if d < d0:
                d0 = d
                bordre = ordre.copy()
        return bordre









.. GENERATED FROM PYTHON SOURCE LINES 345-346

La distance initiale.

.. GENERATED FROM PYTHON SOURCE LINES 346-349

.. code-block:: default

    ordre = list(range(len(x)))
    print("longueur initiale", longueur(x, y, ordre))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    longueur initiale 7.591639460504804




.. GENERATED FROM PYTHON SOURCE LINES 350-351

La longueur obtenue.

.. GENERATED FROM PYTHON SOURCE LINES 351-362

.. code-block:: default


    ordre = n_permutation(x, y, 20)
    print("longueur min", longueur(x, y, ordre))
    xo = [x[o] for o in ordre + [ordre[0]]]
    yo = [y[o] for o in ordre + [ordre[0]]]
    plt.plot(xo, yo, "o-")
    plt.text(xo[0], yo[0], "0", color="r", weight="bold", size="x-large")
    plt.text(xo[-2], yo[-2], "N-1", color="r", weight="bold", size="x-large")


    # C'est mieux.



.. image-sg:: /auto_examples/images/sphx_glr_plot_tsp_009.png
   :alt: plot tsp
   :srcset: /auto_examples/images/sphx_glr_plot_tsp_009.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    iteration 0 d= 7.591639460504804
    iteration 1 d= 0.9850032418222195
    iteration 2 d= 0.9850032418222195
    iteration 3 d= 0.9850032418222195
    iteration 4 d= 0.9850032418222195
    iteration 5 d= 0.9803845951411287
    iteration 6 d= 0.9693215232567256
    iteration 7 d= 0.9693215232567256
    iteration 8 d= 0.9566559017707142
    iteration 9 d= 0.9566559017707142
    iteration 10 d= 0.929065250783502
    iteration 11 d= 0.929065250783502
    iteration 12 d= 0.929065250783502
    iteration 13 d= 0.929065250783502
    iteration 14 d= 0.929065250783502
    iteration 15 d= 0.929065250783502
    iteration 16 d= 0.929065250783502
    iteration 17 d= 0.929065250783502
    iteration 18 d= 0.929065250783502
    iteration 19 d= 0.929065250783502
    longueur min 0.929065250783502

    Text(0.8963082739549963, 0.9061665963345669, 'N-1')




.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 2.598 seconds)


.. _sphx_glr_download_auto_examples_plot_tsp.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_tsp.py <plot_tsp.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_tsp.ipynb <plot_tsp.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
