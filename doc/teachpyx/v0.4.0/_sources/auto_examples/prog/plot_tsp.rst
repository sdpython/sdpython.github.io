
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/prog/plot_tsp.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_prog_plot_tsp.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_prog_plot_tsp.py:


=============================================
Réflexions autour du voyage de commerce (TSP)
=============================================

Le `problème du voyageur de commerce
<https://fr.wikipedia.org/wiki/Probl%C3%A8me_du_voyageur_de_commerce)>`_
consiste à trouver le plus court chemin passant par toutes les villes.
On parle aussi de `circuit hamiltonien <https://en.wikipedia.org/wiki/Hamiltonian_path)>`_
qui consiste à trouver le plus court chemin passant par tous les noeuds d'un graphe.
Ce programme explore quelques solutions approchées et intuitives.

Ce problème est :epkg:`NP-complet`
à savoir qu'il n'existe pas d'algorithme qui permette de trouver la solution avec un
coût polynômial. C'est aussi un problème différent du `plus court chemin dans un graphe
<https://fr.wikipedia.org/wiki/Probl%C3%A8mes_de_cheminement)>`_
qui consiste à trouver le plus court chemin reliant deux noeuds d'un graphe
(mais pas forcément tous les noeuds de ce graphe).

Des villes tirées au hasard
===========================

.. GENERATED FROM PYTHON SOURCE LINES 24-35

.. code-block:: Python


    import random
    import matplotlib.pyplot as plt

    n = 30
    x = [random.random() for _ in range(n)]
    y = [random.random() for _ in range(n)]

    plt.plot(x, y, "o")





.. image-sg:: /auto_examples/prog/images/sphx_glr_plot_tsp_001.png
   :alt: plot tsp
   :srcset: /auto_examples/prog/images/sphx_glr_plot_tsp_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    [<matplotlib.lines.Line2D object at 0x7fd9f243da20>]



.. GENERATED FROM PYTHON SOURCE LINES 36-38

Un parcours aléatoire de tous les noeuds de graphe
donnera quelque chose de très éloigné de la solution optimale :

.. GENERATED FROM PYTHON SOURCE LINES 38-42

.. code-block:: Python


    plt.plot(x + [x[0]], y + [y[0]], "o-")





.. image-sg:: /auto_examples/prog/images/sphx_glr_plot_tsp_002.png
   :alt: plot tsp
   :srcset: /auto_examples/prog/images/sphx_glr_plot_tsp_002.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    [<matplotlib.lines.Line2D object at 0x7fd9f2574040>]



.. GENERATED FROM PYTHON SOURCE LINES 43-53

Croisements
===========

La première constation est que le chemin ne peut pas être optimal
car des arcs se croisent. On en déduit qu'une façon d'améliorer ce
chemin est de *décroiser* certaines parties. On peut par exemple
choisir deux points au hasard, retourner la partie du chemin au milieu
de ces deux points et voir si la longueur du chemin s'en trouve diminuée.
On peut également parcourir toutes les paires de noeuds possibles.
C'est ce qui est implémenté ci-dessous.

.. GENERATED FROM PYTHON SOURCE LINES 53-69

.. code-block:: Python



    def longueur(x, y, ordre):
        i = ordre[-1]
        x0, y0 = x[i], y[i]
        d = 0
        for o in ordre:
            x1, y1 = x[o], y[o]
            d += (x0 - x1) ** 2 + (y0 - y1) ** 2
            x0, y0 = x1, y1
        return d


    ordre = list(range(len(x)))
    print("longueur initiale", longueur(x, y, ordre))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    longueur initiale 8.811830996591114




.. GENERATED FROM PYTHON SOURCE LINES 70-71

Permutations.

.. GENERATED FROM PYTHON SOURCE LINES 71-99

.. code-block:: Python



    def permutation(x, y, ordre):
        d = longueur(x, y, ordre)
        d0 = d + 1
        it = 1
        while d < d0:
            it += 1
            print("iteration", it, "d=", d)
            d0 = d
            for i in range(0, len(ordre) - 1):
                for j in range(i + 2, len(ordre)):
                    r = ordre[i:j].copy()
                    r.reverse()
                    ordre2 = ordre[:i] + r + ordre[j:]
                    t = longueur(x, y, ordre2)
                    if t < d:
                        d = t
                        ordre = ordre2
        return ordre


    ordre = permutation(x, y, list(range(len(x))))
    print("longueur min", longueur(x, y, ordre))
    xo = [x[o] for o in ordre + [ordre[0]]]
    yo = [y[o] for o in ordre + [ordre[0]]]
    plt.plot(xo, yo, "o-")




.. image-sg:: /auto_examples/prog/images/sphx_glr_plot_tsp_003.png
   :alt: plot tsp
   :srcset: /auto_examples/prog/images/sphx_glr_plot_tsp_003.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    iteration 2 d= 8.811830996591114
    iteration 3 d= 2.101501829355391
    iteration 4 d= 1.285469971302597
    iteration 5 d= 1.154861624933519
    iteration 6 d= 1.1421052489146368
    longueur min 1.1421052489146368

    [<matplotlib.lines.Line2D object at 0x7fd9f243e710>]



.. GENERATED FROM PYTHON SOURCE LINES 100-103

Voilà qui est mieux. Maintenant, supposons que nous faisons une
erreur lors du calcul de la distance : nous oublions le dernier
arc qui boucle le chemin du dernier noeud au premier.

.. GENERATED FROM PYTHON SOURCE LINES 103-120

.. code-block:: Python



    def longueur(x, y, ordre):
        # on change cette fonction
        d = 0
        for i in range(1, len(ordre)):
            n = ordre[i - 1]
            o = ordre[i]
            x0, y0 = x[n], y[n]
            x1, y1 = x[o], y[o]
            d += (x0 - x1) ** 2 + (y0 - y1) ** 2
        return d


    ordre = list(range(len(x)))
    print("longueur initiale", longueur(x, y, ordre))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    longueur initiale 8.715556493555296




.. GENERATED FROM PYTHON SOURCE LINES 121-122

Et graphiquement.

.. GENERATED FROM PYTHON SOURCE LINES 122-130

.. code-block:: Python


    ordre = permutation(x, y, list(range(len(x))))
    print("longueur min", longueur(x, y, ordre))
    xo = [x[o] for o in ordre]
    yo = [y[o] for o in ordre]
    plt.plot(xo, yo, "o-")





.. image-sg:: /auto_examples/prog/images/sphx_glr_plot_tsp_004.png
   :alt: plot tsp
   :srcset: /auto_examples/prog/images/sphx_glr_plot_tsp_004.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    iteration 2 d= 8.715556493555296
    iteration 3 d= 1.7595655216554023
    iteration 4 d= 1.081923270548145
    iteration 5 d= 0.9551902040389284
    longueur min 0.9551902040389284

    [<matplotlib.lines.Line2D object at 0x7fd9f23e3160>]



.. GENERATED FROM PYTHON SOURCE LINES 131-141

Noeud de départ constant
========================

Jusque ici, tout concorde. Le chemin est plus court en ce sens qu'il
oublie délibérément l'arc de bouclage que l'algorithme a tendance à
choisir grand. Pour gagner du temps de calcul, un développeur se dit
que le noeud de départ peut être constant. Après tout, le chemin est
une boucle, elle passera toujours par le premier noeud. Qu'il soit en
première position ne change rien et puis inverser une moitié, c'est
équivalent à inverser l'autre moitié. On fait donc juste une modification :

.. GENERATED FROM PYTHON SOURCE LINES 141-188

.. code-block:: Python



    def longueur(x, y, ordre):
        i = ordre[-1]
        x0, y0 = x[i], y[i]
        d = 0
        for o in ordre:
            x1, y1 = x[o], y[o]
            d += (x0 - x1) ** 2 + (y0 - y1) ** 2
            x0, y0 = x1, y1
        return d


    ordre = list(range(len(x)))
    print("longueur initiale", longueur(x, y, ordre))


    def permutation(x, y, ordre):
        d = longueur(x, y, ordre)
        d0 = d + 1
        it = 1
        while d < d0:
            it += 1
            print("iteration", it, "d=", d, "ordre[0]", ordre[0])
            d0 = d
            for i in range(
                1, len(ordre) - 1
            ):  # on part de 1 et plus de 0, on est sûr que le premier noeud ne bouge pas
                for j in range(i + 2, len(ordre)):
                    r = ordre[i:j].copy()
                    r.reverse()
                    ordre2 = ordre[:i] + r + ordre[j:]
                    t = longueur(x, y, ordre2)
                    if t < d:
                        d = t
                        ordre = ordre2
        return ordre


    ordre = permutation(x, y, list(range(len(x))))
    print("longueur min", longueur(x, y, ordre))
    xo = [x[o] for o in ordre + [ordre[0]]]
    yo = [y[o] for o in ordre + [ordre[0]]]
    plt.plot(xo, yo, "o-")
    plt.text(xo[0], yo[0], "0", color="r", weight="bold", size="x-large")
    plt.text(xo[-2], yo[-2], "N-1", color="r", weight="bold", size="x-large")




.. image-sg:: /auto_examples/prog/images/sphx_glr_plot_tsp_005.png
   :alt: plot tsp
   :srcset: /auto_examples/prog/images/sphx_glr_plot_tsp_005.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    longueur initiale 8.811830996591114
    iteration 2 d= 8.811830996591114 ordre[0] 0
    iteration 3 d= 2.0779685382870037 ordre[0] 0
    iteration 4 d= 1.2478858151377523 ordre[0] 0
    longueur min 1.2478858151377523

    Text(0.7672381986842091, 0.06345519245276543, 'N-1')



.. GENERATED FROM PYTHON SOURCE LINES 189-198

Le résultat attendu n'est pas celui qu'on observe.
Est-ce une erreur d'implémentation ou
une erreur de raisonnement ? J'étais pourtant sûr que mon raisonnement était correct
et j'aurais tort d'en douter. C'est une erreur d'implémentation.
Lorsqu'on``for j in range(i+2,len(ordre)):`` et  ``r = ordre[i:j].copy()``,
on écrit que ``j`` va de ``i+2`` inclus à ``len(ordre)`` exclu. Puis
lorsqu'on écrit ``ordre[i:j]``, l'indice ``j`` est exclu ! Autrement dit,
dans cette implémentation, le premier noeud et le dernier noeud ne bougeront
jamais ! On s'empresse de corriger cela.

.. GENERATED FROM PYTHON SOURCE LINES 198-235

.. code-block:: Python



    ordre = list(range(len(x)))
    print("longueur initiale", longueur(x, y, ordre))


    def permutation(x, y, ordre):
        d = longueur(x, y, ordre)
        d0 = d + 1
        it = 1
        while d < d0:
            it += 1
            print("iteration", it, "d=", d, "ordre[0]", ordre[0])
            d0 = d
            for i in range(
                1, len(ordre) - 1
            ):  # on part de 1 et plus de 0, on est sûr que le premier noeud ne bouge pas
                for j in range(i + 2, len(ordre) + 1):  # correction !
                    r = ordre[i:j].copy()
                    r.reverse()
                    ordre2 = ordre[:i] + r + ordre[j:]
                    t = longueur(x, y, ordre2)
                    if t < d:
                        d = t
                        ordre = ordre2
        return ordre


    ordre = permutation(x, y, list(range(len(x))))
    print("longueur min", longueur(x, y, ordre))
    xo = [x[o] for o in ordre + [ordre[0]]]
    yo = [y[o] for o in ordre + [ordre[0]]]
    plt.plot(xo, yo, "o-")
    plt.text(xo[0], yo[0], "0", color="r", weight="bold", size="x-large")
    plt.text(xo[-2], yo[-2], "N-1", color="r", weight="bold", size="x-large")





.. image-sg:: /auto_examples/prog/images/sphx_glr_plot_tsp_006.png
   :alt: plot tsp
   :srcset: /auto_examples/prog/images/sphx_glr_plot_tsp_006.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    longueur initiale 8.811830996591114
    iteration 2 d= 8.811830996591114 ordre[0] 0
    iteration 3 d= 1.927447182348086 ordre[0] 0
    iteration 4 d= 1.1726509916028212 ordre[0] 0
    iteration 5 d= 1.1714660842257392 ordre[0] 0
    longueur min 1.1714660842257392

    Text(0.28109600479247543, 0.06754954438167948, 'N-1')



.. GENERATED FROM PYTHON SOURCE LINES 236-250

Pas parfait mais conforme à nos attentes (les miennes en tout cas) !
Soit dit en passant, la première version de l'algorithme
laissait déjà le dernier noeud inchangé.

Un peu d'aléatoire en plus
==========================

La solution n'est pas parfaite en ce sens que visuellement, on voit que certaines
parties du chemin pourraient être facilement améliorées. Mais si la solution
était parfaite en toute circonstance, nous aurions
trouvé un algorithme à temps polynômial ce qui est
impossible. Dans notre cas, l'algorithme produit toujours la même
solution car il parcourt les noeuds toujours dans le même sens.
Un peu d'aléa devrait l'aider à trouver de meilleures solutions après quelques essais.

.. GENERATED FROM PYTHON SOURCE LINES 250-288

.. code-block:: Python


    # In[8]:


    ordre = list(range(len(x)))
    print("longueur initiale", longueur(x, y, ordre))


    def permutation_rnd(x, y, ordre):
        d = longueur(x, y, ordre)
        d0 = d + 1
        it = 1
        while d < d0:
            it += 1
            print("iteration", it, "d=", d, "ordre[0]", ordre[0])
            d0 = d
            for i in range(1, len(ordre) - 1):
                for j in range(i + 2, len(ordre) + 1):
                    ik = random.randint(1, len(ordre) - 1)
                    il = random.randint(ik + 1, len(ordre))
                    r = ordre[ik:il].copy()
                    r.reverse()
                    ordre2 = ordre[:ik] + r + ordre[il:]
                    t = longueur(x, y, ordre2)
                    if t < d:
                        d = t
                        ordre = ordre2
        return ordre


    ordre = permutation_rnd(x, y, list(range(len(x))))
    print("longueur min", longueur(x, y, ordre))
    xo = [x[o] for o in ordre + [ordre[0]]]
    yo = [y[o] for o in ordre + [ordre[0]]]
    plt.plot(xo, yo, "o-")
    plt.text(xo[0], yo[0], "0", color="r", weight="bold", size="x-large")
    plt.text(xo[-2], yo[-2], "N-1", color="r", weight="bold", size="x-large")




.. image-sg:: /auto_examples/prog/images/sphx_glr_plot_tsp_007.png
   :alt: plot tsp
   :srcset: /auto_examples/prog/images/sphx_glr_plot_tsp_007.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    longueur initiale 8.811830996591114
    iteration 2 d= 8.811830996591114 ordre[0] 0
    iteration 3 d= 2.5682891432396957 ordre[0] 0
    iteration 4 d= 1.9919858643598898 ordre[0] 0
    iteration 5 d= 1.8459033723311158 ordre[0] 0
    iteration 6 d= 1.333700831131214 ordre[0] 0
    iteration 7 d= 1.3337008311312137 ordre[0] 0
    iteration 8 d= 1.2283539490447308 ordre[0] 0
    iteration 9 d= 1.1906704893429638 ordre[0] 0
    iteration 10 d= 1.179494184482651 ordre[0] 0
    longueur min 1.179494184482651

    Text(0.28109600479247543, 0.06754954438167948, 'N-1')



.. GENERATED FROM PYTHON SOURCE LINES 289-292

Ca a l'air de marcher un peu mieux mais quelques aberrations car
l'aléatoire n'est pas un parcours systématique de toutes les pairs.
Par conséquent, il peut rester des croisements :

.. GENERATED FROM PYTHON SOURCE LINES 292-303

.. code-block:: Python



    ordre = permutation_rnd(x, y, list(range(len(x))))
    print("longueur min", longueur(x, y, ordre))
    xo = [x[o] for o in ordre + [ordre[0]]]
    yo = [y[o] for o in ordre + [ordre[0]]]
    plt.plot(xo, yo, "o-")
    plt.text(xo[0], yo[0], "0", color="r", weight="bold", size="x-large")
    plt.text(xo[-2], yo[-2], "N-1", color="r", weight="bold", size="x-large")





.. image-sg:: /auto_examples/prog/images/sphx_glr_plot_tsp_008.png
   :alt: plot tsp
   :srcset: /auto_examples/prog/images/sphx_glr_plot_tsp_008.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    iteration 2 d= 8.811830996591114 ordre[0] 0
    iteration 3 d= 2.0397605497279674 ordre[0] 0
    iteration 4 d= 1.847416293297475 ordre[0] 0
    iteration 5 d= 1.5133080268250862 ordre[0] 0
    iteration 6 d= 1.35653626211927 ordre[0] 0
    iteration 7 d= 1.3087016223831252 ordre[0] 0
    iteration 8 d= 1.2613673201808613 ordre[0] 0
    iteration 9 d= 1.2291363227431569 ordre[0] 0
    longueur min 1.2291363227431569

    Text(0.28109600479247543, 0.06754954438167948, 'N-1')



.. GENERATED FROM PYTHON SOURCE LINES 304-306

Pour éviter cela, on peut imposer un nombre d'itérations minimum
et recommencer plusieurs à partir d'ordre initiaux aléatoires :

.. GENERATED FROM PYTHON SOURCE LINES 306-344

.. code-block:: Python



    def permutation_rnd(x, y, ordre, miniter):
        d = longueur(x, y, ordre)
        d0 = d + 1
        it = 1
        while d < d0 or it < miniter:
            it += 1
            d0 = d
            for i in range(1, len(ordre) - 1):
                for j in range(i + 2, len(ordre) + 1):
                    ik = random.randint(1, len(ordre) - 1)
                    il = random.randint(ik + 1, len(ordre))
                    r = ordre[ik:il].copy()
                    r.reverse()
                    ordre2 = ordre[:ik] + r + ordre[il:]
                    t = longueur(x, y, ordre2)
                    if t < d:
                        d = t
                        ordre = ordre2
        return ordre


    def n_permutation(x, y, miniter):
        ordre = list(range(len(x)))
        bordre = ordre.copy()
        d0 = longueur(x, y, ordre)
        for i in range(0, 20):
            print("iteration", i, "d=", d0)
            random.shuffle(ordre)
            ordre = permutation_rnd(x, y, ordre, 20)
            d = longueur(x, y, ordre)
            if d < d0:
                d0 = d
                bordre = ordre.copy()
        return bordre









.. GENERATED FROM PYTHON SOURCE LINES 345-346

La distance initiale.

.. GENERATED FROM PYTHON SOURCE LINES 346-349

.. code-block:: Python

    ordre = list(range(len(x)))
    print("longueur initiale", longueur(x, y, ordre))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    longueur initiale 8.811830996591114




.. GENERATED FROM PYTHON SOURCE LINES 350-351

La longueur obtenue.

.. GENERATED FROM PYTHON SOURCE LINES 351-362

.. code-block:: Python


    ordre = n_permutation(x, y, 20)
    print("longueur min", longueur(x, y, ordre))
    xo = [x[o] for o in ordre + [ordre[0]]]
    yo = [y[o] for o in ordre + [ordre[0]]]
    plt.plot(xo, yo, "o-")
    plt.text(xo[0], yo[0], "0", color="r", weight="bold", size="x-large")
    plt.text(xo[-2], yo[-2], "N-1", color="r", weight="bold", size="x-large")


    # C'est mieux.



.. image-sg:: /auto_examples/prog/images/sphx_glr_plot_tsp_009.png
   :alt: plot tsp
   :srcset: /auto_examples/prog/images/sphx_glr_plot_tsp_009.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    iteration 0 d= 8.811830996591114
    iteration 1 d= 1.068709448010064
    iteration 2 d= 1.068709448010064
    iteration 3 d= 1.068709448010064
    iteration 4 d= 1.068709448010064
    iteration 5 d= 1.068709448010064
    iteration 6 d= 1.068709448010064
    iteration 7 d= 1.068709448010064
    iteration 8 d= 1.017005293182978
    iteration 9 d= 1.017005293182978
    iteration 10 d= 1.017005293182978
    iteration 11 d= 1.017005293182978
    iteration 12 d= 1.017005293182978
    iteration 13 d= 1.017005293182978
    iteration 14 d= 1.017005293182978
    iteration 15 d= 1.017005293182978
    iteration 16 d= 1.017005293182978
    iteration 17 d= 1.017005293182978
    iteration 18 d= 1.017005293182978
    iteration 19 d= 1.017005293182978
    longueur min 1.017005293182978

    Text(0.4513141365801381, 0.20741773811217845, 'N-1')




.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 2.413 seconds)


.. _sphx_glr_download_auto_examples_prog_plot_tsp.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_tsp.ipynb <plot_tsp.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_tsp.py <plot_tsp.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
