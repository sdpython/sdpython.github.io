<!doctype html>
<html class="no-js" lang="en" data-content_root="../../../">
  <head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html"><link rel="search" title="Search" href="../../../search.html">
        <link rel="prefetch" href="../../../_static/logo.png" as="image">

    <!-- Generated with Sphinx 9.1.0 and Furo 2025.12.19 -->
        <title>experimental_experiment.xbuilder.graph_builder - experimental-experiment 0.1.3 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?v=7bdb33bb" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css?v=7f9a90b1" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?v=8dab3a3b" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle site navigation sidebar">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc" aria-label="Toggle table of contents sidebar">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <span class="icon"><svg><use href="#svg-menu"></use></svg></span>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">experimental-experiment 0.1.3 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../../../_static/logo.png" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">experimental-experiment 0.1.3 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../design/index.html">Design</a><input aria-label="Toggle navigation of Design" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../design/exporter.html">Custom Exporter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../design/optimizer.html">Pattern Optimizer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../design/optimizer_patterns.html">Available Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../design/backends.html">Dynamo Backends</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../tutorial/index.html">Tutorial</a><input aria-label="Toggle navigation of Tutorial" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial/shape.html">ShapeBuilder</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial/to_onnx.html">to_onnx: another export to investigate</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial/errors.html">Unexpected Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorial/docker.html">Start from a docker</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../api/index.html">API</a><input aria-label="Toggle navigation of API" class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../api/gradient/index.html">.gradient</a><input aria-label="Toggle navigation of .gradient" class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../api/gradient/ops/index.html">.gradient.ops</a><input aria-label="Toggle navigation of .gradient.ops" class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api/gradient/ops/op_broadcast_gradient_args.html">.gradient.ops.op_broadcast_gradient_args</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/gradient/grad_helper.html">.gradient.grad_helper</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/gradient/loss_helper.html">.gradient.loss_helper</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../api/reference/index.html">.reference</a><input aria-label="Toggle navigation of .reference" class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../api/reference/ops/index.html">.reference.ops</a><input aria-label="Toggle navigation of .reference.ops" class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api/reference/ops/op_add_add_mul_mul.html">.reference.ops.op_add_add_mul_mul</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/reference/ops/op_average_pool_grad.html">.reference.ops.op_average_pool_grad</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/reference/ops/op_cast_like.html">.reference.ops.op_cast_like</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/reference/ops/op_complex.html">.reference.ops.op_complex</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/reference/ops/op_concat.html">.reference.ops.op_concat</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/reference/ops/op_constant_of_shape.html">.reference.ops.op_constant_of_shape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/reference/ops/op_fused_matmul.html">.reference.ops.op_fused_matmul</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/reference/ops/op_gather_grad.html">.reference.ops.op_gather_grad</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/reference/ops/op_memcpy_host.html">.reference.ops.op_memcpy_host</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/reference/ops/op_mul_sigmoid.html">.reference.ops.op_mul_sigmoid</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/reference/ops/op_negxplus1.html">.reference.ops.op_negxplus1</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/reference/ops/op_quick_gelu.html">.reference.ops.op_quick_gelu</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/reference/ops/op_replace_zero.html">.reference.ops.op_replace_zero</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/reference/ops/op_rotary.html">.reference.ops.op_rotary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/reference/ops/op_qlinear_average_pool.html">.reference.ops.op_qlinear_average_pool</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/reference/ops/op_qlinear_conv.html">.reference.ops.op_qlinear_conv</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/reference/ops/op_scatter_elements.html">.reference.ops.op_scatter_elements</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/reference/ops/op_scatternd_of_shape.html">.reference.ops.op_scatternd_of_shape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/reference/ops/op_simplified_layer_normalization.html">.reference.ops.op_simplified_layer_normalization</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/reference/ops/op_skip_layer_normalization.html">.reference.ops.op_skip_layer_normalization</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/reference/ops/op_slice.html">.reference.ops.op_slice</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/reference/ops/op_transpose_cast.html">.reference.ops.op_transpose_cast</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/reference/ops/op_tri_matrix.html">.reference.ops.op_tri_matrix</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/reference/evaluator.html">.reference.evaluator</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/reference/ort_evaluator.html">.reference.ort_evaluator</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/reference/quantized_tensor.html">.reference.quantized_tensor</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../api/convert/index.html">.convert</a><input aria-label="Toggle navigation of .convert" class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api/convert/convert_helper.html">.convert.convert_helper</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/convert/ort_helper.html">.convert.ort_helper</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../api/plotting/index.html">.plotting</a><input aria-label="Toggle navigation of .plotting" class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api/plotting/data.html">.plotting.data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/plotting/memory.html">.plotting.memory</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../api/skl/index.html">.skl</a><input aria-label="Toggle navigation of .skl" class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" role="switch" type="checkbox"/><label for="toctree-checkbox-10"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api/skl/convert.html">.skl.convert</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/skl/helpers.html">.skl.helpers</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../api/torch_interpreter/index.html">.torch_interpreter</a><input aria-label="Toggle navigation of .torch_interpreter" class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" role="switch" type="checkbox"/><label for="toctree-checkbox-11"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_interpreter/_aten_functions.html">.torch_interpreter._aten_functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_interpreter/_aten_functions_attention.html">.torch_interpreter._aten_functions_attention</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_interpreter/_non_aten_functions.html">.torch_interpreter._non_aten_functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_interpreter/_aten_methods.html">.torch_interpreter._aten_methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_interpreter/_doc_.html">.torch_interpreter._doc_</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_interpreter/_exceptions.html">.torch_interpreter._exceptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_interpreter/_prims_functions.html">.torch_interpreter._prims_functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_interpreter/_torch_helper.html">.torch_interpreter._torch_helper</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_interpreter/aten_functions.html">.torch_interpreter.aten_functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_interpreter/aten_methods.html">.torch_interpreter.aten_methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_interpreter/dispatcher.html">.torch_interpreter.dispatcher</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_interpreter/export_options.html">.torch_interpreter.export_options</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_interpreter/interpreter.html">.torch_interpreter.interpreter</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_interpreter/investigate_helper.html">.torch_interpreter.investigate_helper</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_interpreter/onnx_export.html">.torch_interpreter.onnx_export</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_interpreter/oxs_dispatcher.html">.torch_interpreter.oxs_dispatcher</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_interpreter/oxs_opset.html">.torch_interpreter.oxs_opset</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_interpreter/piece_by_piece.html">.torch_interpreter.piece_by_piece</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_interpreter/piece_by_piece_serialize.html">.torch_interpreter.piece_by_piece_serialize</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_interpreter/tracing.html">.torch_interpreter.tracing</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../api/torch_models/index.html">.torch_models</a><input aria-label="Toggle navigation of .torch_models" class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" role="switch" type="checkbox"/><label for="toctree-checkbox-12"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_models/dump_helper.html">.torch_models.dump_helper</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_models/training_helper.html">.torch_models.training_helper</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../api/xbuilder/index.html">.xbuilder</a><input aria-label="Toggle navigation of .xbuilder" class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" role="switch" type="checkbox"/><label for="toctree-checkbox-13"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api/xbuilder/_onnx_helper.html">.xbuilder._onnx_helper</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/xbuilder/graph_builder.html">.xbuilder.graph_builder</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/xbuilder/graph_builder_opset.html">.xbuilder.graph_builder_opset</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/xbuilder/model_container.html">.xbuilder.model_container</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/xbuilder/optimization_options.html">.xbuilder.optimization_options</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/xbuilder/reverse_graph_builder.html">.xbuilder.reverse_graph_builder</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../api/xoptim/index.html">.xoptim</a><input aria-label="Toggle navigation of .xoptim" class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" role="switch" type="checkbox"/><label for="toctree-checkbox-14"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../api/xoptim/patterns_investigation/index.html">.xoptim.patterns_investigation</a><input aria-label="Toggle navigation of .xoptim.patterns_investigation" class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" role="switch" type="checkbox"/><label for="toctree-checkbox-15"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns_investigation/element_wise.html">.xoptim.patterns_investigation.element_wise</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns_investigation/llm_patterns.html">.xoptim.patterns_investigation.llm_patterns</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../api/xoptim/patterns_ml/index.html">.xoptim.patterns_ml</a><input aria-label="Toggle navigation of .xoptim.patterns_ml" class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" role="switch" type="checkbox"/><label for="toctree-checkbox-16"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns_ml/tree_ensemble.html">.xoptim.patterns_ml.tree_ensemble</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../api/xoptim/patterns_exp/index.html">.xoptim.patterns_exp</a><input aria-label="Toggle navigation of .xoptim.patterns_exp" class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" role="switch" type="checkbox"/><label for="toctree-checkbox-17"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns_exp/binary_operators.html">.xoptim.patterns_exp.binary_operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns_exp/constant_of_shape_scatter_nd.html">.xoptim.patterns_exp.constant_of_shape_scatter_nd</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns_exp/constants.html">.xoptim.patterns_exp.constants</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns_exp/simple_rotary.html">.xoptim.patterns_exp.simple_rotary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns_exp/unary_operators.html">.xoptim.patterns_exp.unary_operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns_exp/where_replace.html">.xoptim.patterns_exp.where_replace</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../api/xoptim/patterns/index.html">.xoptim.patterns</a><input aria-label="Toggle navigation of .xoptim.patterns" class="toctree-checkbox" id="toctree-checkbox-18" name="toctree-checkbox-18" role="switch" type="checkbox"/><label for="toctree-checkbox-18"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns/onnx_any.html">.xoptim.patterns.onnx_any</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns/onnx_attention.html">.xoptim.patterns.onnx_attention</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns/onnx_cast.html">.xoptim.patterns.onnx_cast</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns/onnx_clip.html">.xoptim.patterns.onnx_clip</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns/onnx_constants.html">.xoptim.patterns.onnx_constants</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns/onnx_conv.html">.xoptim.patterns.onnx_conv</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns/onnx_concat.html">.xoptim.patterns.onnx_concat</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns/onnx_dropout.html">.xoptim.patterns.onnx_dropout</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns/onnx_equal.html">.xoptim.patterns.onnx_equal</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns/onnx_expand.html">.xoptim.patterns.onnx_expand</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns/onnx_functions.html">.xoptim.patterns.onnx_functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns/onnx_layer_normalization.html">.xoptim.patterns.onnx_layer_normalization</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns/onnx_matmul.html">.xoptim.patterns.onnx_matmul</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns/onnx_mul.html">.xoptim.patterns.onnx_mul</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns/onnx_range.html">.xoptim.patterns.onnx_range</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns/onnx_reduce.html">.xoptim.patterns.onnx_reduce</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns/onnx_reshape.html">.xoptim.patterns.onnx_reshape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns/onnx_rotary.html">.xoptim.patterns.onnx_rotary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns/onnx_shape.html">.xoptim.patterns.onnx_shape</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns/onnx_slice.html">.xoptim.patterns.onnx_slice</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns/onnx_split.html">.xoptim.patterns.onnx_split</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns/onnx_sub.html">.xoptim.patterns.onnx_sub</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns/onnx_sequence.html">.xoptim.patterns.onnx_sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns/onnx_transpose.html">.xoptim.patterns.onnx_transpose</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns/onnx_unsqueeze.html">.xoptim.patterns.onnx_unsqueeze</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../api/xoptim/patterns_ort/index.html">.xoptim.patterns_ort</a><input aria-label="Toggle navigation of .xoptim.patterns_ort" class="toctree-checkbox" id="toctree-checkbox-19" name="toctree-checkbox-19" role="switch" type="checkbox"/><label for="toctree-checkbox-19"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns_ort/activation.html">.xoptim.patterns_ort.activation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns_ort/activation_grad.html">.xoptim.patterns_ort.activation_grad</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns_ort/batch_normalization.html">.xoptim.patterns_ort.batch_normalization</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns_ort/fused_conv.html">.xoptim.patterns_ort.fused_conv</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns_ort/fused_matmul.html">.xoptim.patterns_ort.fused_matmul</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns_ort/gather_grad.html">.xoptim.patterns_ort.gather_grad</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns_ort/llm_optim.html">.xoptim.patterns_ort.llm_optim</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns_ort/missing_kernels.html">.xoptim.patterns_ort.missing_kernels</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns_ort/simplified_layer_normalization.html">.xoptim.patterns_ort.simplified_layer_normalization</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../api/xoptim/patterns_fix/index.html">.xoptim.patterns_fix</a><input aria-label="Toggle navigation of .xoptim.patterns_fix" class="toctree-checkbox" id="toctree-checkbox-20" name="toctree-checkbox-20" role="switch" type="checkbox"/><label for="toctree-checkbox-20"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api/xoptim/patterns_fix/add_reduction_scatter_nd.html">.xoptim.patterns_fix.add_reduction_scatter_nd</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/xoptim/graph_builder_optim.html">.xoptim.graph_builder_optim</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/xoptim/order_optim.html">.xoptim.order_optim</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/xoptim/patterns_api.html">.xoptim.patterns_api</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/xoptim/repeated_optim.html">.xoptim.repeated_optim</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/xoptim/unfused.html">.xoptim.unfused</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../api/xshape/index.html">.xshape</a><input aria-label="Toggle navigation of .xshape" class="toctree-checkbox" id="toctree-checkbox-21" name="toctree-checkbox-21" role="switch" type="checkbox"/><label for="toctree-checkbox-21"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api/xshape/expressions_torch.html">.xshape.expressions_torch</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/xshape/evaluate_expressions.html">.xshape.evaluate_expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/xshape/rename_expressions.html">.xshape.rename_expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/xshape/simplify_expressions.html">.xshape.simplify_expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/xshape/_builder_runtime.html">.xshape._builder_runtime</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/xshape/_inference_runtime.html">.xshape._inference_runtime</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/xshape/_shape_runtime.html">.xshape._shape_runtime</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/xshape/_shape_helper.html">.xshape._shape_helper</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/xshape/_onnx_helper.html">.xshape._onnx_helper</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/xshape/shape_builder.html">.xshape.shape_builder</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/xshape/shape_builder_impl.html">.xshape.shape_builder_impl</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/xshape/shape_type_compute.html">.xshape.shape_type_compute</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/xshape/type_inference.html">.xshape.type_inference</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../api/torch_dynamo/index.html">.torch_dynamo</a><input aria-label="Toggle navigation of .torch_dynamo" class="toctree-checkbox" id="toctree-checkbox-22" name="toctree-checkbox-22" role="switch" type="checkbox"/><label for="toctree-checkbox-22"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_dynamo/backend_helper.html">.torch_dynamo.backend_helper</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_dynamo/compiled_model.html">.torch_dynamo.compiled_model</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_dynamo/debug_backend.html">.torch_dynamo.debug_backend</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_dynamo/fast_backend.html">.torch_dynamo.fast_backend</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_dynamo/partition.html">experimental_experiment.torch_dynamo.partition</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../api/torch_bench/index.html">.torch_bench</a><input aria-label="Toggle navigation of .torch_bench" class="toctree-checkbox" id="toctree-checkbox-23" name="toctree-checkbox-23" role="switch" type="checkbox"/><label for="toctree-checkbox-23"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_bench/_bash_bench_benchmark_runner.html">experimental_experiment.torch_bench._bash_bench_benchmark_runner</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_bench/_bash_bench_benchmark_runner_agg.html">experimental_experiment.torch_bench._bash_bench_benchmark_runner_agg</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_bench/_bash_bench_benchmark_runner_agg_helper.html">experimental_experiment.torch_bench._bash_bench_benchmark_runner_agg_helper</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_bench/_bash_bench_cmd.html">experimental_experiment.torch_bench._bash_bench_cmd</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_bench/_bash_bench_model_runner.html">experimental_experiment.torch_bench._bash_bench_model_runner</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_bench/_bash_bench_models_helper.html">experimental_experiment.torch_bench._bash_bench_models_helper</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_bench/_bash_bench_set_dummies.html">experimental_experiment.torch_bench._bash_bench_set_dummies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_bench/_bash_bench_set_explicit.html">experimental_experiment.torch_bench._bash_bench_set_explicit</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_bench/_bash_bench_set_huggingface.html">experimental_experiment.torch_bench._bash_bench_set_huggingface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_bench/_bash_bench_set_timm.html">experimental_experiment.torch_bench._bash_bench_set_timm</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_bench/_bash_bench_set_torchbench.html">experimental_experiment.torch_bench._bash_bench_set_torchbench</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_bench/_bash_bench_set_torchbench_ado.html">experimental_experiment.torch_bench._bash_bench_set_torchbench_ado</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_bench/_bash_bench_untrained.html">experimental_experiment.torch_bench._bash_bench_untrained</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_bench/bash_bench_agg.html">.torch_bench.bash_bench_agg</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_bench/bash_bench_explicit.html">.torch_bench.bash_bench_explicit</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_bench/bash_bench_huggingface.html">.torch_bench.bash_bench_huggingface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_bench/bash_bench_timm.html">.torch_bench.bash_bench_timm</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_bench/bash_bench_torchbench.html">.torch_bench.bash_bench_torchbench</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_bench/bash_bench_torchbench_ado.html">.torch_bench.bash_bench_torchbench_ado</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_bench/bash_bench_untrained.html">.torch_bench.bash_bench_untrained</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_bench/check_model.html">.torch_bench.check_model</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_bench/export_model.html">.torch_bench.export_model</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/torch_bench/export_model_helper.html">.torch_bench.export_model_helper</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../api/_bench_test.html">._bench_test</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api/_command_lines_parser.html">._command_lines_parser</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api/args.html">.args</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api/bench_run.html">.bench_run</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api/checks.html">.checks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api/export_helpers.html">.export_helpers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api/ext_test_case.html">.ext_test_case</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api/helpers.html">.helpers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api/memory_peak.html">.memory_peak</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api/model_run.html">.model_run</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api/onnx_tools.html">.onnx_tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api/ort_session.html">.ort_session</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api/torch_test_helper.html">.torch_test_helper</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../galleries.html">Galleries of Examples and Recipes</a><input aria-label="Toggle navigation of Galleries of Examples and Recipes" class="toctree-checkbox" id="toctree-checkbox-24" name="toctree-checkbox-24" role="switch" type="checkbox"/><label for="toctree-checkbox-24"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../auto_examples/index.html">Examples Gallery</a><input aria-label="Toggle navigation of Examples Gallery" class="toctree-checkbox" id="toctree-checkbox-25" name="toctree-checkbox-25" role="switch" type="checkbox"/><label for="toctree-checkbox-25"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_examples/plot_torch_custom_backend_101.html">101: A custom backend for torch</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_examples/plot_torch_linreg_101.html">101: Linear Regression and export to ONNX</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_examples/plot_optimize_101.html">101: Onnx Model Optimization based on Pattern Rewriting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_examples/plot_rewrite_101.html">101: Onnx Model Rewriting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_examples/plot_profile_existing_onnx_101.html">101: Profile an existing model with onnxruntime</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_examples/plot_torch_export_101.html">101: Some dummy examples with torch.export.export</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_examples/plot_onnxscript_102.html">102: Examples with onnxscript</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_examples/plot_executorch_102.html">102: First test with ExecuTorch</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_examples/plot_torch_export_compile_102.html">102: Tweak onnx export</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_examples/plot_shape_inference.html">201: Better shape inference</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_examples/plot_torch_export_201.html">201: Evaluate different ways to export a torch model to ONNX</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_examples/plot_torch_sklearn_201.html">201: Use torch to export a scikit-learn model into ONNX</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_examples/plot_model_to_python.html">Playground for big optimization pattern</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../auto_recipes/index.html">Exporter Recipes Gallery</a><input aria-label="Toggle navigation of Exporter Recipes Gallery" class="toctree-checkbox" id="toctree-checkbox-26" name="toctree-checkbox-26" role="switch" type="checkbox"/><label for="toctree-checkbox-26"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_recipes/plot_exporter_exporter_untrained_tinyllm.html">Check the exporter on a dummy from HuggingFace</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_recipes/plot_exporter_exporter_phi35_piece.html">Export Phi-3.5-mini-instruct piece by piece</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_recipes/plot_exporter_exporter_draft_mode.html">Export Phi-3.5-mini-instruct with draft_export</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_recipes/plot_exporter_exporter_reportibility.html">Export Phi-3.5-mini-instruct with report_exportability</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_recipes/plot_exporter_exporter_scan_pdist.html">Export a model with a loop (scan)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_recipes/plot_exporter_recipes_c_custom_ops_inplace.html">to_onnx and a custom operator inplace</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_recipes/plot_exporter_recipes_c_custom_ops_fct.html">to_onnx and a custom operator registered with a function</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_recipes/plot_exporter_recipes_c_cond.html">to_onnx and a model with a test</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_recipes/plot_exporter_recipes_c_dynpad.html">to_onnx and padding one dimension to a mulitple of a constant</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_recipes/plot_exporter_recipes_c_modules.html">to_onnx and submodules from LLMs</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../command_lines.html">Command Lines</a><input aria-label="Toggle navigation of Command Lines" class="toctree-checkbox" id="toctree-checkbox-27" name="toctree-checkbox-27" role="switch" type="checkbox"/><label for="toctree-checkbox-27"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../bench/index.html">Benchmarks from the command line</a><input aria-label="Toggle navigation of Benchmarks from the command line" class="toctree-checkbox" id="toctree-checkbox-28" name="toctree-checkbox-28" role="switch" type="checkbox"/><label for="toctree-checkbox-28"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../bench/dort_bench.html">experimental_experiment.torch_bench.dort_bench</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../bench/dort_profile.html">experimental_experiment.torch_bench.dort_profile</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../bench/scripts.html">Interesting scripts or command lines</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../bench/bash_bench.html">Measuring the exporters on a short list of sets of models</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../tools/index.html">Tools from the command line</a><input aria-label="Toggle navigation of Tools from the command line" class="toctree-checkbox" id="toctree-checkbox-29" name="toctree-checkbox-29" role="switch" type="checkbox"/><label for="toctree-checkbox-29"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tools/lighten.html">python -m experimental_experiment lighten and unlighten</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tools/optimize.html">python -m experimental_experiment optimize</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tools/print.html">python -m experimental_experiment print</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tools/run.html">python -m experimental_experiment run</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../miscellaneous/index.html">Miscellaneous</a><input aria-label="Toggle navigation of Miscellaneous" class="toctree-checkbox" id="toctree-checkbox-30" name="toctree-checkbox-30" role="switch" type="checkbox"/><label for="toctree-checkbox-30"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../miscellaneous/export_times.html">Export Times</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../miscellaneous/long_outputs.html">Long Outputs uneasy to read</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../CHANGELOGS.html">Change Logs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <h1>Source code for experimental_experiment.xbuilder.graph_builder</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">contextlib</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pprint</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">textwrap</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">IntEnum</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Generator</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Iterator</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Set</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">onnx</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">AttributeProto</span><span class="p">,</span>
    <span class="n">FunctionProto</span><span class="p">,</span>
    <span class="n">GraphProto</span><span class="p">,</span>
    <span class="n">ModelProto</span><span class="p">,</span>
    <span class="n">NodeProto</span><span class="p">,</span>
    <span class="n">SparseTensorProto</span><span class="p">,</span>
    <span class="n">TensorProto</span><span class="p">,</span>
    <span class="n">TypeProto</span><span class="p">,</span>
    <span class="n">ValueInfoProto</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">onnx.helper</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">oh</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">onnx.numpy_helper</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">onh</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">onnx.external_data_helper</span><span class="w"> </span><span class="kn">import</span> <span class="n">uses_external_data</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">onnx.model_container</span><span class="w"> </span><span class="kn">import</span> <span class="n">make_large_tensor_proto</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">onnx.shape_inference</span><span class="w"> </span><span class="kn">import</span> <span class="n">infer_shapes</span> <span class="k">as</span> <span class="n">onnx_infer_shapes</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..helpers</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">dtype_to_tensor_dtype</span><span class="p">,</span>
    <span class="n">from_array_extended</span><span class="p">,</span>
    <span class="n">make_hash</span><span class="p">,</span>
    <span class="n">string_sig</span><span class="p">,</span>
    <span class="n">onnx_dtype_to_torch_dtype</span><span class="p">,</span>
    <span class="n">pretty_onnx</span><span class="p">,</span>
    <span class="n">size_type</span><span class="p">,</span>
    <span class="n">string_signature</span><span class="p">,</span>
    <span class="n">string_type</span><span class="p">,</span>
    <span class="n">torch_dtype_to_onnx_dtype</span><span class="p">,</span>
    <span class="n">make_idn</span><span class="p">,</span>
    <span class="n">make_idg</span><span class="p">,</span>
    <span class="n">onnx_dtype_name</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..xshape.rename_expressions</span><span class="w"> </span><span class="kn">import</span> <span class="n">rename_dynamic_dimensions</span><span class="p">,</span> <span class="n">rename_dynamic_expression</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..xshape._shape_helper</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">DYNAMIC_SHAPE</span><span class="p">,</span>
    <span class="n">STATIC_SHAPE</span><span class="p">,</span>
    <span class="n">all_int</span><span class="p">,</span>
    <span class="n">all_int_or_str</span><span class="p">,</span>
    <span class="n">is_static_dimension</span><span class="p">,</span>
    <span class="n">is_static_shape</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..xshape.shape_type_compute</span><span class="w"> </span><span class="kn">import</span> <span class="n">set_shape_type_op_any</span><span class="p">,</span> <span class="n">set_shape_type_custom</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..xshape._builder_runtime</span><span class="w"> </span><span class="kn">import</span> <span class="n">_BuilderRuntime</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..xshape._shape_runtime</span><span class="w"> </span><span class="kn">import</span> <span class="n">_ShapeRuntime</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..xshape._inference_runtime</span><span class="w"> </span><span class="kn">import</span> <span class="n">_InferenceRuntime</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..xshape._onnx_helper</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">element_wise_binary_op_types</span><span class="p">,</span>
    <span class="n">element_wise_op_cmp_types</span><span class="p">,</span>
    <span class="n">unary_like_op_types</span><span class="p">,</span>
    <span class="n">str_tensor_proto_type</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..xshape.simplify_expressions</span><span class="w"> </span><span class="kn">import</span> <span class="n">simplify_expression</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._onnx_helper</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">_default_OPSET_TO_IR_VERSION</span><span class="p">,</span>
    <span class="n">_nice_shape</span><span class="p">,</span>
    <span class="n">choose_consistent_domain_opset</span><span class="p">,</span>
    <span class="n">compatible_opsets</span><span class="p">,</span>
    <span class="n">same_function_proto</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.model_container</span><span class="w"> </span><span class="kn">import</span> <span class="n">TorchModelContainer</span><span class="p">,</span> <span class="n">proto_from_array</span><span class="p">,</span> <span class="n">_get_type</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.optimization_options</span><span class="w"> </span><span class="kn">import</span> <span class="n">OptimizationOptions</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..xshape.rename_expressions</span><span class="w"> </span><span class="kn">import</span> <span class="n">rename_expression</span><span class="p">,</span> <span class="n">parse_expression_tokens</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..xshape.simplify_expressions</span><span class="w"> </span><span class="kn">import</span> <span class="n">simplify_two_expressions</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..xshape.expressions_torch</span><span class="w"> </span><span class="kn">import</span> <span class="n">Expression</span><span class="p">,</span> <span class="n">parse_expression</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.graph_builder_opset</span><span class="w"> </span><span class="kn">import</span> <span class="n">Opset</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.virtual_tensor</span><span class="w"> </span><span class="kn">import</span> <span class="n">VirtualTensor</span>


<span class="c1"># To help finding bugs.</span>
<span class="k">def</span><span class="w"> </span><span class="nf">assert_sorted</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>


<span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_unset_fake_temporarily</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>

    <span class="n">old</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">_unset_dispatch_mode</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">_TorchDispatchModeKey</span><span class="o">.</span><span class="n">FAKE</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">old</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">old</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">_set_dispatch_mode</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>


<div class="viewcode-block" id="FunctionOptions">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.FunctionOptions">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FunctionOptions</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines how local functions must behave.</span>

<span class="sd">    :param name: function name</span>
<span class="sd">    :param domain: function domain</span>
<span class="sd">    :param export_as_function: export the onnx as functions or keep local function</span>
<span class="sd">    :param external_threshold: whether or not keep initializer as input for the function</span>
<span class="sd">        or move them as constant of the function</span>
<span class="sd">    :param move_initializer_to_constant: move initializers as constant first before</span>
<span class="sd">        creating the function proto, that depends on the size defined by</span>
<span class="sd">        external_threshold</span>
<span class="sd">    :param return_initializer: return the remaining initializer and add them as input</span>
<span class="sd">        to the function</span>
<span class="sd">    :param inline: inline functions</span>
<span class="sd">    :param rename_allowed: allow to rename the function if a duplicate is detected</span>
<span class="sd">    :param merge_allowed: allow to merge a function in case the same code is detected</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">empty_names</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">export_as_function</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">domain</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">external_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">25</span><span class="p">,</span>
        <span class="n">move_initializer_to_constant</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_initializer</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">inline</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">merge_allowed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">rename_allowed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
            <span class="n">export_as_function</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">export_as_function</span> <span class="ow">or</span> <span class="n">name</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;to be removed, helps tracking bugs, name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, domain=</span><span class="si">{</span><span class="n">domain</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;export_as_function=</span><span class="si">{</span><span class="n">export_as_function</span><span class="si">!r}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="n">export_as_function</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">name</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">domain</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;to be removed help track bugs, name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, domain=</span><span class="si">{</span><span class="n">domain</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;export_as_function=</span><span class="si">{</span><span class="n">export_as_function</span><span class="si">!r}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">external_threshold</span><span class="p">,</span> <span class="nb">int</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">external_threshold</span><span class="p">)</span><span class="si">}</span><span class="s2"> for external_threshold&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">export_as_function</span> <span class="o">=</span> <span class="n">export_as_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">external_threshold</span> <span class="o">=</span> <span class="n">external_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">move_initializer_to_constant</span> <span class="o">=</span> <span class="n">move_initializer_to_constant</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_initializer</span> <span class="o">=</span> <span class="n">return_initializer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inline</span> <span class="o">=</span> <span class="n">inline</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rename_allowed</span> <span class="o">=</span> <span class="n">rename_allowed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merge_allowed</span> <span class="o">=</span> <span class="n">merge_allowed</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="s2">&quot;usual&quot;</span>
        <span class="k">return</span> <span class="n">string_sig</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>



<div class="viewcode-block" id="InferShapesOptions">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.InferShapesOptions">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">InferShapesOptions</span><span class="p">(</span><span class="n">IntEnum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines options when running shape inference on an existing model.</span>
<span class="sd">    Options ``NEW`` means shapes informations is removed by running it again.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">NONE</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">NEW</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">ONNX</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">DATA_PROP</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">BUILDER</span> <span class="o">=</span> <span class="mi">8</span></div>



<div class="viewcode-block" id="GraphBuilder">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GraphBuilder</span><span class="p">(</span><span class="n">_BuilderRuntime</span><span class="p">,</span> <span class="n">_ShapeRuntime</span><span class="p">,</span> <span class="n">_InferenceRuntime</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplifies the creation of a model.</span>

<span class="sd">    :param target_opset_or_existing_proto: a ModelProto, an integer,</span>
<span class="sd">        a dictionary of domain, version</span>
<span class="sd">    :param input_names: input names</span>
<span class="sd">    :param as_function: export as a function or a model</span>
<span class="sd">       there are less assert when as_function is True</span>
<span class="sd">    :param optimization_options: optimizations options,</span>
<span class="sd">        see :class:`OptimizationOptions`</span>
<span class="sd">    :param args: example of inputs</span>
<span class="sd">    :param kwargs: example of inputs</span>
<span class="sd">    :param ir_version: ir version when exporting</span>
<span class="sd">    :param verbose: verbosity</span>
<span class="sd">    :param infer_shapes_options: options when running</span>
<span class="sd">        shape inference for an existing model</span>
<span class="sd">    :param raise_list: raise an exception if a new operator belongs to that list</span>
<span class="sd">    :param dynamic_shapes: dynamic shapes</span>
<span class="sd">    :param local_domain: domain name to use for local functions if not specified</span>
<span class="sd">    :param signature: the signature is unused but helps for debugging purposes</span>
<span class="sd">    :param check_empty_source: checks source are not empty</span>
<span class="sd">    :param graph_module: only used for debugging purpose</span>
<span class="sd">    :param exe_path: gives information on how the :class:`torch.fx.Graph` was obtained</span>
<span class="sd">    :param output_names: output names</span>
<span class="sd">    :param output_dynamic_shapes: same as dynamic_shapes but for the output</span>
<span class="sd">    :param _opsets: to overwrite opsets when the builder receives a `GraphProto`</span>
<span class="sd">    :param _context: known names from the parent graph is any</span>
<span class="sd">    :param _parent: parent owning the builder is any</span>

<span class="sd">    Important attributes:</span>

<span class="sd">    - `input_names: List[str]`: list of input names</span>
<span class="sd">    - `output_names: List[str]`: list of output names</span>
<span class="sd">    - `as_function: bool`: the model must be exported as a function or as a model,</span>
<span class="sd">      there are less assert when as_function is True</span>
<span class="sd">    - `optimization_options: OptimizationOptions`:</span>
<span class="sd">    - `nodes: List[NodeProto]`: list of nodes</span>
<span class="sd">    - `initializers_dict: Dict[str, Any]`: initializers</span>
<span class="sd">    - `initializers_dict_sources: Dict[str, InitializerInfo]`:</span>
<span class="sd">      information about where the initiliazers was created</span>
<span class="sd">    - `inputs: List[ValueInfoTensorProto]`: inputs</span>
<span class="sd">    - `outputs: List[ValueInfoTensorProto]`: outputs</span>
<span class="sd">    - `ir_version: int`: ir version</span>
<span class="sd">    - `opsets: Dict[str, int]`: declared opsets</span>
<span class="sd">    - `input_args: List[T]`: input tensors when</span>
<span class="sd">      the class is used to convert an existing model</span>
<span class="sd">    - `input_kwargs: Dict[str, T]`: input tensors when</span>
<span class="sd">      the class is used to convert an existing model</span>
<span class="sd">    - `functions: Dict[Tuple[str,str], FunctionProto]`:</span>
<span class="sd">      dictionary of functions to add to the model</span>
<span class="sd">    - `value_info: List[ValueInfoProto]`: value info of the original model</span>
<span class="sd">    - `dynamic_shapes: Union[Dict[str, Any], Tuple[Any]]]`: dynamic_shapes informations</span>
<span class="sd">    - `_parameter_renaming: Dict[str, str]`: to rename parameter and give them</span>
<span class="sd">      a name which can be found in ``module.named_parameter``</span>

<span class="sd">    Computed attributes:</span>

<span class="sd">    - `_unique_names`: used to create unused result names</span>
<span class="sd">    - `_unique_node_names`: used to create unused node names</span>
<span class="sd">    - `_known_names`: set of existing results names</span>
<span class="sd">    - `_known_shapes: Dict[str, DYNAMIC_SHAPE]`: declared shapes</span>
<span class="sd">    - `_known_types: Dict[str, int]`: declared element types</span>
<span class="sd">    - `_known_devices: Dict[str, int]`: declared devices</span>
<span class="sd">    - `_known_value_shape: Dict[str, Any]`: if a result is a shape or not</span>
<span class="sd">      (for example the output of operator Shape)</span>
<span class="sd">    - `_known_ranks: Dict[str, int]`: declared ranks</span>
<span class="sd">    - `_known_sequences: Dict[str, Dict[str, Any]]`: known sequences</span>
<span class="sd">    - `_dynamic_examples: Dict[str, Set[Union[int,float]]]`: example of dynamic dimensions</span>
<span class="sd">    - `constants_node_: Dict[bytes, NodeProto]`: constant node</span>
<span class="sd">    - `constants_alias_: Dict[str, str]`: alias for constant</span>
<span class="sd">    - `constants_: Dict[str, Any]`: constant values</span>
<span class="sd">    - `constants_computed_: Dict[str, Any]`: computed constant values</span>
<span class="sd">    - `dynamic_objects: Dict[str, torch.SymInt]`: list of dynamic dimension</span>
<span class="sd">    - `dynamic_objects_rev: Dict[str, str]`: reverse dictionary to fasten lookups</span>
<span class="sd">    - `_cache_shape: Dict[key,str]`: cache concatenation of shapes</span>
<span class="sd">    - `_values: Dict[key,str]`: cache initializer value to merge those which are equal</span>
<span class="sd">    - `_dynamic_alias: Dict[str,str]`: used when the user gives a different</span>
<span class="sd">        name to the dynamic shapes</span>
<span class="sd">    - `constraints_: Dict[str, Set[Any]]`:</span>
<span class="sd">        if a broadcast implies a constraints on a dynamic shape,</span>
<span class="sd">        it is stored here</span>
<span class="sd">    - `_events`: is used to retrieve any information useful to debug</span>

<span class="sd">    Debugging attributes:</span>

<span class="sd">    - `_raise_list: Set[str]`: the builder stop if a result falls in that list</span>
<span class="sd">      (debugging tool)</span>

<span class="sd">    You can setup environment variable ``ONNXSTOP``, ``ONNXSTOPSHAPE``, ``ONNXSTOPTYPE``,</span>
<span class="sd">    ``ONNXSTOPVALUESHAPE``, ``ONNXSTOPOUTPUT`` to raise an exception when the type or shape</span>
<span class="sd">    of a variable is set. Example: ``ONNXSTOP=attn_output python ...``.</span>
<span class="sd">    ``ONNXCST=1`` shows which constant is computed,</span>
<span class="sd">    ``NULLSHAPE=1`` raises an exception as soon as a null shape occurs. The code includes:</span>

<span class="sd">    ::</span>

<span class="sd">        self._debug_null_shape = int(os.environ.get(&quot;NULLSHAPE&quot;, &quot;0&quot;))</span>
<span class="sd">        self._debug_stop = os.environ.get(&quot;ONNXSTOP&quot;, &quot;#?#&quot;)</span>
<span class="sd">        self._debug_stop_shape = os.environ.get(&quot;ONNXSTOPSHAPE&quot;, &quot;#?#&quot;)</span>
<span class="sd">        self._debug_stop_type = os.environ.get(&quot;ONNXSTOPTYPE&quot;, &quot;#?#&quot;)</span>
<span class="sd">        self._debug_stop_sequence = os.environ.get(&quot;ONNXSTOPSEQUENCE&quot;, &quot;#?#&quot;)</span>
<span class="sd">        self._debug_get_constant = int(os.environ.get(&quot;ONNXCST&quot;, &quot;0&quot;))</span>
<span class="sd">        self._debug_foldnot = int(os.environ.get(&quot;ONNXFOLDNOT&quot;, &quot;0&quot;))</span>
<span class="sd">        self._debug_local_function = int(os.environ.get(&quot;ONNXFUNC&quot;, &quot;0&quot;))</span>
<span class="sd">        self._debug_value_shape = os.environ.get(&quot;ONNXSTOPVALUESHAPE&quot;, &quot;&quot;)</span>
<span class="sd">        self._debug_node_output = os.environ.get(&quot;ONNXSTOPOUTPUT&quot;, &quot;&quot;)</span>
<span class="sd">        self._debug_node_type = os.environ.get(&quot;ONNXNODETYPE&quot;, &quot;&quot;)</span>
<span class="sd">        self._debug_quiet = int(os.environ.get(&quot;ONNXQUIET&quot;, &quot;0&quot;))</span>
<span class="sd">        self._debug_shape_missing = int(os.environ.get(&quot;ONNXSHAPECOMPUTE&quot;, &quot;0&quot;))</span>
<span class="sd">        self._debug_constant_folding = int(os.environ.get(&quot;ONNXCONSTANTFOLD&quot;, &quot;0&quot;))</span>
<span class="sd">        self._debug_dyn_dim = os.environ.get(&quot;ONNXDYNDIM&quot;,&quot;&quot;).split(&quot;,&quot;)</span>
<span class="sd">        self._debug_print_node = os.environ.get(&quot;PRINTNAME&quot;,&quot;&quot;).split(&quot;,&quot;)</span>

<span class="sd">    .. warning:: ModelProto may be modified</span>

<span class="sd">        The builder tries to minimize the copies of protos. The original</span>
<span class="sd">        model may be modified if the builder is initialized with a model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">MINUS_ONE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">ONE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">ONE_NO_DIM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">ZERO</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">ZERO_NO_DIM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="c1"># MAXINT for int64, means a slice goes up to the last element</span>
    <span class="n">END</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">9223372036854775807</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

<div class="viewcode-block" id="GraphBuilder.ShapeConstant">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.ShapeConstant">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">ShapeConstant</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wraps a constant shape even if the input producing the shape is not.&quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">node</span><span class="p">:</span> <span class="n">NodeProto</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, shape=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;node=&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="GraphBuilder.WrapSym">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.WrapSym">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">WrapSym</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wraps a symbolic int (a dimension for example).&quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sym</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;torch.SymInt&quot;</span><span class="p">,</span> <span class="s2">&quot;torch.SymFloat&quot;</span><span class="p">]):</span>  <span class="c1"># noqa: F821</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">GraphBuilder</span><span class="o">.</span><span class="n">WrapDim</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sym</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span>
                    <span class="n">sym</span><span class="p">,</span> <span class="s2">&quot;node&quot;</span>
                <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Missing attribute node for type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sym</span> <span class="o">=</span> <span class="n">sym</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;WrapSym(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_to_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sym</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>

        <span class="nd">@property</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_to_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sym</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_dynamic_to_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">obj</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">export</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">_DerivedDim</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">export</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">_Dim</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">SymFloat</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">node</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">_expr</span>
                <span class="k">if</span> <span class="s2">&quot;sympy&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="si">}</span><span class="s2"> to convert into string&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="GraphBuilder.WrapDim">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.WrapDim">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">WrapDim</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wraps a string considered as a ``torch.export.Dim``.&quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;WrapDim(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">)&quot;</span>

        <span class="nd">@property</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">name_as_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Dim&quot;</span><span class="p">:</span>
                <span class="c1"># It should be torch.export.dynamic_shapes.Dim</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unable to return the dimension as a string type is &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">, name=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="GraphBuilder.InitializerInfo">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.InitializerInfo">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">InitializerInfo</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tracks the location where the initializer was created.</span>

<span class="sd">        :param name: initializer name</span>
<span class="sd">        :param source: information</span>
<span class="sd">        :param same_as: same as an existing initializers</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">same_as</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">same_as</span> <span class="o">=</span> <span class="n">same_as</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">same_as</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;InitializerInfo(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, source=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;same_as=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">same_as</span><span class="si">!r}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;InitializerInfo(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, source=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="si">!r}</span><span class="s2">)&quot;</span>

<div class="viewcode-block" id="GraphBuilder.InitializerInfo.add_source">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.InitializerInfo.add_source">[docs]</a>
        <span class="k">def</span><span class="w"> </span><span class="nf">add_source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Adds other sources.&quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;##</span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2">&quot;</span></div>
</div>


    <span class="c1"># Size of a tensor kept in the onnx file and not stored as exrternal weight.</span>
    <span class="n">SMALL_TENSOR</span> <span class="o">=</span> <span class="mi">1024</span>

    <span class="n">_op_type_element_wise_types</span> <span class="o">=</span> <span class="n">element_wise_binary_op_types</span><span class="p">()</span>
    <span class="n">_op_type_element_wise_cmp_types</span> <span class="o">=</span> <span class="n">element_wise_op_cmp_types</span><span class="p">()</span>
    <span class="n">_op_type_unary_like</span> <span class="o">=</span> <span class="n">unary_like_op_types</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target_opset_or_existing_proto</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">GraphProto</span><span class="p">,</span> <span class="n">ModelProto</span><span class="p">,</span> <span class="n">FunctionProto</span>
        <span class="p">],</span>
        <span class="n">input_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">as_function</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">optimization_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">OptimizationOptions</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ir_version</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">infer_shapes_options</span><span class="p">:</span> <span class="n">InferShapesOptions</span> <span class="o">=</span> <span class="n">InferShapesOptions</span><span class="o">.</span><span class="n">NONE</span><span class="p">,</span>
        <span class="n">raise_list</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dynamic_shapes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">local_domain</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;local_function&quot;</span><span class="p">,</span>
        <span class="n">signature</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">check_empty_source</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">graph_module</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;torch.fx.GraphModule&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># noqa: F821</span>
        <span class="n">exe_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">output_dynamic_shapes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_opsets</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_context</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="s2">&quot;GraphBuilder&quot;</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="s2">&quot;GraphBuilder&quot;</span><span class="p">,</span> <span class="n">NodeProto</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">TEMPLATE_TYPE</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">TEMPLATE_TYPE</span> <span class="o">=</span> <span class="n">TEMPLATE_TYPE</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">torch</span> <span class="o">=</span> <span class="n">torch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maybe_disable_fake_tensor_mode</span> <span class="o">=</span> <span class="n">_unset_fake_temporarily</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span> <span class="o">=</span> <span class="n">optimization_options</span> <span class="ow">or</span> <span class="n">OptimizationOptions</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local_domain</span> <span class="o">=</span> <span class="n">local_domain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">as_function</span> <span class="o">=</span> <span class="n">as_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ir_version</span> <span class="o">=</span> <span class="n">ir_version</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_debug_msg</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;EXEPATH&quot;</span><span class="p">:</span> <span class="n">exe_path</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source_flat</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dynamic_dimensions_source_flat</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pre_process_dynamic_shape</span><span class="p">(</span><span class="n">dynamic_shapes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dynamic_shapes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pre_process_dynamic_shape</span><span class="p">(</span><span class="n">output_dynamic_shapes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects_rev</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions_builder</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value_info</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raise_list</span> <span class="o">=</span> <span class="n">raise_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_list</span> <span class="o">=</span> <span class="n">raise_list</span> <span class="ow">or</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constants_computed_</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache_shape</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_alias</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constants_node_</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constants_alias_</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_module</span> <span class="o">=</span> <span class="n">graph_module</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_events</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">signature</span> <span class="o">=</span> <span class="n">signature</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_empty_source</span> <span class="o">=</span> <span class="n">check_empty_source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user_defined_output_names</span> <span class="o">=</span> <span class="n">output_names</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_context</span> <span class="o">=</span> <span class="n">_context</span> <span class="ow">or</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_not_turn_constant_initializers</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_parent</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="n">_parent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span> <span class="o">=</span> <span class="n">_parent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="n">_parent</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_known_shapes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_known_types</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_known_ranks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_known_devices</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_known_torch_value</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_known_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_known_sequences</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unique_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unique_node_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_examples</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_norename</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constants_</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">Opset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">anyop</span> <span class="o">=</span> <span class="n">Opset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allow_unknown</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_debug_null_shape</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;NULLSHAPE&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_debug_stop</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ONNXSTOP&quot;</span><span class="p">,</span> <span class="s2">&quot;#?#&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_debug_stop_shape</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ONNXSTOPSHAPE&quot;</span><span class="p">,</span> <span class="s2">&quot;#?#&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_debug_stop_type</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ONNXSTOPTYPE&quot;</span><span class="p">,</span> <span class="s2">&quot;#?#&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_debug_stop_sequence</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ONNXSTOPSEQUENCE&quot;</span><span class="p">,</span> <span class="s2">&quot;#?#&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_debug_get_constant</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ONNXCST&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_debug_local_function</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ONNXFUNC&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_debug_value_shape</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ONNXSTOPVALUESHAPE&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_debug_node_output</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ONNXSTOPOUTPUT&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_debug_node_type</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ONNXNODETYPE&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_debug_quiet</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ONNXQUIET&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_debug_shape_missing</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ONNXSHAPECOMPUTE&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_debug_constant_folding</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ONNXCONSTANTFOLD&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_debug_foldnot</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ONNXFOLDNOT&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_debug_dyn_dim</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ONNXDYNDIM&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_debug_print_node</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;PRINTNAME&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">CONTINUE</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;CONTINUE&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_dyn_dim</span> <span class="o">==</span> <span class="p">{</span><span class="s2">&quot;&quot;</span><span class="p">}:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_debug_dyn_dim</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">time_evaluation_constants_</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">statistics_</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraints_</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_registered_users</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">was_inputs_renamed</span> <span class="o">=</span> <span class="n">input_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">input_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_dynamic_shape_when_input_name_is_defined</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_implicit_decisions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">assert</span> <span class="n">dynamic_shapes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dynamic_shapes</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;dynamic_shapes is expected to be empty or a dictionary or a tuple &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">dynamic_shapes</span><span class="p">)</span><span class="si">}</span><span class="s2">, dynamic_shapes=</span><span class="si">{</span><span class="n">dynamic_shapes</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_register_dynamic_object_from_dynamic_shapes</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dynamic_shapes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_register_dynamic_object_from_dynamic_shapes</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">infer_shapes_options</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">infer_shapes_options</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">InferShapesOptions</span><span class="o">.</span><span class="n">ONNX</span> <span class="k">if</span> <span class="n">infer_shapes_options</span> <span class="k">else</span> <span class="n">InferShapesOptions</span><span class="o">.</span><span class="n">NONE</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_opset_or_existing_proto</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
            <span class="c1"># starts a model from nothing</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="n">infer_shapes_options</span>
            <span class="p">),</span> <span class="s2">&quot;infer_shapes_options is used if an existing model is loaded&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;&quot;</span><span class="p">:</span> <span class="n">target_opset_or_existing_proto</span><span class="p">}</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_opset_or_existing_proto</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
                <span class="k">else</span> <span class="n">target_opset_or_existing_proto</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_names</span> <span class="o">=</span> <span class="n">input_names</span> <span class="ow">or</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_input</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unique_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_names</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_opset_or_existing_proto</span><span class="p">,</span> <span class="p">(</span><span class="n">GraphProto</span><span class="p">,</span> <span class="n">ModelProto</span><span class="p">,</span> <span class="n">FunctionProto</span><span class="p">)):</span>
            <span class="c1"># loads a model from nothing</span>
            <span class="k">if</span> <span class="n">input_names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input_names must be empty if the input is an existing model.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_input</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_opset_or_existing_proto</span><span class="p">,</span> <span class="n">GraphProto</span><span class="p">):</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="n">_opsets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="p">),</span> <span class="s2">&quot;_opsets must be specified if the input is a GraphProto&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span> <span class="o">=</span> <span class="n">_opsets</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">_opsets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;_opsets must be None if the input is not a GraphProto&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_structures_with_proto</span><span class="p">(</span>
                <span class="n">target_opset_or_existing_proto</span><span class="p">,</span> <span class="n">infer_shapes_options</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constant_folding</span><span class="p">(</span>
                <span class="p">(</span><span class="n">optimization_options</span> <span class="ow">or</span> <span class="n">OptimizationOptions</span><span class="p">())</span><span class="o">.</span><span class="n">constant_folding</span><span class="p">,</span>
                <span class="n">convert_into_initializer</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_opset_or_existing_proto</span><span class="p">,</span> <span class="n">FunctionProto</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_shape_types_with_proto</span><span class="p">(</span>
                    <span class="n">target_opset_or_existing_proto</span><span class="p">,</span> <span class="n">infer_shapes_options</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">target_opset_or_existing_proto</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not supported.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="GraphBuilder.has_exact_same_constant_in_context">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.has_exact_same_constant_in_context">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_exact_same_constant_in_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tells if this constant already exiting in the context of the main graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">cstp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">is_constant_part_of_previous_context</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cst</span> <span class="ow">and</span> <span class="n">cstp</span><span class="p">:</span>
            <span class="c1"># Maybe it the same constant and then it is ok.</span>
            <span class="c1"># Should be compare (only if the cost if not two much)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">shape1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="n">shape2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">shape1</span> <span class="o">!=</span> <span class="n">shape2</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="n">n_elem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n_elem</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">:</span>
                    <span class="c1"># Then the code is not much.</span>
                    <span class="n">cst1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_constant</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">exc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">computed_value</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">cst2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_constant_from_parent</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">exc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">computed_value</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">cst1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cst2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="n">cst1</span> <span class="o">-</span> <span class="n">cst2</span>
                        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">==</span> <span class="n">d</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">return</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="GraphBuilder.do_not_turn_constant_initializers_maybe_because_of_showing">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.do_not_turn_constant_initializers_maybe_because_of_showing">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">do_not_turn_constant_initializers_maybe_because_of_showing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constants are turned into initializers in the main graph.</span>
<span class="sd">        It is not possible in function or not always safe inside subgraphs</span>
<span class="sd">        (due to shadowing).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_not_turn_constant_initializers</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">:</span>
            <span class="c1"># The current behaviour could be improved because</span>
            <span class="c1"># the name could been create after this subgraph is really used</span>
            <span class="c1"># in the parent graph.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_exact_same_constant_in_context</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="ow">not</span> <span class="n">r</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">do_not_turn_constant_initializers_maybe_because_of_showing</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="GraphBuilder.make_subset_builder">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.make_subset_builder">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_subset_builder</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">input_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">domain</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">add_local_functions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;GraphBuilder&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a copy of the existing builder but with information reduced to the input_names</span>
<span class="sd">        considered as inputs.</span>

<span class="sd">        :param input_names: new inputs</span>
<span class="sd">        :param name: function name</span>
<span class="sd">        :param domain: domain name for the function</span>
<span class="sd">        :param add_local_functions: adds the local function as well</span>
<span class="sd">        :return: shortened builder</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># new dynamic_shapes</span>
        <span class="n">ds2</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">input_names</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sequence</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Input </span><span class="si">{</span><span class="n">n</span><span class="si">!r}</span><span class="s2"> is sequence but that&#39;s not yet implemented&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">ds2</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span>
                <span class="k">break</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">s</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">)}</span>
            <span class="n">ds2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
        <span class="n">ds2</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ds2</span><span class="p">)</span>

        <span class="n">new_builder</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="p">(</span>
            <span class="n">target_opset_or_existing_proto</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">,</span>
            <span class="n">input_names</span><span class="o">=</span><span class="n">input_names</span><span class="p">,</span>
            <span class="n">as_function</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">optimization_options</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="p">,</span>
            <span class="n">ir_version</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ir_version</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="n">infer_shapes_options</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">raise_list</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">raise_list</span><span class="p">,</span>
            <span class="n">local_domain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">local_domain</span><span class="p">,</span>
            <span class="n">dynamic_shapes</span><span class="o">=</span><span class="n">ds2</span><span class="p">,</span>
            <span class="n">_parent</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">new_builder</span><span class="o">.</span><span class="n">dynamic_objects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">input_names</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sequence</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Input </span><span class="si">{</span><span class="n">n</span><span class="si">!r}</span><span class="s2"> is sequence but that&#39;s not yet implemented&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">new_builder</span><span class="o">.</span><span class="n">make_tensor_input</span><span class="p">(</span>
                <span class="n">n</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">n</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">is_dimension</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_is_dimension</span><span class="p">(</span><span class="n">n</span><span class="p">),</span>
                <span class="n">marker</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;make_subset_builder-</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">add_local_functions</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">assert</span> <span class="n">k</span> <span class="o">==</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Not implemented when k=</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> and function is &#39;</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">domain</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">new_builder</span><span class="o">.</span><span class="n">add_function</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">rename_allowed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">merge_allowed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_builder</span></div>


    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_pre_process_dynamic_shape</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">dynamic_shapes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unique_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Replaces Hints by true DynamicShapes.&quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dynamic_shapes</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">export</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">_Dim</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">dynamic_shapes</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dynamic_shapes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># Not allowed by pytorch but allowed here.</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">WrapDim</span><span class="p">(</span><span class="n">dynamic_shapes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dynamic_shapes</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">WrapDim</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">dynamic_shapes</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dynamic_shapes</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dynamic_shapes</span>
        <span class="k">if</span> <span class="n">unique_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unique_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dynamic_shapes</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">dynamic_shapes</span><span class="p">)(</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_pre_process_dynamic_shape</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">unique_names</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dynamic_shapes</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dynamic_shapes</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_pre_process_dynamic_shape</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">unique_names</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="k">if</span> <span class="n">dynamic_shapes</span> <span class="ow">in</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">export</span><span class="o">.</span><span class="n">Dim</span><span class="o">.</span><span class="n">DYNAMIC</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">export</span><span class="o">.</span><span class="n">Dim</span><span class="o">.</span><span class="n">AUTO</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;DYN0&quot;</span>
            <span class="k">while</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">unique_names</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;DYN</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">unique_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">export</span><span class="o">.</span><span class="n">Dim</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">dynamic_shapes</span><span class="p">)</span><span class="si">}</span><span class="s2"> for dynamic_shapes&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_register_dynamic_object_from_dynamic_shapes_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_name</span><span class="p">,</span> <span class="n">shape_dict</span><span class="p">):</span>
        <span class="c1"># example:</span>
        <span class="c1"># args_0 {0: &lt;class &#39;._bash_bench_model_runner.batch&#39;&gt;}</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">handle_dim</span><span class="p">(</span><span class="n">_k</span><span class="p">,</span> <span class="n">_v</span><span class="p">,</span> <span class="n">input_name</span><span class="o">=</span><span class="n">input_name</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">make_dynamic_object</span><span class="p">(</span>
                    <span class="n">_v</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                    <span class="n">_v</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">_k</span><span class="p">,</span>
                    <span class="n">input_name</span><span class="o">=</span><span class="n">input_name</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">export</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">_DerivedDim</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">make_dynamic_object</span><span class="p">(</span>
                    <span class="n">_v</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">(</span><span class="n">_v</span><span class="o">.</span><span class="vm">__name__</span><span class="p">),</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">_k</span><span class="p">,</span>
                    <span class="n">input_name</span><span class="o">=</span><span class="n">input_name</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># It should be recursive.</span>
                <span class="c1"># maybe add a constraint here</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">make_dynamic_object</span><span class="p">(</span>
                    <span class="n">_v</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">(</span><span class="n">_v</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="vm">__name__</span><span class="p">),</span>
                    <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">input_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">export</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">_Dim</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">make_dynamic_object</span><span class="p">(</span>
                    <span class="n">_v</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">(</span><span class="n">_v</span><span class="o">.</span><span class="vm">__name__</span><span class="p">),</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">_k</span><span class="p">,</span>
                    <span class="n">input_name</span><span class="o">=</span><span class="n">input_name</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">WrapDim</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">make_dynamic_object</span><span class="p">(</span>
                    <span class="n">_v</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">(</span><span class="n">_v</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">_k</span><span class="p">,</span>
                    <span class="n">input_name</span><span class="o">=</span><span class="n">input_name</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">_v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">_v</span><span class="p">)</span><span class="si">}</span><span class="s2"> for dynamic &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;dimension for axis </span><span class="si">{</span><span class="n">_k</span><span class="si">}</span><span class="s2">, input_name=</span><span class="si">{</span><span class="n">input_name</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;pos_vv=</span><span class="si">{</span><span class="n">shape_dict</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;self.dynamic_shapes=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;self.output_dynamic_shapes=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dynamic_shapes</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># A scalar, no axis.</span>
            <span class="n">handle_dim</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape_dict</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">_k</span><span class="p">,</span> <span class="n">_v</span> <span class="ow">in</span> <span class="n">shape_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">handle_dim</span><span class="p">(</span><span class="n">_k</span><span class="p">,</span> <span class="n">_v</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_register_dynamic_object_from_dynamic_shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">dynamic_shapes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dynamic_shapes</span> <span class="k">if</span> <span class="n">output</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">dynamic_shapes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Call this method if dynamic_shapes is not None, output=</span><span class="si">{</span><span class="n">output</span><span class="si">!r}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">output</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_dynamic_shape_when_input_name_is_defined</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">dynamic_shapes</span><span class="p">,</span> <span class="nb">dict</span>
            <span class="p">)</span>
        <span class="n">_prefixes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_unfold</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">prefix</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type prefix=</span><span class="si">{</span><span class="n">prefix</span><span class="si">!r}</span><span class="s2">, obj=</span><span class="si">{</span><span class="n">obj</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="n">all_int</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;prefix is None for obj=</span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">_prefixes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">[(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">obj</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">k</span>
                        <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="kc">None</span>
                        <span class="k">else</span> <span class="p">((</span><span class="n">prefix</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="k">else</span> <span class="p">(</span><span class="o">*</span><span class="n">prefix</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
                    <span class="p">)</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="n">_unfold</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">res</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">k</span>
                        <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="kc">None</span>
                        <span class="k">else</span> <span class="p">((</span><span class="n">prefix</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="k">else</span> <span class="p">(</span><span class="o">*</span><span class="n">prefix</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
                    <span class="p">)</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="n">_unfold</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">res</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">export</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">_Dim</span><span class="p">)):</span>
                <span class="n">_prefixes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">[(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">obj</span><span class="p">)]</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="si">}</span><span class="s2"> and prefix=</span><span class="si">{</span><span class="n">prefix</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">seq_dynamic_shapes</span> <span class="o">=</span> <span class="n">_unfold</span><span class="p">(</span><span class="n">dynamic_shapes</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">input_name_or_position</span><span class="p">,</span> <span class="n">pos_vv</span> <span class="ow">in</span> <span class="n">seq_dynamic_shapes</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pos_vv</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">export</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">_Dim</span><span class="p">)),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unexpected pos_vv=</span><span class="si">{</span><span class="n">pos_vv</span><span class="si">}</span><span class="s2"> (type is </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">pos_vv</span><span class="p">)</span><span class="si">}</span><span class="s2">), &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;input_name_or_position=</span><span class="si">{</span><span class="n">input_name_or_position</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_register_dynamic_object_from_dynamic_shapes_dict</span><span class="p">(</span><span class="n">input_name_or_position</span><span class="p">,</span> <span class="n">pos_vv</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">output</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source_flat</span> <span class="o">=</span> <span class="n">_prefixes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_dynamic_dimensions_source_flat</span> <span class="o">=</span> <span class="n">_prefixes</span>

<div class="viewcode-block" id="GraphBuilder.add_stat">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.add_stat">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_stat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Increments a counter.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">statistics_</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">statistics_</span><span class="p">[</span><span class="n">kind</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">stat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">statistics_</span><span class="p">[</span><span class="n">kind</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stat</span><span class="p">:</span>
            <span class="n">stat</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stat</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">output_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">]</span>

<div class="viewcode-block" id="GraphBuilder.empty_copy">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.empty_copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">empty_copy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">as_function</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">constant_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">24</span><span class="p">,</span> <span class="n">_shapable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;GraphBuilder&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an empty copy but with the same opsets.</span>
<span class="sd">        This is used in pattern matching.</span>

<span class="sd">        :param as_function: to create a function</span>
<span class="sd">        :param constant_size: maximum size of a constant</span>
<span class="sd">        :param _shapable: disable check on shapes if enable</span>
<span class="sd">        :return: new graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">as_function</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;wrong type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">as_function</span><span class="p">)</span><span class="si">}</span><span class="s2"> for as_function&quot;</span>
        <span class="n">opt</span> <span class="o">=</span> <span class="n">OptimizationOptions</span><span class="p">(</span>
            <span class="n">constant_size</span><span class="o">=</span><span class="n">constant_size</span><span class="p">,</span>
            <span class="n">constant_fusing</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">remove_identity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">remove_duplicated_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">patterns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">ir_version</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ir_version</span><span class="p">,</span>
            <span class="n">as_function</span><span class="o">=</span><span class="n">as_function</span><span class="p">,</span>
            <span class="n">optimization_options</span><span class="o">=</span><span class="n">opt</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_shapable</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">_debug_shape_missing</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">g</span></div>


<div class="viewcode-block" id="GraphBuilder.make_key">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.make_key">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="o">...</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds a key identifying a value.</span>
<span class="sd">        Returns None if it is not possible.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">TensorProto</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">uses_external_data</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="n">key</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">external_data</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">info</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;location&quot;</span><span class="p">:</span>
                        <span class="n">key</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">value</span>
                        <span class="k">break</span>
                <span class="k">assert</span> <span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;External tensor </span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> has no location, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;external_data is </span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">external_data</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_key</span><span class="p">(</span><span class="n">onh</span><span class="o">.</span><span class="n">to_array</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">int64</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_key</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">SMALL_TENSOR</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))</span>
        <span class="k">return</span> <span class="kc">None</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">pretty_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensor</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tensor</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;no pretty: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

<div class="viewcode-block" id="GraphBuilder.pretty_node">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.pretty_node">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pretty_node</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">NodeProto</span><span class="p">],</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span>
        <span class="n">short</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pretty rendering for a node.</span>

<span class="sd">        :param node: node to render</span>
<span class="sd">        :param limit: to show type and shapes after the limit</span>
<span class="sd">        :param short: do not display shape information on the left</span>
<span class="sd">        :param shape: show shape information below</span>
<span class="sd">        :return: string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;None&quot;</span>
        <span class="k">if</span> <span class="n">shape</span><span class="p">:</span>
            <span class="n">st</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">:</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;-&quot;</span>
                <span class="n">sh</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;x&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">else</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;rk=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;?&quot;</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">st</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">dt</span><span class="si">}</span><span class="s2">|</span><span class="si">{</span><span class="n">sh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">st</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-&gt;&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;-&quot;</span>
                <span class="n">sh</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;x&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">else</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;rk=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;?&quot;</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">st</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">dt</span><span class="si">}</span><span class="s2">|</span><span class="si">{</span><span class="n">sh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">shape_info</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shape_info</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;Shape&quot;</span><span class="p">,</span> <span class="s2">&quot;Reshape&quot;</span><span class="p">,</span> <span class="s2">&quot;Unsqueeze&quot;</span><span class="p">,</span> <span class="s2">&quot;Squeeze&quot;</span><span class="p">,</span> <span class="s2">&quot;Cast&quot;</span><span class="p">,</span> <span class="s2">&quot;Transpose&quot;</span><span class="p">}:</span>
            <span class="n">atts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">INT</span><span class="p">:</span>
                    <span class="n">atts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">:</span>
                    <span class="n">atts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">INTS</span><span class="p">:</span>
                    <span class="n">atts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">ints</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">suffix</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">cst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_constant</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">exc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cst</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cst</span><span class="p">,</span> <span class="n">NodeProto</span><span class="p">):</span>
                        <span class="n">suffix</span> <span class="o">=</span> <span class="s2">&quot;, NodeProto&quot;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">suffix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;, </span><span class="si">{</span><span class="n">string_type</span><span class="p">(</span><span class="n">cst</span><span class="p">,</span><span class="w"> </span><span class="n">with_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">satts</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">atts</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">satts</span><span class="p">:</span>
                <span class="n">satts</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;, </span><span class="si">{</span><span class="n">satts</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">text</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">}</span><span class="s2">(.</span><span class="si">{</span><span class="n">suffix</span><span class="si">}{</span><span class="n">satts</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">)</span><span class="si">}</span><span class="s2"> -&gt; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="si">}</span><span class="s2">]: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">)</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">domain</span>
                <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">)</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">shape_info</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">text</span><span class="si">}</span><span class="s2"> ## </span><span class="si">{</span><span class="n">shape_info</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">short</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">text</span>
        <span class="n">add</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="mi">80</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
        <span class="n">text</span> <span class="o">+=</span> <span class="n">add</span>
        <span class="n">info</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;T</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot; x &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">o</span><span class="p">)))</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
            <span class="n">info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;: &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">text</span><span class="si">}</span><span class="s2">|</span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">info</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">s</span><span class="si">}{</span><span class="s1">&#39; &#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">110</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="si">}</span><span class="s2">- </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">text</span><span class="si">}</span><span class="s2">|</span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">info</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span></div>


<div class="viewcode-block" id="GraphBuilder.pretty_text">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.pretty_text">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pretty_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">add_fx_graph</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">recursive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pretty rendering of the graph.</span>

<span class="sd">        :param add_fx_graph: add the fx Graph to the rendering</span>
<span class="sd">        :param recursive: dig into subgraphs (not implemented yet)</span>
<span class="sd">        :return: string</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_d</span><span class="p">(</span><span class="n">d1</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">):</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;SymInt(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_torch_sym_int_to_str</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymBool</span><span class="p">):</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;SymBool(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_torch_sym_int_to_str</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">WrapDim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">WrapSym</span><span class="p">)):</span>
                <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">export</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">_DerivedDim</span><span class="p">):</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;_DerivedDim(</span><span class="si">{</span><span class="n">d1</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">export</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">_Dim</span><span class="p">):</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;_Dim(</span><span class="si">{</span><span class="n">d1</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_d</span><span class="p">,</span> <span class="n">d1</span><span class="p">))</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">]&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_d</span><span class="p">,</span> <span class="n">d1</span><span class="p">))</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">_d</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">d1</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">{{</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">d1</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="n">d1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;None&quot;</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected type for </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_v</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">):</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="s2">&quot; x &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;A&quot;</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;T&quot;</span>
                <span class="n">d</span> <span class="o">=</span> <span class="s2">&quot;G&quot;</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;is_cuda&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">is_cuda</span> <span class="k">else</span> <span class="s2">&quot;C&quot;</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">d</span><span class="si">}{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">TensorProto</span><span class="p">):</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">data_type</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;CP&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="s2">&quot;?&quot;</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;?&quot;</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">dtype</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_io</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
            <span class="n">text</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">o</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">add</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="mi">80</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="n">add</span>
            <span class="n">t</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;T</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot; x &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">o</span><span class="p">)))</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">text</span><span class="si">}</span><span class="s2">|</span><span class="si">{</span><span class="s1">&#39;: &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">t</span><span class="p">,</span><span class="n">s</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>
        <span class="c1"># signature</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">signature</span><span class="p">:</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">string_signature</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">signature</span><span class="p">))</span>
        <span class="c1"># dynamic shapes</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">assert_sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dyn---: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">_d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">assert_sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects_rev</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dynrev: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">_d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">assert_sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dynsrc: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">_d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">assert_sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_alias</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dynals: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">_d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">assert_sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                    <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;d-dynshp: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">_d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="p">):</span>
                    <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;t-dynshp: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">_d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># the rest</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;opset: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">source</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;init: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">_v</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">t</span><span class="si">}{</span><span class="s1">&#39; &#39;</span><span class="o">*</span><span class="nb">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">70</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="si">}</span><span class="s2"> -- </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">source</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;init: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">_v</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span>
                <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">source</span>
            <span class="p">):</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;init-source: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_names</span><span class="p">:</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_io</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;input:&quot;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">short</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">:</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_io</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;output:&quot;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FUNCKEY: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FUNC </span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="n">domain</span><span class="si">}</span><span class="s2">]: </span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="n">input</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="n">output</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">opset_import</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span> <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span> <span class="k">else</span> <span class="s2">&quot;&#39;&#39;&quot;</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  opset: </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">op</span><span class="o">.</span><span class="n">version</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">node</span><span class="p">:</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">short</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions_builder</span><span class="p">:</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">functions_builder</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">pretty_text</span><span class="p">(</span>
                        <span class="n">add_fx_graph</span><span class="o">=</span><span class="n">add_fx_graph</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span>
                    <span class="p">)</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">add_fx_graph</span><span class="p">:</span>
            <span class="n">fx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_msg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;process.graph_module.graph&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fx</span><span class="p">:</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-- FX.GRAPH-- &quot;</span><span class="p">)</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">fx</span><span class="p">))</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;--&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">fx</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;val&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2">:[</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2">:[</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="si">}</span><span class="s2">] - list&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2">:[</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="si">}</span><span class="s2">] - </span><span class="si">{</span><span class="n">val</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2">:[</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="si">}</span><span class="s2">] - </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">main_opset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Returns the opset for the main domain (assuming it is used).&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>

<div class="viewcode-block" id="GraphBuilder.get_opset">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.get_opset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_opset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domain</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">exc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the opset version for a specific domain.</span>

<span class="sd">        :param domain: domain name</span>
<span class="sd">        :param exc: raise an exception if missing</span>
<span class="sd">        :return: version</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">exc</span> <span class="ow">or</span> <span class="n">domain</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Domain </span><span class="si">{</span><span class="n">domain</span><span class="si">!r}</span><span class="s2"> is not registered</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="GraphBuilder.add_domain">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.add_domain">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domain</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">version</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a domain to the list of supported ones.</span>
<span class="sd">        Checks the version is the same if it exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">domain</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">version</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">[</span><span class="n">domain</span><span class="p">],</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Version mismatch for domain=</span><span class="si">{</span><span class="n">domain</span><span class="si">!r}</span><span class="s2">, current is &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">[</span><span class="n">domain</span><span class="p">]</span><span class="si">}</span><span class="s2">, new is </span><span class="si">{</span><span class="n">version</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">[</span><span class="n">domain</span><span class="p">]</span> <span class="o">=</span> <span class="n">version</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">make_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_tensor_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proto</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NodeProto</span><span class="p">,</span> <span class="n">TensorProto</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">STATIC_SHAPE</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="n">TensorProto</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">proto</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="n">NodeProto</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">proto</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unexpected attribute type for attribute </span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;attribute list is </span><span class="si">{</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">proto</span><span class="o">.</span><span class="n">attribute</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;in node type </span><span class="si">{</span><span class="n">proto</span><span class="o">.</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">, name=</span><span class="si">{</span><span class="n">proto</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;doc_string=</span><span class="si">{</span><span class="n">proto</span><span class="o">.</span><span class="n">doc_string</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;value_float&quot;</span><span class="p">,</span> <span class="s2">&quot;value_int&quot;</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">tuple</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;value_floats&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">floats</span><span class="p">),)</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;value_ints&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">ints</span><span class="p">),)</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unexpected or unsupported scenario type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">proto</span><span class="p">)</span><span class="si">}</span><span class="s2">: &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">proto</span><span class="si">}</span><span class="s2">, attribute=</span><span class="si">{</span><span class="n">proto</span><span class="o">.</span><span class="n">attribute</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_tensor_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proto</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NodeProto</span><span class="p">,</span> <span class="n">TensorProto</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="n">TensorProto</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">proto</span><span class="o">.</span><span class="n">data_type</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="n">NodeProto</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">proto</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;value_float&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;value_int&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">TensorProto</span><span class="o">.</span><span class="n">INT64</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;value_floats&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;value_ints&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">TensorProto</span><span class="o">.</span><span class="n">INT64</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">att</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">data_type</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected type or value </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">proto</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">proto</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="GraphBuilder.is_constant">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.is_constant">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tells if a result is a constant.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants_</span></div>


<div class="viewcode-block" id="GraphBuilder.compute_constant">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.compute_constant">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_constant</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">exc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">only_array</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">allow_empty</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a constant.</span>

<span class="sd">        :param name: constant name</span>
<span class="sd">        :param exc: raises an exception if any failure</span>
<span class="sd">        :param only_array: do not return TensorProto</span>
<span class="sd">        :param allow_empty: allow empty result</span>
<span class="sd">        :return: constant</span>

<span class="sd">        If returns None if the constant is a FakeTensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Name </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> is not a constant&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2"> for name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="n">only_array</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">TensorProto</span><span class="p">):</span>
                <span class="c1"># Should reuse memory buffer here.</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">onh</span><span class="o">.</span><span class="n">to_array</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="n">src</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;&quot;</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span>
                    <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">source</span>
                    <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;##</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">source</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="n">src</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;GraphBuilder.compute_constant/from&quot;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span>
                <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected source=</span><span class="si">{</span><span class="n">src</span><span class="si">!r}</span><span class="s2"> for initializer </span><span class="si">{</span><span class="n">name</span><span class="si">!r}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">add_initializer</span><span class="p">(</span>
                    <span class="n">name</span><span class="p">,</span>
                    <span class="n">v</span><span class="p">,</span>
                    <span class="n">existing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">allow_empty</span><span class="o">=</span><span class="n">allow_empty</span><span class="p">,</span>
                    <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;GraphBuilder.compute_constant/from(</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">)</span><span class="si">{</span><span class="n">src</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">v</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">_subclasses</span><span class="o">.</span><span class="n">fake_tensor</span><span class="o">.</span><span class="n">FakeTensor</span><span class="p">):</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_constant_folding</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unable to compute constant because value is a FakeTensor&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">string_type</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">with_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;in node </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_node</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">value</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">_InferenceRuntime</span><span class="o">.</span><span class="n">compute_constant</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">exc</span><span class="o">=</span><span class="n">exc</span><span class="p">,</span> <span class="n">only_array</span><span class="o">=</span><span class="n">only_array</span><span class="p">,</span> <span class="n">allow_empty</span><span class="o">=</span><span class="n">allow_empty</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="GraphBuilder.get_constant">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.get_constant">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_constant</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">exc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">computed_value</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">as_shape</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">multiple_outputs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">NodeProto</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The method returns the constant *name*. It is a tensor (numpy array)</span>
<span class="sd">        or a NodeProto which must be evaluated.</span>
<span class="sd">        If *computed_value* is True, the NodeProto is evaluated with the</span>
<span class="sd">        ReferenceEvaluator.</span>

<span class="sd">        :param name: constant name</span>
<span class="sd">        :param exc: raise an exception if anything is impossible to do</span>
<span class="sd">        :param computed_value: compute the value if not a constant</span>
<span class="sd">        :param as_shape: returns a tuple for a shape</span>
<span class="sd">        :param multiple_outputs: allow multiple outputs</span>
<span class="sd">        :return: value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_get_constant</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.get_constant] name=</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;computed_value=</span><span class="si">{</span><span class="n">computed_value</span><span class="si">}</span><span class="s2">, as_shape=</span><span class="si">{</span><span class="n">as_shape</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;exc=</span><span class="si">{</span><span class="n">exc</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">as_shape</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">multiple_outputs</span><span class="p">,</span> <span class="s2">&quot;multiple outputs not allowed with as_shape=True&quot;</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_constant</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">computed_value</span><span class="o">=</span><span class="n">computed_value</span><span class="p">,</span> <span class="n">as_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">exc</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;No constant for name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, exc=</span><span class="si">{</span><span class="n">exc</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;computed_value=</span><span class="si">{</span><span class="n">computed_value</span><span class="si">}</span><span class="s2">, as_shape=</span><span class="si">{</span><span class="n">as_shape</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;multiple_outputs=</span><span class="si">{</span><span class="n">multiple_outputs</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_get_constant</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.get_constant]   A: None, name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">assert</span> <span class="n">multiple_outputs</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">res</span><span class="p">,</span> <span class="nb">tuple</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Multiple output is not allowed but type is </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="si">}</span><span class="s2"> for name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="n">new_res</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">maybe_disable_fake_tensor_mode</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                    <span class="n">new_res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_get_constant</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.get_constant]   SHAPE: </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">new_res</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_res</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">exc</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">:</span>  <span class="c1"># subgraphs not fully working</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Result </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> is not a constant</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_get_constant</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.get_constant]   C: None, name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">possible_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants_</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants_computed_</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants_computed_</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Constant is empty for name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="k">assert</span> <span class="n">multiple_outputs</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Multiple output is not allowed but type is </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2"> for name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_get_constant</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.get_constant]   D: value: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">, name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="n">exc</span> <span class="ow">or</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unable to compute value </span><span class="si">{</span><span class="n">name</span><span class="si">!r}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="k">if</span> <span class="n">possible_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">possible_value</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">NodeProto</span><span class="p">)</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">possible_value</span><span class="p">)</span><span class="si">}</span><span class="s2"> for a constant</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="n">computed_value</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">possible_value</span><span class="p">,</span> <span class="n">NodeProto</span><span class="p">):</span>
                <span class="n">res</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_constant</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">exc</span><span class="o">=</span><span class="n">exc</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># The constant is too big to be computed.</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_get_constant</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.get_constant]   E: None, name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                    <span class="k">return</span> <span class="kc">None</span>

                <span class="k">assert</span> <span class="n">multiple_outputs</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">),</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Multiple output is not allowed but type is </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;for name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="ow">not</span> <span class="n">multiple_outputs</span>
                <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;get_constants not implemented when multiple_outputs=True, name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_get_constant</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.get_constant]   &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;F: tuple, name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                    <span class="k">return</span> <span class="n">res</span>

                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">),</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Expecting multiple outputs for name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;op_type=</span><span class="si">{</span><span class="n">possible_value</span><span class="o">.</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">multiple_outputs</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">),</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Multiple output is not allowed but type is </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;for name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_get_constant</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.get_constant]   &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;G: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2">, name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                    <span class="k">assert</span> <span class="p">(</span>
                        <span class="ow">not</span> <span class="n">exc</span> <span class="ow">or</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unable to compute value </span><span class="si">{</span><span class="n">name</span><span class="si">!r}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">possible_value</span><span class="o">.</span><span class="n">output</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="k">assert</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Constant is empty for name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="k">assert</span> <span class="n">multiple_outputs</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">),</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Multiple output is not allowed but type is </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;for name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_get_constant</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.get_constant]   &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;H: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">, name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="ow">not</span> <span class="n">exc</span> <span class="ow">or</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unable to compute value </span><span class="si">{</span><span class="n">name</span><span class="si">!r}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">return</span> <span class="n">value</span>

            <span class="k">assert</span> <span class="n">possible_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Constant is empty for name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="k">assert</span> <span class="n">multiple_outputs</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">possible_value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Multiple output is not allowed but type is </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">possible_value</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;for name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_get_constant</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.get_constant]   &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;I: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">possible_value</span><span class="p">)</span><span class="si">}</span><span class="s2">, name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="n">exc</span> <span class="ow">or</span> <span class="n">possible_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unable to compute value </span><span class="si">{</span><span class="n">name</span><span class="si">!r}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">return</span> <span class="n">possible_value</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># So it should be stored in a parent.</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_constant_from_parent</span><span class="p">(</span>
                <span class="n">name</span><span class="p">,</span>
                <span class="n">exc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">computed_value</span><span class="o">=</span><span class="n">computed_value</span><span class="p">,</span>
                <span class="n">as_shape</span><span class="o">=</span><span class="n">as_shape</span><span class="p">,</span>
                <span class="n">multiple_outputs</span><span class="o">=</span><span class="n">multiple_outputs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Result </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> was never evaluated within method &#39;constant_folding&#39;, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;known initializers=</span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">)</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_get_constant</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.get_constant]   J: None, name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">value</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_get_constant</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.get_constant] &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;  K: np.ndarray </span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.get_constant] &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;  K: np.ndarray </span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">maybe_disable_fake_tensor_mode</span><span class="p">():</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">constants_computed_</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">multiple_outputs</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Multiple output is not allowed for name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_get_constant</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.get_constant] &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  L: nptorch.Tensor </span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">v</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">TensorProto</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">uses_external_data</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Tensor is using external data, data_type=</span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">data_type</span><span class="si">}</span><span class="s2">, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;dims=</span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">dims</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_get_constant</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[GraphBuilder.get_constant]   M: None&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">onh</span><span class="o">.</span><span class="n">to_array</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">multiple_outputs</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Multiple output is not allowed for name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constants_computed_</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_get_constant</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[GraphBuilder.get_constant]   O: TensorProto&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">v</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
            <span class="c1"># This should not be needed.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_get_constant</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.get_constant]   P: np.float32 </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to convert type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2"> into numpy array.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="GraphBuilder.get_constant_from_parent">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.get_constant_from_parent">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_constant_from_parent</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">exc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">computed_value</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">as_shape</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">multiple_outputs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">NodeProto</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tells if this name is part of the previous context.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="n">exc</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;No parent found, unable to retrieve constant name </span><span class="si">{</span><span class="n">name</span><span class="si">!r}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">get_constant</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">exc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">computed_value</span><span class="o">=</span><span class="n">computed_value</span><span class="p">,</span>
            <span class="n">as_shape</span><span class="o">=</span><span class="n">as_shape</span><span class="p">,</span>
            <span class="n">multiple_outputs</span><span class="o">=</span><span class="n">multiple_outputs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">get_constant_from_parent</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">exc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">computed_value</span><span class="o">=</span><span class="n">computed_value</span><span class="p">,</span>
            <span class="n">as_shape</span><span class="o">=</span><span class="n">as_shape</span><span class="p">,</span>
            <span class="n">multiple_outputs</span><span class="o">=</span><span class="n">multiple_outputs</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="GraphBuilder.is_constant_part_of_previous_context">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.is_constant_part_of_previous_context">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_constant_part_of_previous_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tells if this name is part of the previous context and a constant as well.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">is_constant_part_of_previous_context</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="GraphBuilder.is_sequence">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.is_sequence">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tells if a result is a sequence.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_sequences</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unknown name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="GraphBuilder.get_sequence">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.get_sequence">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns sequence information&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_sequences</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Sequence </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> is not known</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_sequences</span><span class="p">[</span><span class="n">name</span><span class="p">]</span></div>


<div class="viewcode-block" id="GraphBuilder.set_sequence">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.set_sequence">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_sequence</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span>
        <span class="n">shapes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">DYNAMIC_SHAPE</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ranks</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unknown</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Defines a result as a sequence.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_debug_stop_sequence</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_stop_type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Requested stop, sequence name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, dtype=</span><span class="si">{</span><span class="n">dtype</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;No result name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Only one type is allowed in onnx sequences but dtype=</span><span class="si">{</span><span class="n">dtype</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;the interpret allows multiple types for simplicity&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_known_sequences</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">shapes</span><span class="o">=</span><span class="n">shapes</span><span class="p">,</span> <span class="n">ranks</span><span class="o">=</span><span class="n">ranks</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">shapes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ranks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;ranks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_sequences</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_known_sequences</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_sequences</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="n">new_value</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="s2">&quot;shapes&quot;</span><span class="p">,</span> <span class="s2">&quot;ranks&quot;</span><span class="p">]:</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="n">old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">new_value</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">new_value</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
                    <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">new_value</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="n">n</span> <span class="o">==</span> <span class="n">e</span><span class="p">,</span> <span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Sequence </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> was already declared with a different value &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;for k=</span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2">, existing=</span><span class="si">{</span><span class="n">e</span><span class="si">!r}</span><span class="s2">, new=</span><span class="si">{</span><span class="n">n</span><span class="si">!r}</span><span class="s2">, declared=</span><span class="si">{</span><span class="n">old</span><span class="si">}</span><span class="s2">, &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;new=</span><span class="si">{</span><span class="n">d</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_known_sequences</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_value</span></div>


<div class="viewcode-block" id="GraphBuilder.set_name">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.set_name">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">marker</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds a name to the list of known names.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Empty name </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> cannot be registered, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;marker=</span><span class="si">{</span><span class="n">marker</span><span class="si">!r}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">strip</span><span class="p">()),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;No space should be added at the extremities of the name </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raise_list</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Name </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> is one of the name declared in &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;the stop list, marker=</span><span class="si">{</span><span class="n">marker</span><span class="si">!r}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2"> for name, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;marker=</span><span class="si">{</span><span class="n">marker</span><span class="si">!r}</span><span class="s2">, existing marker=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;set_name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_names</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Name </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> already exists, marker=</span><span class="si">{</span><span class="n">marker</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;existing marker is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;set_name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_known_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unique_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;set_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">marker</span></div>


<div class="viewcode-block" id="GraphBuilder.set_rank">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.set_rank">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_rank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the rank for a result.</span>

<span class="sd">        :param name: result name</span>
<span class="sd">        :param value: rank</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_stop</span> <span class="ow">or</span> <span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_stop_shape</span><span class="p">:</span>
            <span class="c1"># Set ONNXSTOP or ONNXSTOPSHAPE to stop here.</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Requested stop, name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, rank=</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected rank type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected rank type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2"> for name.&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_ranks</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">value</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_ranks</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Inconsistent ranks for </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, previous value is &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_known_ranks</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="si">}</span><span class="s2">, new value is </span><span class="si">{</span><span class="n">value</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.set_rank] (again) </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_known_ranks</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.set_rank] </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">is_more_precise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">STATIC_SHAPE</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="n">STATIC_SHAPE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">base</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Cannot compare shapes with different ranks </span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">base</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="GraphBuilder.get_is_dimension">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.get_is_dimension">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_is_dimension</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">elem_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">STATIC_SHAPE</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n_outputs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">exc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tells if a result is a dynamic dimension or not.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_torch_value</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_torch_value</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;run_node&quot;</span><span class="p">:</span>
                <span class="n">val1</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">_exa</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">val1</span>
                <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">el_type</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="k">if</span> <span class="n">el_type</span> <span class="ow">in</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">float16</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">bfloat16</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">,</span>
                    <span class="p">):</span>
                        <span class="k">return</span> <span class="kc">False</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>
                    <span class="k">if</span> <span class="n">el_type</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># A single integer with no shape, it looks like a dimension.</span>
                        <span class="c1"># Let&#39;s assume it is. It is more efficient to consider it as</span>
                        <span class="c1"># a dimension.</span>
                        <span class="k">return</span> <span class="kc">True</span>
                    <span class="c1"># In another case, let&#39;s assume it is not.</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">elem_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">elem_type</span> <span class="ow">in</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">float16</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">bfloat16</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">,</span>
                    <span class="p">):</span>
                        <span class="k">return</span> <span class="kc">False</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">):</span>
                        <span class="k">return</span> <span class="kc">False</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="p">{</span>
                        <span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT16</span><span class="p">,</span>
                        <span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span>
                        <span class="n">TensorProto</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">,</span>
                        <span class="n">TensorProto</span><span class="o">.</span><span class="n">BFLOAT16</span><span class="p">,</span>
                        <span class="n">TensorProto</span><span class="o">.</span><span class="n">BOOL</span><span class="p">,</span>
                    <span class="p">}:</span>
                        <span class="k">return</span> <span class="kc">False</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">TensorProto</span><span class="o">.</span><span class="n">INT64</span> <span class="ow">and</span> <span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
                            <span class="k">return</span> <span class="kc">True</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">val1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">val1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
                        <span class="ow">and</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;example_value&quot;</span>
                        <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="p">):</span>
                        <span class="c1"># No dynamic shape as input, so there</span>
                        <span class="c1"># shoud not be any dynamic shape as output.</span>
                        <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">val1</span> <span class="o">==</span> <span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
                    <span class="c1"># Another case where it seems False.</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Not implemented for name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, value=</span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2"> (</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">), &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;val1=</span><span class="si">{</span><span class="n">val1</span><span class="si">}</span><span class="s2">, elem_type=</span><span class="si">{</span><span class="n">elem_type</span><span class="si">}</span><span class="s2">, shape=</span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">, n_outputs=</span><span class="si">{</span><span class="n">n_outputs</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;call_module&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">el_type</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">el_type</span> <span class="ow">in</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">float16</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">bfloat16</span><span class="p">,</span>
                    <span class="p">):</span>
                        <span class="k">return</span> <span class="kc">False</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># We may assume a model would not output just one dimension.</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Not implemented for name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, value=</span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2"> (</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">), &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;elem_type=</span><span class="si">{</span><span class="n">elem_type</span><span class="si">}</span><span class="s2">, shape=</span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">, n_outputs=</span><span class="si">{</span><span class="n">n_outputs</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;_INT_&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
            <span class="c1"># This is most likely a dimension but not marked as such for the time being.</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">elem_type</span> <span class="ow">in</span> <span class="p">{</span>
                <span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT16</span><span class="p">,</span>
                <span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span>
                <span class="n">TensorProto</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">,</span>
                <span class="n">TensorProto</span><span class="o">.</span><span class="n">BFLOAT16</span><span class="p">,</span>
                <span class="n">TensorProto</span><span class="o">.</span><span class="n">BOOL</span><span class="p">,</span>
            <span class="p">}:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">exc</span><span class="p">:</span>
                <span class="c1"># We return false by default.</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unable to guess if </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, elem_type=</span><span class="si">{</span><span class="n">elem_type</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;shape=</span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2"> is a dimension</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">res</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="p">(</span>
                <span class="n">elem_type</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="ow">or</span> <span class="n">elem_type</span>
                <span class="ow">in</span> <span class="p">{</span>
                    <span class="n">TensorProto</span><span class="o">.</span><span class="n">INT64</span><span class="p">,</span>
                    <span class="n">TensorProto</span><span class="o">.</span><span class="n">INT32</span><span class="p">,</span>
                    <span class="n">TensorProto</span><span class="o">.</span><span class="n">UINT64</span><span class="p">,</span>
                    <span class="n">TensorProto</span><span class="o">.</span><span class="n">UINT32</span><span class="p">,</span>
                    <span class="c1"># not a dimension but a result of a computation involving a dimension</span>
                    <span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">)</span>
            <span class="ow">and</span> <span class="p">(</span><span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
        <span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Inconsistent result type for name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, is_dimension=</span><span class="si">{</span><span class="n">res</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;elem_type=</span><span class="si">{</span><span class="n">elem_type</span><span class="si">}</span><span class="s2">, shape=</span><span class="si">{</span><span class="n">shape</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="GraphBuilder.reset_types_and_shapes">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.reset_types_and_shapes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reset_types_and_shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes shapes, and types if not an initializer.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_types</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_device</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_devices</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_shapes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_ranks</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="p">[</span><span class="n">k</span><span class="p">]</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">set_shapes_types</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;torch.fx.Node&quot;</span><span class="p">],</span>  <span class="c1"># noqa: F821</span>
        <span class="n">where</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_known_torch_value</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_torch_sym_int_to_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;torch.SymInt&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>  <span class="c1">#  noqa: F821</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;node&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">torch.fx.experimental.sym_node</span><span class="w"> </span><span class="kn">import</span> <span class="n">SymNode</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;node&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="n">SymNode</span><span class="p">):</span>
            <span class="c1"># &#39;_expr&#39; is safer than expr</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">_expr</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">val_int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">val_int</span>
        <span class="k">except</span> <span class="p">(</span>
            <span class="ne">TypeError</span><span class="p">,</span>
            <span class="ne">ValueError</span><span class="p">,</span>
            <span class="ne">AttributeError</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">symbolic_shapes</span><span class="o">.</span><span class="n">GuardOnDataDependentSymNode</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">pass</span>

        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to convert </span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2"> into string&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_two_shapes_are_compatible</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">old_shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
        <span class="n">shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
        <span class="n">register_int</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Raises an exception if two shapes are not compatible.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">old_shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Rank mismatch between previous shape </span><span class="si">{</span><span class="n">old_shape</span><span class="si">}</span><span class="s2"> and &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;new shape </span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2"> (name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">)</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_dyn_dim</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sshape</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">sshape</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">old_shape</span><span class="p">)</span> <span class="o">|</span> <span class="n">sshape</span><span class="p">)</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_dyn_dim</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._check_two_shapes_are_compatible] &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;old_shape=</span><span class="si">{</span><span class="n">old_shape</span><span class="si">}</span><span class="s2">, shape=</span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">, register_int=</span><span class="si">{</span><span class="n">register_int</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">for</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">old_shape</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d2</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">d1</span> <span class="o">==</span> <span class="n">d2</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Shape </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> already exists and one dimension &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;is not compatible existing </span><span class="si">{</span><span class="n">old_shape</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(new) </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">d1_</span><span class="p">,</span> <span class="n">d2_</span> <span class="o">=</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">):</span>
                <span class="n">d1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_torch_sym_int_to_str</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">export</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">_Dim</span><span class="p">):</span>
                <span class="n">d1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_torch_sym_int_to_str</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">):</span>
                <span class="n">d2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_torch_sym_int_to_str</span><span class="p">(</span><span class="n">d2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">export</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">_Dim</span><span class="p">):</span>
                <span class="n">d2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_torch_sym_int_to_str</span><span class="p">(</span><span class="n">d2</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d2</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">d1</span> <span class="o">==</span> <span class="n">d2</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d2</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">register_constraint_dimension</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">register_constraint_dimension</span><span class="p">(</span><span class="n">d2</span><span class="p">,</span> <span class="n">d1</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Shape </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> already exists &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;and it is not compatible &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;existing </span><span class="si">{</span><span class="n">old_shape</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2"> (new) &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;d1=</span><span class="si">{</span><span class="n">d1_</span><span class="si">!r}</span><span class="s2">, d2=</span><span class="si">{</span><span class="n">d2_</span><span class="si">!r}</span><span class="s2">, dim types=&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">d1_</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">d2_</span><span class="p">)</span><span class="si">}</span><span class="s2">), &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;d1=</span><span class="si">{</span><span class="n">d1</span><span class="si">!r}</span><span class="s2">, d2=</span><span class="si">{</span><span class="n">d2</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

<div class="viewcode-block" id="GraphBuilder.register_dynamic_objects_from_shape">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.register_dynamic_objects_from_shape">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">register_dynamic_objects_from_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">DYNAMIC_SHAPE</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Registers all the dynamic objects required in this shape.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">register_dynamic_objects_from_dim</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span></div>


<div class="viewcode-block" id="GraphBuilder.register_dynamic_objects_from_dim">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.register_dynamic_objects_from_dim">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">register_dynamic_objects_from_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Registers all the dynamic objects required in a dimension.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">WrapDim</span><span class="p">):</span>
            <span class="n">token</span> <span class="o">=</span> <span class="n">dim</span><span class="o">.</span><span class="n">name</span>
            <span class="k">if</span> <span class="n">token</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_dynamic_object</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_dynamic_object</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot; &quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dim</span> <span class="ow">and</span> <span class="n">dim</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;(&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">dim</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;)&quot;</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;type(dim)=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span><span class="si">}</span><span class="s2"> must be a str and should not contain &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;a comma or a space dim=</span><span class="si">{</span><span class="n">dim</span><span class="si">!r}</span><span class="s2"> and the same number of opened and closed &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;brackets</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">parse_expression_tokens</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">token</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_dynamic_object</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_dynamic_object</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span></div>


<div class="viewcode-block" id="GraphBuilder.set_shape">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.set_shape">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_shape</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">:</span> <span class="n">DYNAMIC_SHAPE</span><span class="p">,</span>
        <span class="n">set_rank</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">set_if_more_precise</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">exc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">allow_zero</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the shape for a result. It is exists, it checks the new shape</span>
<span class="sd">        is equal to the existing one.</span>

<span class="sd">        :param name: result name</span>
<span class="sd">        :param shape: shape</span>
<span class="sd">        :param set_rank: set the rank as well</span>
<span class="sd">        :param set_if_more_precise: change the shape if it is more precise</span>
<span class="sd">        :param exc: raise an exception if inconsistency</span>
<span class="sd">        :param allow_zero: the shape should not have a value equal to zero</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2"> for name.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected shape type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_debug_stop</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_stop_shape</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_debug_stop</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_debug_stop_shape</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="c1"># Set ONNXSTOP or ONNXSTOPSHAPE to stop here.</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Requested stop, name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, shape=</span><span class="si">{</span><span class="n">shape</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">shape</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected shape </span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="s2">&quot;torch.Size&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected shape </span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">sdim</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sdim</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">register_dynamic_objects_from_dim</span><span class="p">(</span><span class="n">sdim</span><span class="p">)</span>
        <span class="n">shape0</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">verify_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">allow_zero</span> <span class="ow">or</span> <span class="mi">0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">shape</span> <span class="ow">or</span> <span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unexpected null shape </span><span class="si">{</span><span class="n">shape</span><span class="si">!r}</span><span class="s2"> (or </span><span class="si">{</span><span class="n">shape0</span><span class="si">!r}</span><span class="s2">) for name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;this case usually happens before a concatenation, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;allow_zero=</span><span class="si">{</span><span class="n">allow_zero</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># costly</span>
        <span class="c1"># assert all(not isinstance(t, self.torch.SymInt) for t in shape), (</span>
        <span class="c1">#     f&quot;Unexpected type for a shape, shape={shape}, types={[type(_) for _ in shape]}&quot;</span>
        <span class="c1">#     f&quot;{self.get_debug_msg()}&quot;</span>
        <span class="c1"># )</span>
        <span class="c1"># shape_int = [d for d in shape if isinstance(d, int)]</span>
        <span class="c1"># assert (</span>
        <span class="c1">#     len(shape) == 0 or not shape_int or min(shape_int) &gt;= 0</span>
        <span class="c1"># ), f&quot;Negative value in shape {shape} for {name!r}{self.get_debug_msg()}&quot;</span>
        <span class="c1"># assert (</span>
        <span class="c1">#     not self._debug_null_shape</span>
        <span class="c1">#     or len(shape) == 0</span>
        <span class="c1">#     or not shape_int</span>
        <span class="c1">#    or min(shape_int) &gt; 0</span>
        <span class="c1"># ), f&quot;Zero value in shape {shape} for {name!r}{self.get_debug_msg()}&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_shapes</span><span class="p">:</span>
            <span class="n">old_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_shapes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_dyn_dim</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_dyn_dim</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">old_shape</span><span class="p">)):</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.set_shape] set_shape(</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, </span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">), &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;old_shape=</span><span class="si">{</span><span class="n">old_shape</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">old_shape</span><span class="p">)</span> <span class="ow">and</span> <span class="n">set_if_more_precise</span><span class="p">:</span>
                <span class="n">is_more_precise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_more_precise</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">old_shape</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_more_precise</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">old_shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="ow">or</span> <span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,):</span>
                        <span class="k">if</span> <span class="s2">&quot;warnings&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_msg</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_debug_msg</span><span class="p">[</span><span class="s2">&quot;warnings&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_debug_msg</span><span class="p">[</span><span class="s2">&quot;warnings&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Name </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> already exists and it is not compatible &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;existing </span><span class="si">{</span><span class="n">old_shape</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2"> (new)&quot;</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_check_two_shapes_are_compatible</span><span class="p">(</span>
                            <span class="n">old_shape</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">register_int</span><span class="o">=</span><span class="kc">False</span>
                        <span class="p">)</span>

            <span class="k">elif</span> <span class="n">shape</span> <span class="o">!=</span> <span class="n">old_shape</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Name </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> already exists and its shape different &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">old_shape</span><span class="si">}</span><span class="s2"> (old) != </span><span class="si">{</span><span class="n">shape</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_dyn_dim</span> <span class="ow">and</span> <span class="nb">set</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_dyn_dim</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.set_shape] set_shape(</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, </span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.set_shape] </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_dynamic_object</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_known_shapes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;replacements_dimensions_&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replacements_dimensions_</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">rename_dynamic_expression</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">replacements_for_replacements_dimensions_</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                    <span class="k">else</span> <span class="n">_</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">shape</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">set_rank</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_rank</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span></div>


<div class="viewcode-block" id="GraphBuilder.set_type_shape_or_rank">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.set_type_shape_or_rank">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_type_shape_or_rank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">like</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the type and the shape of *name* like *like*.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_device</span><span class="p">(</span><span class="n">like</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_device</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">like</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">like</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">like</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">like</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_shape</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">like</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">like</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_rank</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">like</span><span class="p">))</span></div>


<div class="viewcode-block" id="GraphBuilder.set_device">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.set_device">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_device</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;torch.dtype&quot;</span><span class="p">],</span>  <span class="c1"># noqa: F821</span>
        <span class="n">exc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">keep_this_device</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the shape for a result. It is exists, it checks the new shape</span>
<span class="sd">        is equal to the existing one.</span>

<span class="sd">        :param name: name</span>
<span class="sd">        :param device: an integer or a torch device then converted into an integer</span>
<span class="sd">        :param exc: raises an exception</span>
<span class="sd">        :param keep_this_device: keeps this device anyway, this may happen if a constant</span>
<span class="sd">            is created, then the device may not be the one from the input (a shape)</span>
<span class="sd">            but the most frequent for any result tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">exc</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;not implemented when exc=</span><span class="si">{</span><span class="n">exc</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># This happens while tracing.</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">device</span><span class="si">!r}</span><span class="s2"> is not a constant</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">device</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_constant</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">computed_value</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">device</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">device</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;cpu&quot;</span> <span class="k">else</span> <span class="n">device</span><span class="o">.</span><span class="n">index</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_devices</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">keep_this_device</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">keep_this_device</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_devices</span><span class="p">[</span>
                <span class="n">name</span>
            <span class="p">]</span> <span class="o">==</span> <span class="n">device</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;device mismatch for name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_known_devices</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;new device is </span><span class="si">{</span><span class="n">device</span><span class="si">}</span><span class="s2">, is_constant=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_known_devices</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">device</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">has_device</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2"> for name.&quot;</span>
        <span class="k">return</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_devices</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_device</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2"> for name.&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_devices</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unknown device for name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_devices</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

<div class="viewcode-block" id="GraphBuilder.set_type">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.set_type">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">exc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the shape for a result. It is exists, it checks the new shape</span>
<span class="sd">        is equal to the existing one.</span>

<span class="sd">        :param name: name</span>
<span class="sd">        :param dtype: element type (an integer, ONNX), 0 (unknonw is a possible value)</span>
<span class="sd">        :param exc: raises an exception</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_debug_stop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_stop_type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Requested stop, name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, dtype=</span><span class="si">{</span><span class="n">dtype</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2"> for name.&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">int_type</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">int_type</span> <span class="o">=</span> <span class="n">_get_type</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_types</span><span class="p">:</span>
            <span class="c1"># 0 is undefined</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">int_type</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_types</span><span class="p">[</span><span class="n">name</span><span class="p">]:</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">exc</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Type for name </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> already exists and it is different, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;known is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_known_types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">int_type</span><span class="si">}</span><span class="s2"> (new) - &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(mapping=</span><span class="si">{</span><span class="n">str_tensor_proto_type</span><span class="p">()</span><span class="si">}</span><span class="s2">)</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="s2">&quot;warnings&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_msg</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_debug_msg</span><span class="p">[</span><span class="s2">&quot;warnings&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_debug_msg</span><span class="p">[</span><span class="s2">&quot;warnings&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Type for name </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> already exists and it is different, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;known is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_known_types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">int_type</span><span class="si">}</span><span class="s2"> (new) - &quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Type for name </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> already exists and it is different, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;known is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_known_types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">int_type</span><span class="si">}</span><span class="s2"> (new) - &quot;</span>
                    <span class="p">)</span>
                <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.set_type] </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">int_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_known_types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">int_type</span></div>


<div class="viewcode-block" id="GraphBuilder.rank">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.rank">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shortcut to :meth:`get_rank`.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2"> for name.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="GraphBuilder.has_name">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.has_name">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tells if a result exists.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span> <span class="nb">str</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2"> for name (name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">)</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_names</span></div>


<div class="viewcode-block" id="GraphBuilder.has_rank">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.has_rank">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_rank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tells if a result has a rank.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2"> for name.&quot;</span>
        <span class="k">return</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_ranks</span></div>


<div class="viewcode-block" id="GraphBuilder.has_shape">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.has_shape">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tells if a result has a shape.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2"> for name.&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_shapes</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">full</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_shapes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">is_static_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">min</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="GraphBuilder.has_type">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.has_type">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tells if a result has a type. This should be always true.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2"> for name.&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_types</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># If the type is undefined, then it has no type.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span></div>


<div class="viewcode-block" id="GraphBuilder.get_rank">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.get_rank">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_rank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the rank of a result.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2"> for name.&quot;</span>
        <span class="k">assert</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_ranks</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;rank is unknown for result </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, has_shape=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;has_rank=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;known_ranks=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_known_ranks</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_ranks</span><span class="p">[</span><span class="n">name</span><span class="p">]</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_shape_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="s2">&quot;Use to debug.&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="s2">&quot;?&quot;</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">name</span><span class="p">))])</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">:?&quot;</span>

<div class="viewcode-block" id="GraphBuilder.get_shape">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.get_shape">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DYNAMIC_SHAPE</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the shape of a result.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2"> for name.&quot;</span>
        <span class="k">assert</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_shapes</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Shape is unknown for result </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;known_shapes=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_known_shapes</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_shapes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span></div>


<div class="viewcode-block" id="GraphBuilder.get_type_known">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.get_type_known">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_type_known</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">exc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the type known by torch to help solve mismatches.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_torch_value</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_torch_value</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="c1"># something like (</span>
            <span class="c1">#                   &#39;run_node&#39;,</span>
            <span class="c1">#                   (</span>
            <span class="c1">#                       &#39;&#39;,</span>
            <span class="c1">#                       (&#39;val&#39;, torch.float16, torch.Size([2, 12, 2048, 2048]))</span>
            <span class="c1">#                   )</span>
            <span class="c1">#                )</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">exc</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">3</span>
            <span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unexpected output value </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;No information provided by torch&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">3</span>
            <span class="p">):</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">itype</span> <span class="o">=</span> <span class="n">torch_dtype_to_onnx_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">itype</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="GraphBuilder.get_type">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.get_type">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the type of a result.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2"> for name.&quot;</span>
        <span class="k">assert</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_types</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Type is unknown for result </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;known_types=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_known_types</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_dims_equal_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="n">done</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="p">{</span><span class="n">d</span><span class="p">}</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">nds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">done</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">done</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraints_</span><span class="p">:</span>
                    <span class="n">nds</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraints_</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">ds</span> <span class="o">|=</span> <span class="n">nds</span>
        <span class="k">return</span> <span class="n">ds</span>

<div class="viewcode-block" id="GraphBuilder.same_dimension">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.same_dimension">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">same_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks if the dimensions are the same. Looks into constraints as well.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dims_equal_set</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims_equal_set</span><span class="p">(</span><span class="n">b</span><span class="p">))</span></div>


<div class="viewcode-block" id="GraphBuilder.same_shape">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.same_shape">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">same_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks if the shapes are the same. Looks into constraints as well.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;missing shape for </span><span class="si">{</span><span class="n">x</span><span class="si">!r}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;missing shape for </span><span class="si">{</span><span class="n">y</span><span class="si">!r}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">shape1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">shape2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shape1</span> <span class="o">==</span> <span class="n">shape2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape2</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">same_dimension</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">shape1</span><span class="p">,</span> <span class="n">shape2</span><span class="p">))</span></div>


<div class="viewcode-block" id="GraphBuilder.value_as_shape">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.value_as_shape">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">value_as_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the value of a result if it is a shape.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="n">TensorProto</span><span class="o">.</span><span class="n">INT64</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># It is probably a shape because the user requested it as a shape.</span>
            <span class="n">cst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_constant</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">exc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">computed_value</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cst</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">cst</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">cst</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">cst</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">return</span> <span class="n">value</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="GraphBuilder.set_value_shape">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.set_value_shape">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_value_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">equal_to</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the value for a shape result.</span>

<span class="sd">        :param name: name</span>
<span class="sd">        :param value: it cannot be empty</span>
<span class="sd">        :param equal_to: if specified, the value is also equal to this value</span>

<span class="sd">        A value can be a string (for an unknown shape, a tuple for a shape,</span>
<span class="sd">        an integer for a single scalar.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_value_shape</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_value_shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Requested stop, name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, value=</span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2">, equal_to=</span><span class="si">{</span><span class="n">equal_to</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span> <span class="nb">str</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2"> for name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">value</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unexpected value for shape </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, value=</span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;types=</span><span class="si">{</span><span class="n">string_type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_shape</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">),)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">())</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, has no rank, but it should, value=</span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2048</span>
        <span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> is not a shape, its rank is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;shape=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;?&#39;</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;value=</span><span class="si">{</span><span class="n">string_type</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">with_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Mismatch between value=</span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2"> and rank=&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2"> for name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">equal_to</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="p">:</span>
                <span class="n">existing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">existing</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">existing</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                    <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">existing</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">register_constraint_dimension</span><span class="p">(</span><span class="s2">&quot;existing&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                    <span class="k">return</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span>
            <span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Shape value for </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> (value=</span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2">) is already &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;registered and is different from the existing &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;value which is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kc">None</span><span class="p">)</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(equal_to=</span><span class="si">{</span><span class="n">equal_to</span><span class="si">!r}</span><span class="s2">)</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.set_value_shape] </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">name</span> <span class="ow">in</span> <span class="n">equal_to</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, it should be in equal_to=</span><span class="si">{</span><span class="n">equal_to</span><span class="si">!r}</span><span class="s2">.&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">equal_to</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">None</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">equal_to</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">None</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unexpected value=</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> for name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, equal_to=</span><span class="si">{</span><span class="n">equal_to</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;values=</span><span class="si">{</span><span class="n">values</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="n">equal_to</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">equal_to</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">!r}</span><span class="s2"> should already registered, name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;value=</span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2">, equal_to=</span><span class="si">{</span><span class="n">equal_to</span><span class="si">!r}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="c1"># The logic is to get rid of one value instead of keeping</span>
        <span class="c1"># a mapping between equivalent values.</span>
        <span class="n">new_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="p">[</span><span class="n">equal_to</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">equal_to</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_value</span></div>


<div class="viewcode-block" id="GraphBuilder.unique_dimension_name">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.unique_dimension_name">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">unique_dimension_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a unique dimension name.</span>
<span class="sd">        If by any change, a dimension has the same name as a dimension,</span>
<span class="sd">        the builder may be confused as a dynamic dimension can take part</span>
<span class="sd">        of a known value for a shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">existing</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unique_names</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_shapes</span><span class="p">:</span>
            <span class="n">existing</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">existing</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unique_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">prefix</span>
        <span class="n">sug</span> <span class="o">=</span> <span class="n">prefix</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">sug</span> <span class="ow">in</span> <span class="n">existing</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">sug</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unique_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sug</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sug</span></div>


<div class="viewcode-block" id="GraphBuilder.unique_name">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.unique_name">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">unique_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="s2">&quot;Returns a unique result name.&quot;</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique_names</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">sug</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">2&quot;</span>
            <span class="k">while</span> <span class="n">sug</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique_names</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">sug</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unique_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sug</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">sug</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unique_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">prefix</span></div>


<div class="viewcode-block" id="GraphBuilder.unique_node_name">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.unique_node_name">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">unique_node_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="s2">&quot;Returns a unique node name.&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique_node_names</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">sug</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">2&quot;</span>
            <span class="k">while</span> <span class="n">sug</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique_node_names</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">sug</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unique_node_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sug</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">sug</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unique_node_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">name</span></div>


<div class="viewcode-block" id="GraphBuilder.elem_size">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.elem_size">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">elem_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem_type</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="s2">&quot;Returns the size in byte of the an element of this size.&quot;</span>
        <span class="k">if</span> <span class="n">elem_type</span> <span class="ow">in</span> <span class="p">{</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span> <span class="n">TensorProto</span><span class="o">.</span><span class="n">INT32</span><span class="p">,</span> <span class="n">TensorProto</span><span class="o">.</span><span class="n">UINT32</span><span class="p">}:</span>
            <span class="k">return</span> <span class="mi">4</span>
        <span class="k">if</span> <span class="n">elem_type</span> <span class="ow">in</span> <span class="p">{</span>
            <span class="n">TensorProto</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">,</span>
            <span class="n">TensorProto</span><span class="o">.</span><span class="n">INT64</span><span class="p">,</span>
            <span class="n">TensorProto</span><span class="o">.</span><span class="n">UINT64</span><span class="p">,</span>
            <span class="n">TensorProto</span><span class="o">.</span><span class="n">COMPLEX64</span><span class="p">,</span>
        <span class="p">}:</span>
            <span class="k">return</span> <span class="mi">8</span>
        <span class="k">if</span> <span class="n">elem_type</span> <span class="ow">in</span> <span class="p">{</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">COMPLEX128</span><span class="p">}:</span>
            <span class="k">return</span> <span class="mi">16</span>
        <span class="k">if</span> <span class="n">elem_type</span> <span class="ow">in</span> <span class="p">{</span>
            <span class="n">TensorProto</span><span class="o">.</span><span class="n">INT16</span><span class="p">,</span>
            <span class="n">TensorProto</span><span class="o">.</span><span class="n">UINT16</span><span class="p">,</span>
            <span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT16</span><span class="p">,</span>
            <span class="n">TensorProto</span><span class="o">.</span><span class="n">BFLOAT16</span><span class="p">,</span>
        <span class="p">}:</span>
            <span class="k">return</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">elem_type</span> <span class="ow">in</span> <span class="p">{</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">BOOL</span><span class="p">,</span> <span class="n">TensorProto</span><span class="o">.</span><span class="n">UINT8</span><span class="p">,</span> <span class="n">TensorProto</span><span class="o">.</span><span class="n">INT8</span><span class="p">}:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;elem_size not implemented for elem_type=</span><span class="si">{</span><span class="n">elem_type</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;among </span><span class="si">{</span><span class="n">str_tensor_proto_type</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="GraphBuilder.make_dynamic_object">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.make_dynamic_object">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_dynamic_object</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
        <span class="n">shape_as_input</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">input_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a dynamic shapes.</span>

<span class="sd">        :param name: name</span>
<span class="sd">        :param value: value</span>
<span class="sd">        :param shape_as_input: adds the name to the list of the inputs</span>
<span class="sd">            of the onnx model</span>
<span class="sd">        :param input_name: the dimension comes from this input</span>
<span class="sd">        :param axis: the dimension comes this axis</span>
<span class="sd">        :return: the name</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_append_to_source</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">input_name</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">input_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">):</span>
                <span class="c1"># axis can be None for a scaler.</span>
                <span class="k">assert</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">input_name</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Name </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> (input_name=</span><span class="si">{</span><span class="n">input_name</span><span class="si">!r}</span><span class="s2">) &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;cannot be defined from itself (axis=</span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2">), &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;value type is </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">source</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">input_name</span><span class="o">=</span><span class="n">input_name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">shape_as_input</span> <span class="ow">or</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_names</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The dimension </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> is already registered but it is not an input &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">input_names</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="c1"># The dimension is already registered but it is used for another input.</span>
            <span class="n">_append_to_source</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">input_name</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Dynamic object </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, value=</span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2"> is already there</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">WrapSym</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">sym</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymFloat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymBool</span><span class="p">)</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2"> for value</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">_append_to_source</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">input_name</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_dynamic_object</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">parse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">shape_as_input</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">maybe_as_int</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="c1"># Then an input is a shape.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_dynamic_object</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">value</span><span class="p">)</span>

        <span class="c1"># Do we need this?</span>
        <span class="c1"># if name not in self._known_value_shape:</span>
        <span class="c1">#    self._known_value_shape[name] = name</span>

        <span class="n">key</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymFloat</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;node&quot;</span><span class="p">):</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">torch.fx.experimental.sym_node</span><span class="w"> </span><span class="kn">import</span> <span class="n">SymNode</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="n">SymNode</span><span class="p">):</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">key2</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">maybe_as_int</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">key2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_add_dynamic_example</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">key2</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2"> for value.node=</span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="c1"># key = str(value)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_dynamic_objects_rev</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">shape_as_input</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymFloat</span><span class="p">)),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;shape_as_input=</span><span class="si">{</span><span class="n">shape_as_input</span><span class="si">}</span><span class="s2">, unexpected type &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2"> for value</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="c1"># torch.compile adds input for dynamic shapes</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_as_shape</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="c1"># Let&#39;s mark  this input as a shape</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_value_shape</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_tensor_input</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="p">[</span><span class="n">name</span><span class="p">],</span>
                <span class="p">(</span>
                    <span class="n">TensorProto</span><span class="o">.</span><span class="n">INT64</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">)</span>
                    <span class="k">else</span> <span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span>
                <span class="p">),</span>
                <span class="nb">tuple</span><span class="p">(),</span>
                <span class="n">is_dimension</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;make_dynamic_object&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">get_dimension_as_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">name</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source</span><span class="p">[</span><span class="n">name</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Dimension </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> has no registered source &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;it cannot be created as a result</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span>
        <span class="n">input_name</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="s2">&quot;input_name&quot;</span><span class="p">]</span>
        <span class="n">shape_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;_onx_shape_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span><span class="s2">&quot;Shape&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">input_name</span><span class="p">],</span> <span class="p">[</span><span class="n">shape_name</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;_get_dimension_as_result&quot;</span><span class="p">)</span>
        <span class="n">axis_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_initializer</span><span class="p">(</span>
            <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">axis</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
            <span class="n">source</span><span class="o">=</span><span class="s2">&quot;GraphBuilder.get_dimension_as_result.axis_name&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span><span class="s2">&quot;Gather&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">shape_name</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">],</span> <span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;_get_dimension_as_result&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">name</span>

<div class="viewcode-block" id="GraphBuilder.make_shape_from_results">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.make_shape_from_results">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_shape_from_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">DYNAMIC_SHAPE</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a shape coming from intermediate results.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s2"> for shape</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">all_int</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_initializer</span><span class="p">(</span>
                <span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
                <span class="n">source</span><span class="o">=</span><span class="s2">&quot;GraphBuilder.make_shape_from_results.shape&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">key</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">key</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_torch_sym_int</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="n">key</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">)):</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_quiet</span> <span class="ow">or</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="p">),</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Missing shape for </span><span class="si">{</span><span class="n">d</span><span class="si">!r}</span><span class="s2"> in </span><span class="si">{</span><span class="n">shape</span><span class="si">!r}</span><span class="s2">, has_rank=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;has_type=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">key</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="si">}</span><span class="s2"> for a dimension in &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">shape</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="k">assert</span> <span class="n">all_int_or_str</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unexpected key </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> type are </span><span class="si">{</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">key</span><span class="p">]</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;shape=</span><span class="si">{</span><span class="n">shape</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Concat&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache_shape</span><span class="p">:</span>
            <span class="c1"># The same shape was already requested.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache_shape</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="n">shape_shape</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">conc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">conc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">make_initializer</span><span class="p">(</span>
                        <span class="s2">&quot;&quot;</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
                        <span class="n">source</span><span class="o">=</span><span class="s2">&quot;GraphBuilder.make_shape_from_results.conc&quot;</span><span class="p">,</span>
                    <span class="p">),</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">shape_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">shape_shape</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">d</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects_rev</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects_rev</span><span class="p">[</span><span class="n">value</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">1</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects_rev</span><span class="p">[</span><span class="n">value</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">),</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">, name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, value=</span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dimension_as_result</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">value</span>

                <span class="k">assert</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span>
                    <span class="n">name</span>
                <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unknown dynamic object </span><span class="si">{</span><span class="n">d</span><span class="si">!r}</span><span class="s2"> (or </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">)</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Unexpected rank=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                        <span class="s2">&quot;for a shape{self.get_debug_msg()}&quot;</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">UnsqueezeAnyOpset</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ZERO</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;_mkshape1_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_device</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">set_device</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_shape</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
                        <span class="n">conc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                        <span class="n">shape_shape</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># We assume rank is one.</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">shape_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">shape_shape</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">shape_shape</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="n">conc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">shape_shape</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">conc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_torch_sym_int</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects_rev</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects_rev</span><span class="p">[</span><span class="n">value</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">1</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects_rev</span><span class="p">[</span><span class="n">value</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">),</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">, name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, value=</span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dimension_as_result</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">):</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_torch_sym_int</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">)</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span>
                    <span class="n">name</span>
                <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unknown dynamic object </span><span class="si">{</span><span class="n">d</span><span class="si">!r}</span><span class="s2">-</span><span class="si">{</span><span class="n">name</span><span class="si">!r}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Unexpected rank=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                        <span class="s2">&quot;for a shape{self.get_debug_msg()}&quot;</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">UnsqueezeAnyOpset</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ZERO</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;_mkshape2_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_device</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">set_device</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_shape</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
                        <span class="n">conc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">conc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">conc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">shape_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">shape_shape</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="si">}</span><span class="s2"> for a dimension in &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">shape</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">conc</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;All tensors to concatenate must have rank 1, got ranks: &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;?&#39;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">conc</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">conc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span><span class="s2">&quot;Concat&quot;</span><span class="p">,</span> <span class="n">conc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;_mkshape_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">shape_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_rank</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_shape</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="p">(</span><span class="n">shape_shape</span><span class="p">,))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">conc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;No shape to concatenate</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span><span class="s2">&quot;Identity&quot;</span><span class="p">,</span> <span class="n">conc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;_mkshape1_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache_shape</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="GraphBuilder.make_initializer">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.make_initializer">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_initializer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
        <span class="n">external</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">msg</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">parameter_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">source</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">allow_empty</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">give_unique</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an initializer to the graph.</span>
<span class="sd">        The function detects duplicated small containers, only if they are</span>
<span class="sd">        integers. Other type might be used as weights. Even similar, they could</span>
<span class="sd">        change after training.</span>

<span class="sd">        :param name: name, if empty (`&quot;&quot;`), a unique names is given, if not empty,</span>
<span class="sd">            it is more like a prefix, the method might change it to make it unique</span>
<span class="sd">        :param value: value (TensorProto)</span>
<span class="sd">        :param external: external initializer or not (not stored in the graph model)</span>
<span class="sd">        :param msg: added to the error message if something goes wrong</span>
<span class="sd">        :param parameter_name: the parameter name is different than its name in the fx graph,</span>
<span class="sd">            they are restored when the model is finally exported into onnx,</span>
<span class="sd">            until then, the mapping is kept in attribute ``_parameter_renaming``</span>
<span class="sd">        :param source: any additional information, this field is usually used to</span>
<span class="sd">            let the number know where the initializer was created.</span>
<span class="sd">        :param allow_empty: allow_empty value</span>
<span class="sd">        :param give_unique: give a unique name</span>
<span class="sd">        :return: name of the initializer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">external</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;External initializers are not implemented yet.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">TensorProto</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Shape </span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> does not match the registered one </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;for name </span><span class="si">{</span><span class="n">name</span><span class="si">!r}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Shape </span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> does not match the registered one </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;for name </span><span class="si">{</span><span class="n">name</span><span class="si">!r}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="c1"># torch.nn.parameter.Parameter -&gt; np.ndarray</span>
            <span class="k">assert</span> <span class="s2">&quot;FakeTensor&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;FakeTensor </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> cannot be an initializer </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Shape </span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> does not match the registered one </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;for name </span><span class="si">{</span><span class="n">name</span><span class="si">!r}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Initializer name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2"> for value=</span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2"> (</span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_key</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">:</span>
            <span class="c1"># exception with obivous names</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;ONES&quot;</span><span class="p">,</span> <span class="s2">&quot;ZEROS&quot;</span><span class="p">,</span> <span class="s2">&quot;ZERO&quot;</span><span class="p">,</span> <span class="s2">&quot;ONE&quot;</span><span class="p">}</span> <span class="ow">or</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;ONES&quot;</span><span class="p">):</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">parameter_name</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Empty name cannot be used with parameter_name=</span><span class="si">{</span><span class="n">parameter_name</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;key=</span><span class="si">{</span><span class="n">key</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">new_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">assert</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unable to find </span><span class="si">{</span><span class="n">new_name</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_append_initializer_source</span><span class="p">(</span><span class="n">new_name</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">existing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">new_name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_append_initializer_source</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">same_as</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
                <span class="s2">&quot;Identity&quot;</span><span class="p">,</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">key</span><span class="p">]],</span>
                <span class="p">[</span><span class="n">name</span><span class="p">],</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;make_initializer&quot;</span><span class="p">,</span>
                <span class="n">insert_position</span><span class="o">=</span><span class="s2">&quot;HEAD&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">TensorProto</span><span class="p">):</span>
            <span class="n">itype</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">data_type</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">itype</span> <span class="o">=</span> <span class="n">_get_type</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">or</span> <span class="n">give_unique</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sh</span> <span class="o">=</span> <span class="s2">&quot;x&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">shape</span><span class="p">))</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">size</span><span class="p">())</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;detach&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="n">value</span><span class="o">.</span><span class="n">size</span>
                <span class="n">sh2</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))</span>
                    <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">5</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span>
                    <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                <span class="p">)</span>
                <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;init</span><span class="si">{</span><span class="n">itype</span><span class="si">}</span><span class="s2">_s</span><span class="si">{</span><span class="n">sh</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">sh2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_initializer</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">value</span><span class="p">,</span>
            <span class="n">itype</span><span class="o">=</span><span class="n">itype</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
            <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
            <span class="n">parameter_name</span><span class="o">=</span><span class="n">parameter_name</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span>
            <span class="n">allow_empty</span><span class="o">=</span><span class="n">allow_empty</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">name</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_append_initializer_source</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">same_as</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">existing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gathers information related to an initializer.</span>

<span class="sd">        :param name: name of the initializer</span>
<span class="sd">        :param source: any kind of string, it should not be empty</span>
<span class="sd">        :param same_as: the initializer was detected as a duplicate of an existing one,</span>
<span class="sd">            this field reflects that.</span>
<span class="sd">        :param existing: does it already exists?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">existing</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Initializer </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> does not exist, source=</span><span class="si">{</span><span class="n">source</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">add_source</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">assert</span> <span class="n">existing</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Initializer </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> was already added to the model, source=</span><span class="si">{</span><span class="n">source</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;existing is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="si">!r}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_empty_source</span> <span class="ow">or</span> <span class="n">source</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;source is null for initializer </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="o">.</span><span class="n">InitializerInfo</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">same_as</span><span class="o">=</span><span class="n">same_as</span>
        <span class="p">)</span>

<div class="viewcode-block" id="GraphBuilder.add_initializer">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.add_initializer">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_initializer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
        <span class="n">itype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cst</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">existing</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">allow_empty</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">parameter_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">source</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an initializer.</span>

<span class="sd">        :param name: constant name</span>
<span class="sd">        :param value: initializer</span>
<span class="sd">        :param itype: to overwrite the type</span>
<span class="sd">        :param shape: to overwrite the shape</span>
<span class="sd">        :param cst: value to send to :meth:`update_node_constant</span>
<span class="sd">            &lt;experimental_experiment.xshape._inference_runtime._InferenceRuntime.update_node_constant&gt;`</span>
<span class="sd">        :param key: used to register the initializer</span>
<span class="sd">        :param existing: if True, shape and type should exist,</span>
<span class="sd">            if False, it should not exist, if None, both case are allowed</span>
<span class="sd">        :param allow_empty: allow empty tensor anyway</span>
<span class="sd">        :param parameter_name: the parameter name is different than its name in the fx graph,</span>
<span class="sd">            they are restored when the model is finally exported into onnx,</span>
<span class="sd">            until then, the mapping is kept in attribute ``_parameter_renaming``</span>
<span class="sd">        :param source: any additional information, this field is usually used to</span>
<span class="sd">            let the number know where the initializer was created.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">)</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span>
            <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;NEWDIM&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Shape </span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> does not match the registered one </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;for name </span><span class="si">{</span><span class="n">name</span><span class="si">!r}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">is_proto</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">TensorProto</span><span class="p">,</span> <span class="n">NodeProto</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_tensor_shape</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_proto</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">itype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">itype</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_tensor_type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_proto</span> <span class="k">else</span> <span class="n">dtype_to_tensor_dtype</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">existing</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">allow_empty</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">min</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Initializer </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> has an empty shape=</span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">, itype=</span><span class="si">{</span><span class="n">itype</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;existing shape=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;?&#39;</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;type=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;value </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> is replaced by an initializer &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;already exists</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">or</span> <span class="n">itype</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Type mismatch for </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, existing type </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;new type </span><span class="si">{</span><span class="n">itype</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">or</span> <span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Type mismatch for </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, existing shape &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">, new shape </span><span class="si">{</span><span class="n">shape</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_shape</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">allow_zero</span><span class="o">=</span><span class="n">allow_empty</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">itype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">allow_empty</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">min</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Initializer </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> has an empty shape=</span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">, itype=</span><span class="si">{</span><span class="n">itype</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;type=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;value=</span><span class="si">{</span><span class="n">string_type</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">with_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="w"> </span><span class="n">with_min_max</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="n">existing</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;initializer </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> was already added (itype=</span><span class="si">{</span><span class="n">itype</span><span class="si">}</span><span class="s2">, shape=</span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="n">existing</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span>
                <span class="n">name</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;initializer </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> already exists</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_shape</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">allow_zero</span><span class="o">=</span><span class="n">allow_empty</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">itype</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;make_initializer&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unique_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_key</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant_is_equal_to</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">existing</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_append_initializer_source</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">existing</span><span class="o">=</span><span class="n">existing</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">parameter_name</span> <span class="ow">and</span> <span class="n">parameter_name</span> <span class="o">!=</span> <span class="n">name</span><span class="p">:</span>
            <span class="c1"># We want a specific name for this one, let&#39;s keep that information in</span>
            <span class="c1"># main so that we can rename them later.</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">parameter_name</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Parameter </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> cannot be renamed int </span><span class="si">{</span><span class="n">parameter_name</span><span class="si">!r}</span><span class="s2"> as it &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;is already taken</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameter_name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_norename</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">parameter_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">[</span><span class="n">parameter_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_append_initializer_source</span><span class="p">(</span>
                <span class="n">parameter_name</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">existing</span><span class="o">=</span><span class="n">existing</span><span class="p">,</span> <span class="n">same_as</span><span class="o">=</span><span class="n">name</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">parameter_name</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;parameter_name&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_shape</span><span class="p">(</span><span class="n">parameter_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">parameter_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_device</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_device</span><span class="p">(</span><span class="n">parameter_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)):</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_initializer] &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">itype</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">] -&gt; </span><span class="si">{</span><span class="n">parameter_name</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_initializer] </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">itype</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cst</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">NodeProto</span><span class="p">):</span>
            <span class="n">cst</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">is_constant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_node_constant</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">cst</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_constant</span> <span class="ow">and</span> <span class="n">parameter_name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_node_constant</span><span class="p">(</span><span class="n">parameter_name</span><span class="p">,</span> <span class="n">cst</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="n">name</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_shape_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">STATIC_SHAPE</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">oh</span><span class="o">.</span><span class="n">np_dtype_to_tensor_dtype</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">value</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">torch_dtype_to_onnx_dtype</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">value</span><span class="o">.</span><span class="n">nelement</span><span class="p">(),</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">TensorProto</span><span class="p">):</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">data_type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">shape</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported type for a constant </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">constant_is_equal_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;intializer </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> not found.&quot;</span>
        <span class="n">cst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">itype1</span><span class="p">,</span> <span class="n">size1</span><span class="p">,</span> <span class="n">shape1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape_type</span><span class="p">(</span><span class="n">cst</span><span class="p">)</span>
        <span class="n">itype2</span><span class="p">,</span> <span class="n">size2</span><span class="p">,</span> <span class="n">shape2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape_type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">itype1</span> <span class="o">!=</span> <span class="n">itype2</span> <span class="ow">or</span> <span class="n">shape1</span> <span class="o">!=</span> <span class="n">shape2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">size1</span><span class="p">,</span> <span class="n">size2</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">30</span><span class="p">:</span>
            <span class="c1"># No check. Too long.</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cst</span><span class="p">,</span> <span class="n">TensorProto</span><span class="p">):</span>
            <span class="n">cst</span> <span class="o">=</span> <span class="n">onh</span><span class="o">.</span><span class="n">to_array</span><span class="p">(</span><span class="n">cst</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">TensorProto</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">onh</span><span class="o">.</span><span class="n">to_array</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cst</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cst</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">cst</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">cst</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,):</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cst</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cst</span> <span class="o">==</span> <span class="n">value</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cst</span> <span class="o">-</span> <span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="n">t1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">cst</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cst</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">cst</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">value</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span><span class="si">}</span><span class="s2"> for name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">t1</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">t2</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">t1</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">t2</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">t1</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t1</span> <span class="o">==</span> <span class="n">t2</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t2</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>

<div class="viewcode-block" id="GraphBuilder.is_dynamic_shape">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.is_dynamic_shape">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_dynamic_shape</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">:</span> <span class="n">DYNAMIC_SHAPE</span><span class="p">,</span>
        <span class="n">verify</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">allow_none</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">allow_new_dynamic_dimension</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tells if a shape is dynamic or static (only integers).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_dynamic_dimension</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span>
                <span class="n">verify</span><span class="o">=</span><span class="n">verify</span><span class="p">,</span>
                <span class="n">allow_none</span><span class="o">=</span><span class="n">allow_none</span><span class="p">,</span>
                <span class="n">allow_new_dynamic_dimension</span><span class="o">=</span><span class="n">allow_new_dynamic_dimension</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">shape</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="GraphBuilder.is_constant_or_attribute">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.is_constant_or_attribute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_constant_or_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">NodeProto</span><span class="p">,</span> <span class="n">input_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">att_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tells if an input is a constant or returns true if in an older</span>
<span class="sd">        opset, it was named as an attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">input_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="n">input_index</span><span class="p">])</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="GraphBuilder.get_constant_or_attribute">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.get_constant_or_attribute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_constant_or_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">NodeProto</span><span class="p">,</span> <span class="n">input_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">att_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tells if an input is a constant or returns true if in an older</span>
<span class="sd">        opset, it was named as an attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">input_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_constant</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="n">input_index</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">att_name</span><span class="p">:</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">INTS</span>
                <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Not Implemented when att.type=</span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">type</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">ints</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">is_dynamic_dimension</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
        <span class="n">verify</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">allow_none</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">allow_new_dynamic_dimension</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">allow_none</span> <span class="ow">and</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_alias</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_alias</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">dim</span><span class="p">)]</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">verify</span>
            <span class="ow">or</span> <span class="n">is_static_dimension</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">str</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span>
            <span class="ow">or</span> <span class="nb">str</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects_rev</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">dim</span><span class="p">))</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_dimension_expression</span><span class="p">(</span>
                <span class="n">dim</span><span class="p">,</span> <span class="n">allow_new_dynamic_dimension</span><span class="o">=</span><span class="n">allow_new_dynamic_dimension</span>
            <span class="p">)</span>
        <span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;dim=</span><span class="si">{</span><span class="n">dim</span><span class="si">!r}</span><span class="s2"> (type=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span><span class="si">}</span><span class="s2">) not in found in &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="si">}</span><span class="s2">, self.dynamic_shapes=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;self._dynamic_alias=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_alias</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="GraphBuilder.get_dynamic_dimension">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.get_dynamic_dimension">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_dynamic_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">keep_const</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a dynamic dimension as a 1D tensor of one element.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">keep_const</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dim</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_initializer</span><span class="p">(</span>
                <span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dim</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
                <span class="n">source</span><span class="o">=</span><span class="s2">&quot;GraphBuilder.get_dynamic_dimension.dim&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">dim</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">)</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span><span class="si">}</span><span class="s2"> for dim=</span><span class="si">{</span><span class="n">dim</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;dim=</span><span class="si">{</span><span class="n">dim</span><span class="si">!r}</span><span class="s2"> has no rank</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">UnsqueezeAnyOpset</span><span class="p">(</span>
                        <span class="n">dim</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">ZERO</span><span class="p">,</span>
                        <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;get_dynamic_dimension_a_</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">return</span> <span class="n">dim</span>
            <span class="k">assert</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unable to find a dynamic object for </span><span class="si">{</span><span class="n">dim</span><span class="si">:</span><span class="s2">r</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;list=</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unable to find a result to express dim </span><span class="si">{</span><span class="n">dim</span><span class="si">:</span><span class="s2">r</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;sources=</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Source is available for </span><span class="si">{</span><span class="n">dim</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;source=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_torch_sym_int_to_str</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">name</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unable to expression a dynamic dimension</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> has no rank</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">UnsqueezeAnyOpset</span><span class="p">(</span>
                    <span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ZERO</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;get_dynamic_dimension_b_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">dim</span>
        <span class="k">assert</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unable to find a dynamic object for </span><span class="si">{</span><span class="n">name</span><span class="si">:</span><span class="s2">r</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;list=</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unable to find a result to express dim </span><span class="si">{</span><span class="n">name</span><span class="si">:</span><span class="s2">r</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;sources=</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Source is available for </span><span class="si">{</span><span class="n">dim</span><span class="si">!r}</span><span class="s2">, source=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_dynamic_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;WrapDim&quot;</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span> <span class="ow">or</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">dyn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dyn</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">dyn</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
        <span class="n">st</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
        <span class="n">name</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">v</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="k">if</span> <span class="s2">&quot;_Dim&quot;</span> <span class="ow">in</span> <span class="n">st</span> <span class="ow">or</span> <span class="s2">&quot;_DerivedDim&quot;</span> <span class="ow">in</span> <span class="n">st</span> <span class="ow">or</span> <span class="s2">&quot;torch.export.dynamic_shapes.Dim&quot;</span> <span class="ow">in</span> <span class="n">st</span>
            <span class="k">else</span> <span class="n">v</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">WrapDim</span><span class="p">)),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;_get_dynamic_dimension must return a string but name is </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;type(name)=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">name</span>

<div class="viewcode-block" id="GraphBuilder.add_dynamic_object">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.add_dynamic_object">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_dynamic_object</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">parse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">check_tokens</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers a dynamic object such as a dynamic dimension.</span>

<span class="sd">        :param key: string</span>
<span class="sd">        :param value: SymInt, Dim, _DerivedDim</span>
<span class="sd">        :param name: input name it comes from</span>
<span class="sd">        :param dim: dimension for this dimension in input</span>
<span class="sd">        :param parse: parse the expression add pieces of it as well</span>
<span class="sd">        :param check_token: check that the subtoken are</span>
<span class="sd">            registered prior to this addition</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">export</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">_Dim</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unexpected dimension type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;class is </span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">!r}</span><span class="s2"> for key=</span><span class="si">{</span><span class="n">key</span><span class="si">!r}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">WrapDim</span><span class="p">):</span>
            <span class="n">keykey</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">key</span><span class="p">,</span> <span class="nb">str</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="si">}</span><span class="s2"> for key</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">keykey</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymFloat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">WrapDim</span><span class="p">)):</span>
            <span class="n">wrapped_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">WrapSym</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">[</span><span class="n">keykey</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrapped_value</span>
            <span class="n">wrapped_name</span> <span class="o">=</span> <span class="n">wrapped_value</span><span class="o">.</span><span class="n">name</span>
            <span class="k">if</span> <span class="n">wrapped_name</span> <span class="ow">and</span> <span class="n">wrapped_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">:</span>
                <span class="c1"># This means this informations is a dynamic dimension</span>
                <span class="c1"># used for the first time.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">[</span><span class="n">wrapped_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrapped_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">[</span><span class="n">keykey</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span> <span class="ow">and</span> <span class="n">dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dyn_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dyn_shape</span><span class="p">:</span>
                <span class="n">dyndim</span> <span class="o">=</span> <span class="n">dyn_shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_dynamic_alias</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">dyndim</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">parse</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">register_dynamic_objects_from_dim</span><span class="p">(</span><span class="n">keykey</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">check_tokens</span><span class="p">:</span>
            <span class="n">tokens</span> <span class="o">=</span> <span class="n">parse_expression_tokens</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">assert</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">,</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Token </span><span class="si">{</span><span class="n">t</span><span class="si">!r}</span><span class="s2"> from </span><span class="si">{</span><span class="n">key</span><span class="si">!r}</span><span class="s2"> is not registered &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;among </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">)</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span></div>


<div class="viewcode-block" id="GraphBuilder.has_dynamic_object">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.has_dynamic_object">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_dynamic_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tells if a result is a dynamic object, `torch.SymInt` for torch.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">add_dynamic_objects_rev</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">name_value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects_rev</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects_rev</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects_rev</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name_value</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_add_dynamic_example</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_examples</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_examples</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_examples</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_torch_sym_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">add</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymFloat</span><span class="p">)</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;unexpected type for d=</span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2">, type=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># don&#39;t use &#39;expr&#39;</span>
            <span class="n">dyn_val</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">_expr</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">dyn_val</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">d</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">node</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Is it an integer?</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">maybe_as_int</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># maybe an expression which is a single integer</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="k">pass</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_alias</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_alias</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects_rev</span><span class="p">:</span>
            <span class="c1"># The dynamic dimension does not seem to be registered.</span>
            <span class="c1"># Maybe it is constant.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">val_int</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">maybe_as_int</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">val_int</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_dynamic_example</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">val_int</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">value</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="k">pass</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects_rev</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span> <span class="ow">and</span> <span class="n">add</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_dynamic_object</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_dynamic_object_rev</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects_rev</span> <span class="ow">or</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;value=</span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2">, unable to find dimension </span><span class="si">{</span><span class="n">d</span><span class="si">!r}</span><span class="s2"> (</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="si">}</span><span class="s2">) &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;(str(d)=</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="si">!r}</span><span class="s2">) in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects_rev</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;or </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_alias</span><span class="si">}</span><span class="s2"> or </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">dir</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2"> for d=</span><span class="si">{</span><span class="n">d</span><span class="si">!r}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects_rev</span><span class="p">:</span>
            <span class="n">new_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects_rev</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_value</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">new_value</span><span class="p">)</span><span class="si">}</span><span class="s2"> for value=</span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2">, d=</span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_value</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unexpected number of items in </span><span class="si">{</span><span class="n">new_value</span><span class="si">}</span><span class="s2">, value=</span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2">, d=</span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="c1"># We assume if len(new_value) &gt; 1 that all names are equivalent.</span>
            <span class="c1"># The graph is doing the same computation multiple times.</span>
            <span class="n">final</span> <span class="o">=</span> <span class="n">new_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">final</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">final</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">final</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">final</span><span class="p">)</span><span class="si">}</span><span class="s2">, final=</span><span class="si">{</span><span class="n">final</span><span class="si">}</span><span class="s2">, value=</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">, d=</span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;new_value=</span><span class="si">{</span><span class="n">new_value</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">final</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="c1"># A formula</span>
                <span class="k">return</span> <span class="n">final</span>

            <span class="c1"># An alias</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">final</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">, name=</span><span class="si">{</span><span class="n">final</span><span class="si">}</span><span class="s2">, value=</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">, d=</span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;new_value=</span><span class="si">{</span><span class="n">new_value</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">name</span>

        <span class="c1"># Its value is in self._known_value_shape. We still return its name.</span>
        <span class="k">return</span> <span class="n">value</span>

<div class="viewcode-block" id="GraphBuilder.verify_dynamic_shape">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.verify_dynamic_shape">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">verify_dynamic_shape</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">add</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DYNAMIC_SHAPE</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The implementation of this method should be revisited.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">is_static</span> <span class="o">=</span> <span class="n">is_static_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unable to check static shape </span><span class="si">{</span><span class="n">string_type</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">if</span> <span class="n">is_static</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">)</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">WrapDim</span><span class="p">)):</span>
                <span class="n">dyn_name</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dynamic_dimension</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dyn_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">add</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">add_dynamic_object</span><span class="p">(</span><span class="n">dyn_name</span><span class="p">,</span> <span class="n">dyn_name</span><span class="p">,</span> <span class="n">parse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">new_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">dyn_name</span><span class="o">.</span><span class="n">name_as_string</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dyn_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">WrapDim</span><span class="p">)</span>
                        <span class="k">else</span> <span class="n">dyn_name</span>
                    <span class="p">)</span>
                    <span class="k">continue</span>

                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_torch_sym_int</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">add</span><span class="o">=</span><span class="n">add</span><span class="p">)</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="si">}</span><span class="s2"> in shape=</span><span class="si">{</span><span class="n">shape</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">new_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">export</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">_Dim</span><span class="p">)</span>
                <span class="ow">or</span> <span class="s2">&quot;_DerivedDim&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="ow">or</span> <span class="s2">&quot;_Dim&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;verify_dynamic_shape not yet implemented for type(d)=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="si">}</span><span class="s2">, d=</span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">new_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="si">}</span><span class="s2"> in shape=</span><span class="si">{</span><span class="n">shape</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">new_shape</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Issue with shape=</span><span class="si">{</span><span class="n">new_shape</span><span class="si">}</span><span class="s2">, types=</span><span class="si">{</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">new_shape</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">new_new_shape</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">new_shape</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">new_new_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simplifies_dynamic_dimension_string</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
            <span class="n">new_new_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_new_shape</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_simplifies_dynamic_dimension_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">dim</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;(&quot;</span> <span class="ow">and</span> <span class="n">dim</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;)&quot;</span> <span class="ow">and</span> <span class="s2">&quot;(&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dim</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;0+&quot;</span><span class="p">):</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">dim</span>

<div class="viewcode-block" id="GraphBuilder.register_users">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.register_users">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">register_users</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">users</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers users. This is not used except to check the conversion</span>
<span class="sd">        is valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_registered_users</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> is already registered</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_registered_users</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">users</span><span class="p">)</span></div>


<div class="viewcode-block" id="GraphBuilder.make_tensor_input">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.make_tensor_input">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_tensor_input</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
        <span class="n">elem_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DYNAMIC_SHAPE</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">is_dimension</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">default_initializer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a tensor input to the onnx graph.</span>

<span class="sd">        :param name: name or tuple of names, in case, all inputs are create</span>
<span class="sd">            with the same element type and shape</span>
<span class="sd">        :param elem_type: element type</span>
<span class="sd">        :param shape: shape</span>
<span class="sd">        :param is_dimension: torch is using ``torch.SymInt`` to add a dynamic input</span>
<span class="sd">            to the graph</span>
<span class="sd">        :param marker: to known from this input was created</span>
<span class="sd">        :param default_initializer: add an initializer with the same name of the input</span>
<span class="sd">        :param device: device if known</span>
<span class="sd">        :return: input name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">make_tensor_input</span><span class="p">(</span>
                        <span class="n">n</span><span class="p">,</span>
                        <span class="n">elem_type</span><span class="p">,</span>
                        <span class="n">shape</span><span class="p">,</span>
                        <span class="n">is_dimension</span><span class="o">=</span><span class="n">is_dimension</span><span class="p">,</span>
                        <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span>
                        <span class="n">default_initializer</span><span class="o">=</span><span class="n">default_initializer</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">as_function</span> <span class="ow">or</span> <span class="n">elem_type</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;elem_type is unknown for name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">add_node</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="kc">None</span>  <span class="c1"># noqa: E731</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_input</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_names</span><span class="p">):</span>
            <span class="c1"># The input needs to be renamed, an identity node is added.</span>
            <span class="n">input_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">current_input</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">input_name</span> <span class="o">!=</span> <span class="n">name</span><span class="p">:</span>
                <span class="n">add_node</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>  <span class="c1"># noqa: E731</span>
                    <span class="s2">&quot;Identity&quot;</span><span class="p">,</span>
                    <span class="p">[</span><span class="n">input_name</span><span class="p">],</span>
                    <span class="p">[</span><span class="n">name</span><span class="p">],</span>
                    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;make_tensor_input_id&quot;</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_dimension</span><span class="p">:</span>
                <span class="c1"># The convention is to have _dim_ in the name to tell</span>
                <span class="c1"># it is a dimension.</span>
                <span class="n">input_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_dim_&quot;</span>
                <span class="k">if</span> <span class="n">input_name</span> <span class="o">!=</span> <span class="n">name</span><span class="p">:</span>
                    <span class="n">add_node</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>  <span class="c1"># noqa: E731</span>
                        <span class="s2">&quot;Identity&quot;</span><span class="p">,</span>
                        <span class="p">[</span><span class="n">input_name</span><span class="p">],</span>
                        <span class="p">[</span><span class="n">name</span><span class="p">],</span>
                        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;make_tensor_input_id&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">input_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">input_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="n">input_name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">current_input</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">elem_type</span> <span class="o">=</span> <span class="n">_get_type</span><span class="p">(</span><span class="n">elem_type</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_dynamic_shape_when_input_name_is_defined</span><span class="p">:</span>
            <span class="c1">#</span>
            <span class="c1"># dynamic shapes were defined as tuple,</span>
            <span class="c1"># we need to propagate the information to the names</span>
            <span class="c1"># dynamic_dimensions_source={&#39;dim&#39;: [{&#39;axis&#39;: 1, &#39;input_name&#39;: 0}]}</span>
            <span class="c1"># Let&#39;s replace None by strings.</span>
            <span class="c1">#</span>
            <span class="k">for</span> <span class="n">dim_name</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;input_name&quot;</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;input_name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">):</span>
                        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;input_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_name</span>
                        <span class="k">if</span> <span class="n">shape</span><span class="p">:</span>
                            <span class="n">axis</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span>
                            <span class="k">assert</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Unexpected shape=</span><span class="si">{</span><span class="n">shape</span><span class="si">!r}</span><span class="s2"> and axis=</span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2">, &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;dim_name=</span><span class="si">{</span><span class="n">dim_name</span><span class="si">!r}</span><span class="s2">, self.dynamic_dimensions_source=&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source</span><span class="si">}</span><span class="s2"> &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, input_name=</span><span class="si">{</span><span class="n">input_name</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;self.dynamic_shapes=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="si">}</span><span class="s2"> &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;self.input_names=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">input_names</span><span class="si">}</span><span class="s2">&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
                            <span class="n">dim_name_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_torch_sym_int_to_str</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
                            <span class="k">if</span> <span class="n">dim_name</span> <span class="o">!=</span> <span class="n">dim_name_axis</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim_name_axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                                <span class="k">assert</span> <span class="p">(</span>
                                    <span class="n">dim_name_axis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_alias</span>
                                    <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_alias</span><span class="p">[</span><span class="n">dim_name_axis</span><span class="p">]</span> <span class="o">==</span> <span class="n">dim_name</span>
                                <span class="p">),</span> <span class="p">(</span>
                                    <span class="sa">f</span><span class="s2">&quot;Alias mismatch for </span><span class="si">{</span><span class="n">dim_name_axis</span><span class="si">!r}</span><span class="s2">, axis=</span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2">, &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;existing is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_alias</span><span class="p">[</span><span class="n">dim_name_axis</span><span class="p">]</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;new is </span><span class="si">{</span><span class="n">dim_name</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;for input </span><span class="si">{</span><span class="n">input_name</span><span class="si">!r}</span><span class="s2"> and shape </span><span class="si">{</span><span class="n">shape</span><span class="si">!r}</span><span class="s2">&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                                <span class="p">)</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_add_dynamic_alias</span><span class="p">(</span><span class="n">dim_name_axis</span><span class="p">,</span> <span class="n">dim_name</span><span class="p">)</span>
                            <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                                <span class="n">dim_name</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">axis</span> <span class="k">else</span> <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
                            <span class="p">)</span>

        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">(</span><span class="n">sh</span> <span class="k">if</span> <span class="n">sh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_dimension_name</span><span class="p">(</span><span class="n">input_name</span><span class="p">))</span> <span class="k">for</span> <span class="n">sh</span> <span class="ow">in</span> <span class="n">shape</span>
            <span class="p">)</span>
        <span class="n">dyn_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">verify_dynamic_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">input_name</span><span class="p">,</span> <span class="n">add</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fill_dynamic_alias</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">new_dyn_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_dynamic_alias</span><span class="p">(</span><span class="n">dyn_shape</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_dyn_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dyn_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">(</span><span class="n">a</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_dyn_shape</span><span class="p">,</span> <span class="n">dyn_shape</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">node</span> <span class="o">=</span> <span class="n">oh</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span><span class="n">input_name</span><span class="p">,</span> <span class="n">elem_type</span><span class="p">,</span> <span class="n">dyn_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">input_name</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;make_tensor_input_</span><span class="si">{</span><span class="n">marker</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_tensor_input_finalize</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dyn_shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_tensor_input] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">input_name</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">elem_type</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">dyn_shape</span><span class="si">}</span><span class="s2">] -- marker=</span><span class="si">{</span><span class="n">marker</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">as_function</span> <span class="ow">or</span> <span class="n">elem_type</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;elem_type=</span><span class="si">{</span><span class="n">elem_type</span><span class="si">!r}</span><span class="s2"> must be specified for input </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_shape</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dyn_shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">input_name</span> <span class="o">!=</span> <span class="n">name</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_shape</span><span class="p">(</span><span class="n">input_name</span><span class="p">,</span> <span class="n">dyn_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">elem_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">elem_type</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">input_name</span> <span class="o">!=</span> <span class="n">name</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">input_name</span><span class="p">,</span> <span class="n">elem_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_device</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">input_name</span> <span class="o">!=</span> <span class="n">name</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_device</span><span class="p">(</span><span class="n">input_name</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="n">node</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">+=</span> <span class="s2">&quot;.</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_shape_type</span><span class="p">([</span><span class="n">name</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">add_node</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">default_initializer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">init_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_initializer</span><span class="p">(</span>
                <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">default_initializer</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s2">&quot;default_initilizer&quot;</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="n">init_name</span> <span class="o">==</span> <span class="n">name</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The initializer </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> should not be renamed into </span><span class="si">{</span><span class="n">init_name</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">name</span></div>


<div class="viewcode-block" id="GraphBuilder.make_tensor_sequence_input">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.make_tensor_sequence_input">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_tensor_sequence_input</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">elem_type</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">:</span> <span class="n">DYNAMIC_SHAPE</span><span class="p">,</span>
        <span class="n">marker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a tensor input to the onnx graph.</span>

<span class="sd">        :param name: name</span>
<span class="sd">        :param elem_type: element type</span>
<span class="sd">        :param shape: shape</span>
<span class="sd">        :param marker: to known from this input was created</span>
<span class="sd">        :return: input name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">add_node</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="kc">None</span>  <span class="c1"># noqa: E731</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_input</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_names</span><span class="p">):</span>
            <span class="c1"># The input needs to be renamed, an identity node is added.</span>
            <span class="n">input_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">current_input</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">input_name</span> <span class="o">!=</span> <span class="n">name</span><span class="p">:</span>
                <span class="n">add_node</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>  <span class="c1"># noqa: E731</span>
                    <span class="s2">&quot;Identity&quot;</span><span class="p">,</span>
                    <span class="p">[</span><span class="n">input_name</span><span class="p">],</span>
                    <span class="p">[</span><span class="n">name</span><span class="p">],</span>
                    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;make_tensor_input_id&quot;</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">input_name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">current_input</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">elem_type</span> <span class="o">=</span> <span class="n">_get_type</span><span class="p">(</span><span class="n">elem_type</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_dynamic_shape_when_input_name_is_defined</span><span class="p">:</span>
            <span class="c1">#</span>
            <span class="c1"># dynamic shapes were defined as tuple,</span>
            <span class="c1"># we need to propagate the information to the names</span>
            <span class="c1"># dynamic_dimensions_source={&#39;dim&#39;: [{&#39;axis&#39;: 1, &#39;input_name&#39;: 0}]}</span>
            <span class="k">for</span> <span class="n">dim_name</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;input_name&quot;</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;input_name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">):</span>
                        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;input_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_name</span>
                        <span class="k">if</span> <span class="n">shape</span><span class="p">:</span>
                            <span class="n">axis</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span>
                            <span class="k">assert</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Unexpected shape=</span><span class="si">{</span><span class="n">shape</span><span class="si">!r}</span><span class="s2"> and axis=</span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2">, &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;dim_name=</span><span class="si">{</span><span class="n">dim_name</span><span class="si">!r}</span><span class="s2">, self.dynamic_dimensions_source=&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source</span><span class="si">}</span><span class="s2"> &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, input_name=</span><span class="si">{</span><span class="n">input_name</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;self.dynamic_shapes=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="si">}</span><span class="s2"> &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;self.input_names=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">input_names</span><span class="si">}</span><span class="s2">&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
                            <span class="n">dim_name_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_torch_sym_int_to_str</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
                            <span class="k">if</span> <span class="n">dim_name</span> <span class="o">!=</span> <span class="n">dim_name_axis</span><span class="p">:</span>
                                <span class="k">assert</span> <span class="p">(</span>
                                    <span class="n">dim_name_axis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_alias</span>
                                    <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_alias</span><span class="p">[</span><span class="n">dim_name_axis</span><span class="p">]</span> <span class="o">==</span> <span class="n">dim_name</span>
                                <span class="p">),</span> <span class="p">(</span>
                                    <span class="s2">&quot;Alias mismatch for </span><span class="si">{dim_name_axis!r}</span><span class="s2">, existing is &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_alias</span><span class="p">[</span><span class="n">dim_name_axis</span><span class="p">]</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;new is </span><span class="si">{</span><span class="n">dim_name</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;for input </span><span class="si">{</span><span class="n">input_name</span><span class="si">!r}</span><span class="s2"> and shape </span><span class="si">{</span><span class="n">shape</span><span class="si">!r}</span><span class="s2">&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                                <span class="p">)</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_add_dynamic_alias</span><span class="p">(</span><span class="n">dim_name_axis</span><span class="p">,</span> <span class="n">dim_name</span><span class="p">)</span>
                            <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                                <span class="n">dim_name</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">axis</span> <span class="k">else</span> <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
                            <span class="p">)</span>

        <span class="n">dyn_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">verify_dynamic_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">input_name</span><span class="p">,</span> <span class="n">add</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fill_dynamic_alias</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">new_dyn_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_dynamic_alias</span><span class="p">(</span><span class="n">dyn_shape</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_dyn_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dyn_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">(</span><span class="n">a</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_dyn_shape</span><span class="p">,</span> <span class="n">dyn_shape</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">node</span> <span class="o">=</span> <span class="n">oh</span><span class="o">.</span><span class="n">make_tensor_sequence_value_info</span><span class="p">(</span><span class="n">input_name</span><span class="p">,</span> <span class="n">elem_type</span><span class="p">,</span> <span class="n">dyn_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">input_name</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;make_tensor_sequence_input_</span><span class="si">{</span><span class="n">marker</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_tensor_input_finalize</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dyn_shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_tensor_sequence_input] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">input_name</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">elem_type</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">dyn_shape</span><span class="si">}</span><span class="s2">] -- marker=</span><span class="si">{</span><span class="n">marker</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">as_function</span> <span class="ow">or</span> <span class="n">elem_type</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;elem_type=</span><span class="si">{</span><span class="n">elem_type</span><span class="si">!r}</span><span class="s2"> must be specified for input </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_sequence</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">elem_type</span><span class="p">,</span> <span class="p">[</span><span class="n">shape</span><span class="p">]</span> <span class="k">if</span> <span class="n">shape</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">+=</span> <span class="s2">&quot;.</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_shape_type</span><span class="p">([</span><span class="n">name</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">add_node</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">name</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_dynamic_to_str</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">exc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">register_if_not_exist</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">register_if_not_exist</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_to_str</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">register_if_not_exist</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">res</span>
            <span class="k">if</span> <span class="n">res</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_dynamic_object</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">parse</span><span class="o">=</span><span class="n">register_if_not_exist</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">obj</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">export</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">_DerivedDim</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">export</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">_Dim</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">node</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">_expr</span>
            <span class="k">if</span> <span class="s2">&quot;sympy&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="nb">hasattr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;__module__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">==</span> <span class="s2">&quot;torch.utils._sympy.functions&quot;</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_to_str</span><span class="p">(</span>
                    <span class="n">i</span><span class="p">,</span> <span class="n">exc</span><span class="o">=</span><span class="n">exc</span><span class="p">,</span> <span class="n">register_if_not_exist</span><span class="o">=</span><span class="n">register_if_not_exist</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Object has </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="si">}</span><span class="s2"> but could not find a dynamic interpretation&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">WrapDim</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">name</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="si">}</span><span class="s2"> to convert into string&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_is_dynamic_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dyn</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">dyn</span><span class="p">,</span>
            <span class="p">(</span>
                <span class="nb">str</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">export</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">_DerivedDim</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">export</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">_Dim</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">,</span>
            <span class="p">),</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_add_dynamic_alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;An integer should not be an alias, key=</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">, value=</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_alias</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_fill_dynamic_alias</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dyn_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="n">dyn_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dyn_shape</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_dynamic_dimension</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_to_str</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">exc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">alias</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span> <span class="ow">or</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="n">sdim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_to_str</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">register_if_not_exist</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sdim</span> <span class="o">!=</span> <span class="n">alias</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_dynamic_alias</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">sdim</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sdim</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_make_tensor_input_finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">dyn_shape</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
        <span class="n">tuple_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tuple_shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">dyn_shape</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;mismatch between shape=</span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">, dynamic_shape=</span><span class="si">{</span><span class="n">dyn_shape</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">_idim</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">tuple_shape</span><span class="p">,</span> <span class="n">dyn_shape</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unexpected shape mismatch shape=</span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;dyn_shape=</span><span class="si">{</span><span class="n">dyn_shape</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unexpected shape mismatch shape=</span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;dyn_shape=</span><span class="si">{</span><span class="n">dyn_shape</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">sb</span> <span class="o">=</span> <span class="n">b</span>
                <span class="k">if</span> <span class="n">sb</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_dynamic_object</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">sb</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_to_str</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">register_if_not_exist</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_to_str</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">register_if_not_exist</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="GraphBuilder.make_tensor_output">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.make_tensor_output">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_tensor_output</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
        <span class="n">elem_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">STATIC_SHAPE</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">indexed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">is_dimension</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">allow_untyped_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">doc_string</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a tensor output to the onnx graph.</span>

<span class="sd">        :param name: name</span>
<span class="sd">        :param elem_type: element type</span>
<span class="sd">        :param shape: shape</span>
<span class="sd">        :param indexed: the name must be indexed?</span>
<span class="sd">        :param is_dimension: torch is using torch.SymInt to add a dynamic input</span>
<span class="sd">            to the graph</span>
<span class="sd">        :param allow_untyped_output: allow untyped output even if it is not a function</span>
<span class="sd">        :param doc_string: doc string</span>
<span class="sd">        :param device: device if known</span>
<span class="sd">        :return: output name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_function</span> <span class="ow">or</span> <span class="n">is_dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;is_dimension must be specified for output name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;elem_type=</span><span class="si">{</span><span class="n">elem_type</span><span class="si">}</span><span class="s2">, shape=</span><span class="si">{</span><span class="n">shape</span><span class="si">!r}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">is_dimension</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> not compatible with is_dimension=True&quot;</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_tensor_output</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">elem_type</span><span class="p">,</span> <span class="n">shape</span><span class="p">))</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span>
                    <span class="n">n</span>
                <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Output </span><span class="si">{</span><span class="n">n</span><span class="si">!r}</span><span class="s2"> among </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> not found</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">as_function</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">indexed</span> <span class="ow">or</span> <span class="s2">&quot;_&quot;</span> <span class="ow">in</span> <span class="n">name</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Name </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> is not indexed like &#39;output_0&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">is_dimension</span> <span class="ow">and</span> <span class="s2">&quot;_dim_&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">is_dimension</span> <span class="ow">and</span> <span class="s2">&quot;_dim_&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">name</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Inconsistence for input </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;elem_type=</span><span class="si">{</span><span class="n">elem_type</span><span class="si">}</span><span class="s2">, shape=</span><span class="si">{</span><span class="n">shape</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;is_dimension=</span><span class="si">{</span><span class="n">is_dimension</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="n">elem_type</span> <span class="o">=</span> <span class="n">_get_type</span><span class="p">(</span><span class="n">elem_type</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_function</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">allow_untyped_output</span> <span class="ow">and</span> <span class="n">elem_type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Undefined element type for </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">(</span><span class="n">sh</span> <span class="k">if</span> <span class="n">sh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_dimension_name</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="k">for</span> <span class="n">sh</span> <span class="ow">in</span> <span class="n">shape</span>
            <span class="p">)</span>
        <span class="n">dyn_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">verify_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">elem_type</span><span class="o">=</span><span class="n">elem_type</span><span class="p">)</span>

        <span class="n">index_output</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index_output</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">user_defined_output_names</span><span class="p">):</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">user_defined_output_names</span><span class="p">[</span><span class="n">index_output</span><span class="p">]</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">new_name</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot rename one output into </span><span class="si">{</span><span class="n">new_name</span><span class="si">!r}</span><span class="s2"> as it is already used&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
                <span class="s2">&quot;Identity&quot;</span><span class="p">,</span>
                <span class="p">[</span><span class="n">name</span><span class="p">],</span>
                <span class="p">[</span><span class="n">new_name</span><span class="p">],</span>
                <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_node_name</span><span class="p">(</span><span class="s2">&quot;make_tensor_output_rename&quot;</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_tensor_output] &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;rename </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> into </span><span class="si">{</span><span class="n">new_name</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">old_name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">new_name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">old_name</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">elem_type</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">oh</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">elem_type</span><span class="p">,</span> <span class="n">dyn_shape</span><span class="p">,</span> <span class="n">doc_string</span><span class="o">=</span><span class="n">doc_string</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We skip the shape as well.</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">ValueInfoProto</span><span class="p">()</span>
            <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">if</span> <span class="n">doc_string</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">=</span> <span class="n">doc_string</span>

        <span class="n">node</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">+=</span> <span class="s2">&quot;.</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_shape_type</span><span class="p">([</span><span class="n">name</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Output </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> not found</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_tensor_output] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">elem_type</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">dyn_shape</span><span class="si">}</span><span class="s2">]&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">dyn_shape</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_shape</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dyn_shape</span><span class="p">,</span> <span class="n">allow_zero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">old_name</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_shape</span><span class="p">(</span><span class="n">old_name</span><span class="p">,</span> <span class="n">dyn_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">elem_type</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">elem_type</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">old_name</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">old_name</span><span class="p">,</span> <span class="n">elem_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_device</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">old_name</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_device</span><span class="p">(</span><span class="n">old_name</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">name</span></div>


<div class="viewcode-block" id="GraphBuilder.make_tensor_value_info_from_name">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.make_tensor_value_info_from_name">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_tensor_value_info_from_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValueInfoProto</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a ValueInfoProto based on the information available on</span>
<span class="sd">        the graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">oh</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_tensor_output] &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">:R</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">]&quot;</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">oh</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span>
                    <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_tensor_output] &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">:R</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">]&quot;</span>
                    <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">oh</span><span class="o">.</span><span class="n">make_value_info</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">TypeProto</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_tensor_output] </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="GraphBuilder.select_outputs">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.select_outputs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">select_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Selects new outputs. The type is assumed to be unknown.</span>
<span class="sd">        The method only wipes out the outputs to replace them by</span>
<span class="sd">        others. It assumes the unused nodes are removed afterwards.</span>

<span class="sd">        :param output_names: new outputs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_outputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">output_names</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_tensor_value_info_from_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
            <span class="n">new_outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="n">new_outputs</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">verify_shape</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DYNAMIC_SHAPE</span><span class="p">],</span>
        <span class="n">elem_type</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DYNAMIC_SHAPE</span><span class="p">]:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem_type</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;elem_type must be an integer not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">elem_type</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">shape</span><span class="p">,</span> <span class="nb">tuple</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Shape must be a tuple not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># costly</span>
        <span class="c1"># assert is_static_shape(shape) or self.is_dynamic_shape(shape, allow_none=True), (</span>
        <span class="c1">#     f&quot;Shape={shape} is not a shape (type={[type(i) for i in shape]}), &quot;</span>
        <span class="c1">#     f&quot;name={name!r}, elem_type={elem_type}{self.get_debug_msg()}&quot;</span>
        <span class="c1"># )</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">verify_dynamic_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">s</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
                <span class="k">else</span> <span class="p">(</span>
                    <span class="n">simplify_expression</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">100</span>
                    <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_dimension_name</span><span class="p">(</span><span class="s2">&quot;NEWDIMLONG&quot;</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">new_shape</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">4</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_device</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">8</span>
        <span class="k">return</span> <span class="n">k</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_debug_string_inputs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">outputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">align</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Meaning:</span>

<span class="sd">        - ``&quot;-&quot;``: (0) none</span>
<span class="sd">        - ``&quot;t&quot;``: (1) type</span>
<span class="sd">        - ``&quot;r&quot;``: (2) rank</span>
<span class="sd">        - ``&quot;u&quot;``: (3) rank + type</span>
<span class="sd">        - ``&quot;s&quot;``: (4) shape</span>
<span class="sd">        - ``&quot;v&quot;``: (5) shape + type</span>
<span class="sd">        - ``&quot;w&quot;``: (6) shape + rank</span>
<span class="sd">        - ``&quot;#&quot;``: (7) shape + type + rank</span>
<span class="sd">        - ``&quot;?&quot;``: (8) device</span>
<span class="sd">        - ``&quot;T&quot;``: (9) type + device</span>
<span class="sd">        - ``&quot;R&quot;``: (10) rank + device</span>
<span class="sd">        - ``&quot;U&quot;``: (11) rank + type + device</span>
<span class="sd">        - ``&quot;S&quot;``: (12)) shape + device</span>
<span class="sd">        - ``&quot;V&quot;``: (13) shape + type + device</span>
<span class="sd">        - ``&quot;W&quot;``: (14) shape + rank + device</span>
<span class="sd">        - ``&quot;@&quot;``: (15) shape + type + rank + device</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="c1">#  ..0123456789012345</span>
        <span class="n">c</span> <span class="o">=</span> <span class="s2">&quot;-trusvw#?TRUSVW@&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="n">st</span> <span class="o">+=</span> <span class="n">c</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_symbol</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>
        <span class="n">st</span> <span class="o">+=</span> <span class="s2">&quot;:&quot;</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
            <span class="n">st</span> <span class="o">+=</span> <span class="n">c</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_symbol</span><span class="p">(</span><span class="n">o</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">align</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">align</span><span class="p">:</span>
            <span class="n">st</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">align</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">st</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_op_type</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">op_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">outputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">domain</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">attributes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">AttributeProto</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="p">):</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">op_type</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;Reduce&quot;</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">domain</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span>
            <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="s2">&quot;axes&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Operator </span><span class="si">{</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2"> defines twice the axes, kwargs=</span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;len(inputs)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">op_type</span> <span class="o">!=</span> <span class="s2">&quot;Cast&quot;</span>
            <span class="ow">or</span> <span class="n">domain</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span>
            <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;to&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;to&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s2">&quot;to&quot;</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">))</span>
        <span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Operator Cast needs arguments to but kwargs=</span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="s2">, name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="n">op_type</span> <span class="o">!=</span> <span class="s2">&quot;Cast&quot;</span> <span class="ow">or</span> <span class="n">domain</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Operator Cast has one empty input, name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, inputs=</span><span class="si">{</span><span class="n">inputs</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="n">op_type</span> <span class="o">!=</span> <span class="s2">&quot;Concat&quot;</span> <span class="ow">or</span> <span class="n">domain</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Concatenation of zero or one input is not necessary, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;len(inputs)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2"> &quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">main_opset</span> <span class="o">&lt;=</span> <span class="mi">11</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">op_type</span> <span class="o">!=</span> <span class="s2">&quot;Squeeze&quot;</span> <span class="ow">or</span> <span class="n">domain</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Operator Squeeze is not correclty specified for opset &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">main_opset</span><span class="si">}</span><span class="s2">, inputs=</span><span class="si">{</span><span class="n">inputs</span><span class="si">}</span><span class="s2">, kwargs=</span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;atts=</span><span class="si">{</span><span class="n">attributes</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_entries</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">attributes</span> <span class="ow">or</span> <span class="p">[])</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">op_type</span> <span class="o">!=</span> <span class="s2">&quot;Squeeze&quot;</span> <span class="ow">or</span> <span class="n">domain</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="ow">or</span> <span class="n">n_entries</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Operator Squeeze is not correclty specified for opset &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">main_opset</span><span class="si">}</span><span class="s2">, n_entries=</span><span class="si">{</span><span class="n">n_entries</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;inputs=</span><span class="si">{</span><span class="n">inputs</span><span class="si">}</span><span class="s2">, kwargs=</span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;atts=</span><span class="si">{</span><span class="n">attributes</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">op_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;NegXplus1&quot;</span><span class="p">,</span> <span class="s2">&quot;ReplaceZero&quot;</span><span class="p">}</span> <span class="ow">or</span> <span class="n">domain</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Type=</span><span class="si">{</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2"> and domain </span><span class="si">{</span><span class="n">domain</span><span class="si">!r}</span><span class="s2"> mismatch</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">op_type</span> <span class="o">!=</span> <span class="s2">&quot;If&quot;</span>
            <span class="ow">or</span> <span class="n">domain</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span>
            <span class="ow">or</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;then_branch&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
                <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
                <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;else_branch&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;then_branch&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">input</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;else_branch&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">input</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Node &#39;If&#39; has an unexpected number of inputs or outputs.&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">If(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span><span class="si">}</span><span class="s2">) -&gt; </span><span class="si">{</span><span class="n">outputs</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">kwargs=</span><span class="si">{</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="n">outputs</span> <span class="o">!=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">],</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unexpected value for outputs=</span><span class="si">{</span><span class="n">outputs</span><span class="si">}</span><span class="s2">, op_type=</span><span class="si">{</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">, domain=</span><span class="si">{</span><span class="n">domain</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;inputs=</span><span class="si">{</span><span class="n">inputs</span><span class="si">}</span><span class="s2">, attributes=</span><span class="si">{</span><span class="n">attributes</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

<div class="viewcode-block" id="GraphBuilder.do_not_remove">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.do_not_remove">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">do_not_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">NodeProto</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tells if a node should be removed or not.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_DONOTREMOVE_&quot;</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">unique_names</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">outputs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">op_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">attributes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">AttributeProto</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">inputs</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">op_type</span>
            <span class="ow">in</span> <span class="p">{</span>
                <span class="s2">&quot;Reshape&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Shape&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Size&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Transpose&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Cast&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Squeeze&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Unsqueeze&quot;</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">):</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">_get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">attributes</span> <span class="ow">or</span> <span class="p">[]:</span>
                    <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">INTS</span><span class="p">:</span>
                            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">ints</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">INT</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">att</span><span class="o">.</span><span class="n">i</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">op_type</span> <span class="o">==</span> <span class="s2">&quot;Cast&quot;</span><span class="p">:</span>
                <span class="n">to</span> <span class="o">=</span> <span class="n">_get</span><span class="p">(</span><span class="s2">&quot;to&quot;</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">or</span> <span class="s2">&quot;?&quot;</span>
                <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">::C</span><span class="si">{</span><span class="n">to</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">elif</span> <span class="n">op_type</span> <span class="o">==</span> <span class="s2">&quot;Transpose&quot;</span><span class="p">:</span>
                <span class="n">perm</span> <span class="o">=</span> <span class="n">_get</span><span class="p">(</span><span class="s2">&quot;perm&quot;</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">or</span> <span class="s2">&quot;?&quot;</span>
                <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">::T</span><span class="si">{</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="n">perm</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">elif</span> <span class="n">op_type</span> <span class="o">==</span> <span class="s2">&quot;Shape&quot;</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">_get</span><span class="p">(</span><span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">_get</span><span class="p">(</span><span class="s2">&quot;end&quot;</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
                <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">::Shape</span><span class="si">{</span><span class="n">start</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">end</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">elif</span> <span class="n">op_type</span> <span class="o">==</span> <span class="s2">&quot;Size&quot;</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">::Size&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">short</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Reshape&quot;</span><span class="p">:</span> <span class="s2">&quot;RSh&quot;</span><span class="p">,</span> <span class="s2">&quot;Squeeze&quot;</span><span class="p">:</span> <span class="s2">&quot;Sq&quot;</span><span class="p">,</span> <span class="s2">&quot;Unsqueeze&quot;</span><span class="p">:</span> <span class="s2">&quot;UnSq&quot;</span><span class="p">}[</span><span class="n">op_type</span><span class="p">]</span>
                <span class="n">cst</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">compute_constant</span><span class="p">(</span>
                        <span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">exc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">only_array</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_empty</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">else</span> <span class="kc">None</span>
                <span class="p">)</span>
                <span class="n">name</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">::</span><span class="si">{</span><span class="n">short</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">if</span> <span class="n">cst</span> <span class="ow">is</span> <span class="kc">None</span>
                    <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">::</span><span class="si">{</span><span class="n">short</span><span class="si">}{</span><span class="s1">&#39;x&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="n">cst</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">output_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_onx_</span><span class="si">{</span><span class="n">op_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="si">}</span><span class="s2">_&quot;</span>
            <span class="k">if</span> <span class="n">inputs</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="c1"># The new name tries to keep track of the first input,</span>
                <span class="c1"># usually the most meaningful.</span>
                <span class="n">lower</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">lower</span><span class="si">}{</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">5</span><span class="p">:]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">if</span> <span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_onx_&quot;</span><span class="p">)</span>
                    <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">lower</span><span class="si">}{</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">output_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">lower</span><span class="p">]</span> <span class="k">if</span> <span class="n">outputs</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">lower</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">outputs</span><span class="p">)]</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">output_names</span><span class="p">]</span>

<div class="viewcode-block" id="GraphBuilder.make_node">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.make_node">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_node</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">op_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
        <span class="n">outputs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">domain</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">attributes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">AttributeProto</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">check</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">do_not_remove</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">insert_position</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata_props</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a node in the graph.</span>

<span class="sd">        :param op_type: operator type</span>
<span class="sd">        :param inputs: input names</span>
<span class="sd">        :param outputs: output names, may be None, in that case,</span>
<span class="sd">            the builder chooses them for the user</span>
<span class="sd">        :param domain: domain</span>
<span class="sd">        :param attributes: list of attributes to add as AttributeProto</span>
<span class="sd">        :param check: do some verification</span>
<span class="sd">        :param name: node name</span>
<span class="sd">        :param sts: if not specified, tries to set the shape and the type of</span>
<span class="sd">            the new results aftr the node is added, it is not possible</span>
<span class="sd">            for every node, there is no tool which determines the output shape</span>
<span class="sd">            of just one node</span>
<span class="sd">        :param do_not_remove: prevent this node from being removed</span>
<span class="sd">        :param insert_position: insert the node at the end (None) or</span>
<span class="sd">            at the top (HEAD).</span>
<span class="sd">        :param kwargs: additional attributes to add the node</span>
<span class="sd">        :param metadata_props: additional information to store into the node</span>
<span class="sd">        :return: output names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_local_function</span> <span class="ow">and</span> <span class="n">domain</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_node-f?] </span><span class="si">{</span><span class="n">op_type</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">domain</span><span class="si">}</span><span class="s2">] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span><span class="si">}</span><span class="s2">) -&gt; </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">assert</span> <span class="s2">&quot;.&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">op_type</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;&#39;.&#39; not allowed in operator &#39;</span><span class="si">{</span><span class="n">domain</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">op_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
        <span class="k">assert</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;None&quot;</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;It is good practice to give every node a name so that is &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;easier to see where this node is created but name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;and op_type=</span><span class="si">{</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">attributes</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Only attributes or kwargs can be filled for node </span><span class="si">{</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">.&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">outputs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;outputs=</span><span class="si">{</span><span class="n">outputs</span><span class="si">}</span><span class="s2"> must be &gt; 0.&quot;</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op_type</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">op_type</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">op_type</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">output_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_names</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">op_type</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">output_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">outputs</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output_names</span> <span class="o">=</span> <span class="n">outputs</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">inputs</span><span class="p">]</span>

        <span class="n">inputs</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_partial_rewrite_opset_version</span><span class="p">(</span>
            <span class="n">op_type</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">domain</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.1.make_node]&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_debug_string_inputs</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span><span class="w"> </span><span class="n">output_names</span><span class="p">)</span><span class="si">}</span><span class="s2">] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">op_type</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">inputs</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="n">outputs</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">op_type</span> <span class="o">==</span> <span class="s2">&quot;Identity&quot;</span> <span class="ow">and</span> <span class="n">inputs</span> <span class="o">==</span> <span class="n">output_names</span><span class="p">:</span>
            <span class="c1"># No need.</span>
            <span class="k">return</span> <span class="n">output_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">op_type</span> <span class="o">==</span> <span class="s2">&quot;Concat&quot;</span><span class="p">:</span>
            <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">inputs</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">types</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">types</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;All inputs must have the same rank for Concat, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;types=</span><span class="si">{</span><span class="n">types</span><span class="si">}</span><span class="s2">, inputs=</span><span class="si">{</span><span class="n">inputs</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">check</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="n">inputs</span><span class="si">}</span><span class="s2">, op_type=</span><span class="si">{</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                    <span class="c1"># Optional input.</span>
                    <span class="k">continue</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Input </span><span class="si">{</span><span class="n">i</span><span class="si">!r}</span><span class="s2"> does not exist for operator </span><span class="si">{</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;inputs=</span><span class="si">{</span><span class="n">inputs</span><span class="si">}</span><span class="s2">, outputs=</span><span class="si">{</span><span class="n">outputs</span><span class="si">}</span><span class="s2">, name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">)</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">output_names</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
                    <span class="n">i</span><span class="p">,</span> <span class="nb">str</span>
                <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="n">output_names</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                    <span class="c1"># Optional output.</span>
                    <span class="k">continue</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Output </span><span class="si">{</span><span class="n">i</span><span class="si">!r}</span><span class="s2"> already exists for operator </span><span class="si">{</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">), output_names=</span><span class="si">{</span><span class="n">output_names</span><span class="si">}</span><span class="s2">, inputs=</span><span class="si">{</span><span class="n">inputs</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">check</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Input </span><span class="si">{</span><span class="n">i</span><span class="si">!r}</span><span class="s2"> has no known shape.&quot;</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Input </span><span class="si">{</span><span class="n">i</span><span class="si">!r}</span><span class="s2"> has no known type.&quot;</span>

        <span class="k">if</span> <span class="n">do_not_remove</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_node_name</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;_DONOTREMOVE_</span><span class="si">{</span><span class="n">name</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_node_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_op_type</span><span class="p">(</span>
            <span class="n">op_type</span><span class="p">,</span>
            <span class="n">inputs</span><span class="p">,</span>
            <span class="n">outputs</span><span class="p">,</span>
            <span class="n">domain</span><span class="o">=</span><span class="n">domain</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">attributes</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># break?</span>
        <span class="c1"># if op_type == &quot;Sub&quot;:</span>
        <span class="c1">#     print(&quot;op_type&quot;, op_type, inputs, output_names)</span>
        <span class="c1">#     raise AssertionError(f&quot;MANUAL BREAK{self.get_debug_msg()}&quot;)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_node_output</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_node_output</span> <span class="ow">in</span> <span class="n">output_names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Stop requested as </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_debug_node_output</span><span class="si">!r}</span><span class="s2"> appears in &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">op_type</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span><span class="si">}</span><span class="s2">) -&gt; </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_node_type</span> <span class="ow">and</span> <span class="n">op_type</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_node_type</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Stop requested as </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_debug_node_type</span><span class="si">!r}</span><span class="s2"> appears in &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">op_type</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span><span class="si">}</span><span class="s2">) -&gt; </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">kwargs=</span><span class="si">{</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># next</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">oh</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span><span class="n">op_type</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">output_names</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">domain</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">iti</span> <span class="o">=</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">]</span>
            <span class="n">ito</span> <span class="o">=</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="k">else</span> <span class="n">outputs</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;A node </span><span class="si">{</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2"> cannot be created with &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;inputs=</span><span class="si">{</span><span class="n">inputs</span><span class="si">}</span><span class="s2"> (types=</span><span class="si">{</span><span class="n">iti</span><span class="si">}</span><span class="s2">), outputs=</span><span class="si">{</span><span class="n">outputs</span><span class="si">}</span><span class="s2"> (types=</span><span class="si">{</span><span class="n">ito</span><span class="si">}</span><span class="s2">), &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;domain=</span><span class="si">{</span><span class="n">domain</span><span class="si">!r}</span><span class="s2">, kwargs=</span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">))</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Repeated outputs for node </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">)</span><span class="si">}</span><span class="s2">) -&gt; &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">metadata_props</span><span class="p">:</span>
            <span class="n">oh</span><span class="o">.</span><span class="n">set_metadata_props</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">metadata_props</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">attributes</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;Constant&quot;</span><span class="p">,</span> <span class="s2">&quot;ConstantOfShape&quot;</span><span class="p">}:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">t</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">constant_size</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;A node Constant is created with a size </span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s2"> greater than &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;the limit </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">constant_size</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="c1"># A exact constant may be already existing,</span>
            <span class="c1"># In that case, we just return an identity node.</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_exact_same_constant</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.2.make_node] &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;duplicated constant detected for &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">oh</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
                    <span class="s2">&quot;Identity&quot;</span><span class="p">,</span>
                    <span class="p">[</span><span class="n">origin</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_node_name</span><span class="p">(</span><span class="s2">&quot;.make_node&quot;</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">constants_alias_</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_constant_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># constant handling, shape, type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_node_set_type_shape_constant</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">sts</span><span class="o">=</span><span class="n">sts</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.3.make_node] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_debug_string_inputs</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">output_names</span><span class="p">)</span><span class="si">}</span><span class="s2">] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># shape inference</span>
        <span class="n">shape_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simple_update_value_shape_with_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># add the node</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">o</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;make_node_</span><span class="si">{</span><span class="n">op_type</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">o</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">insert_position</span> <span class="o">==</span> <span class="s2">&quot;HEAD&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">shape_set</span> <span class="ow">or</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="c1"># second try</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_node_set_type_shape</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="n">node</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">+=</span> <span class="s2">&quot;.</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_shape_type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">output_names</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_another_pass_at_shape_inference</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_make_node_set_type_shape</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_info_shape_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
            <span class="n">st</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;-T</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="si">}</span><span class="s2">:&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;T?:&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
                <span class="n">st</span> <span class="o">+=</span> <span class="s2">&quot;x&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">o</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
                <span class="n">st</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;R</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">last_added_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_partial_rewrite_opset_version</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">op_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">domain</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="n">domain</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">opset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">op_type</span> <span class="o">==</span> <span class="s2">&quot;Unsqueeze&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">opset</span> <span class="o">&lt;</span> <span class="mi">13</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
                        <span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
                    <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type for axis=</span><span class="si">{</span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> and operator Unsqueeze&quot;</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;axes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="p">[</span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="k">else</span> <span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="p">)</span>
                    <span class="n">inputs</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">opset</span> <span class="o">&gt;=</span> <span class="mi">13</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_initializer</span><span class="p">(</span>
                        <span class="s2">&quot;&quot;</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;axes&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
                        <span class="n">source</span><span class="o">=</span><span class="s2">&quot;GraphBuilder._partial_rewrite_opset_version.axes&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;axes&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">kwargs</span>

<div class="viewcode-block" id="GraphBuilder.get_attribute">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.get_attribute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_attribute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">NodeProto</span><span class="p">,</span> <span class="n">att_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">exc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AttributeProto</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an attribute for a node.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">att_name</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">att</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">exc</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unable to find attribute </span><span class="si">{</span><span class="n">att_name</span><span class="si">!r}</span><span class="s2"> for node &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;type </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2"> in node </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="GraphBuilder.get_attribute_with_default">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.get_attribute_with_default">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_attribute_with_default</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">NodeProto</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">default_value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an attribute or its default value if missing.</span>

<span class="sd">        :param node: node</span>
<span class="sd">        :param name: attribute name</span>
<span class="sd">        :param default_value: default value</span>
<span class="sd">        :return: value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">INT</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">att</span><span class="o">.</span><span class="n">i</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">INTS</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">ints</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">att</span><span class="o">.</span><span class="n">f</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">FLOATS</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">floats</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">STRING</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">att</span><span class="o">.</span><span class="n">s</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Not implemented for attribute name </span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, attribute=</span><span class="si">{</span><span class="n">att</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">default_value</span></div>


<div class="viewcode-block" id="GraphBuilder.get_attributes_with_default">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.get_attributes_with_default">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_attributes_with_default</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">NodeProto</span><span class="p">,</span> <span class="o">**</span><span class="n">default_values</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns int or float attributes. If missing, the default value is returned</span>
<span class="sd">        if it is not None.</span>

<span class="sd">        :param node: node</span>
<span class="sd">        :param default_values: default values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">default_values</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">INT</span><span class="p">:</span>
                    <span class="n">res</span><span class="p">[</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">att</span><span class="o">.</span><span class="n">i</span>
                <span class="k">elif</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">INTS</span><span class="p">:</span>
                    <span class="n">res</span><span class="p">[</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">ints</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">:</span>
                    <span class="n">res</span><span class="p">[</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">att</span><span class="o">.</span><span class="n">f</span>
                <span class="k">elif</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">FLOATS</span><span class="p">:</span>
                    <span class="n">res</span><span class="p">[</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">floats</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">STRING</span><span class="p">:</span>
                    <span class="n">res</span><span class="p">[</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">att</span><span class="o">.</span><span class="n">s</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Not implemented for attribute name </span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, attribute=</span><span class="si">{</span><span class="n">att</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">default_values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">res</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_update_other_builder_local_function_before_merging</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">builder</span><span class="p">:</span> <span class="s2">&quot;GraphBuilder&quot;</span><span class="p">,</span> <span class="n">merge_allowed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">):</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_check_</span><span class="p">():</span>
            <span class="n">local_domains</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">builder</span><span class="o">.</span><span class="n">functions</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">builder</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">domain</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">local_domains</span>
                    <span class="ow">or</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="p">)</span> <span class="ow">in</span> <span class="n">builder</span><span class="o">.</span><span class="n">functions</span>
                    <span class="ow">or</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="p">)</span> <span class="ow">in</span> <span class="n">builder</span><span class="o">.</span><span class="n">functions_builder</span>
                <span class="p">),</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Node </span><span class="si">{</span><span class="n">builder</span><span class="o">.</span><span class="n">pretty_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2"> not found in </span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="n">builder</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;or </span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="n">builder</span><span class="o">.</span><span class="n">functions_builder</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;local_domains=</span><span class="si">{</span><span class="n">local_domains</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">builder</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">builder</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">assert</span> <span class="n">key</span> <span class="o">==</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;disrepancy </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> vs </span><span class="si">{</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">builder</span><span class="o">.</span><span class="n">_check_function_order</span><span class="p">()</span>

        <span class="n">_check_</span><span class="p">()</span>
        <span class="n">needs_renaming</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">builder</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">builder</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="ow">not</span> <span class="n">merge_allowed</span>
                    <span class="ow">or</span> <span class="ow">not</span> <span class="n">same_function_proto</span><span class="p">(</span><span class="n">builder</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                <span class="p">):</span>
                    <span class="c1"># needs rewriting</span>
                    <span class="n">needs_renaming</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="n">replacements</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">domain</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">needs_renaming</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="n">domain</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_r</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">r&quot;</span>
            <span class="k">while</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">candidate</span> <span class="o">=</span> <span class="n">domain</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_r</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">r&quot;</span>
            <span class="n">replacements</span><span class="p">[</span><span class="n">domain</span><span class="p">,</span> <span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate</span>

        <span class="k">if</span> <span class="n">replacements</span><span class="p">:</span>
            <span class="n">builder</span><span class="o">.</span><span class="n">rename_in_local_functions</span><span class="p">(</span><span class="n">replacements</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">builder</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">replacements</span><span class="p">:</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="n">replacements</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="n">node</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">new_key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">node</span><span class="o">.</span><span class="n">op_type</span> <span class="o">=</span> <span class="n">new_key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span><span class="p">:</span>
                    <span class="n">builder</span><span class="o">.</span><span class="n">_rename_local_functions_in_graph</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">replacements</span><span class="p">)</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">replacements</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">builder</span><span class="o">.</span><span class="n">functions</span><span class="p">)),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The builder has some remaining functions it should not have, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;replacements=</span><span class="si">{</span><span class="n">replacements</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;builder.functions=</span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="n">builder</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">needs_renaming</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">builder</span><span class="o">.</span><span class="n">functions</span><span class="p">)),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The builder has some remaining functions with the same name, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;replacements=</span><span class="si">{</span><span class="n">replacements</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;needs_renaming=</span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="n">needs_renaming</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">_check_</span><span class="p">()</span>

<div class="viewcode-block" id="GraphBuilder.make_nodes">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.make_nodes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_nodes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">builder</span><span class="p">:</span> <span class="s2">&quot;GraphBuilder&quot;</span><span class="p">,</span>
        <span class="n">input_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">function_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">FunctionOptions</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">optimize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">force_rename_with_prefix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends all nodes and initializers from another builder.</span>
<span class="sd">        Handles the renaming of results.</span>
<span class="sd">        The content stored in &#39;builder&#39; is modified inplace to avoid copying.</span>

<span class="sd">        :param builder: other builder</span>
<span class="sd">        :param input_names: input names</span>
<span class="sd">        :param output_names: output names</span>
<span class="sd">        :param prefix: prefix all name from this builder if `function_options` is None</span>
<span class="sd">        :param function_options: defines how to create a local function if needed</span>
<span class="sd">        :param optimize: optimize the function</span>
<span class="sd">        :param force_rename_with_prefix: even if a parameter name should be renamed,</span>
<span class="sd">            the prefix *name* is used</span>
<span class="sd">        :return: output names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_other_builder_local_function_before_merging</span><span class="p">(</span>
            <span class="n">builder</span><span class="p">,</span> <span class="n">merge_allowed</span><span class="o">=</span><span class="n">function_options</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">function_options</span><span class="o">.</span><span class="n">merge_allowed</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">builder</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_function</span><span class="p">(</span>
                <span class="n">f</span><span class="p">,</span>
                <span class="n">rename_allowed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">merge_allowed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">builder</span><span class="o">=</span><span class="n">builder</span><span class="o">.</span><span class="n">functions_builder</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">function_options</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">function_options</span><span class="o">.</span><span class="n">export_as_function</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_local_function</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_nodes-f] &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;function_options=</span><span class="si">{</span><span class="n">function_options</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;optimize=</span><span class="si">{</span><span class="n">optimize</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_nodes-f] input_names=</span><span class="si">{</span><span class="n">input_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">new_inits</span><span class="p">,</span> <span class="p">(</span><span class="n">fdomain</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_local_function</span><span class="p">(</span>
                <span class="n">builder</span><span class="p">,</span> <span class="n">function_options</span><span class="o">=</span><span class="n">function_options</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="n">optimize</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_local_function</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_nodes-f] new_inits=</span><span class="si">{</span><span class="n">new_inits</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">builder</span><span class="o">.</span><span class="n">output_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_names</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Number of output mismatch: output_names=</span><span class="si">{</span><span class="n">output_names</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;builder.output_names=</span><span class="si">{</span><span class="n">builder</span><span class="o">.</span><span class="n">output_names</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
                <span class="n">fname</span><span class="p">,</span>
                <span class="p">[</span><span class="o">*</span><span class="n">input_names</span><span class="p">,</span> <span class="o">*</span><span class="n">new_inits</span><span class="p">],</span>
                <span class="n">output_names</span><span class="p">,</span>
                <span class="n">domain</span><span class="o">=</span><span class="n">fdomain</span><span class="p">,</span>
                <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="n">fname</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Shape information, needs to handle multiple outputs</span>
            <span class="c1"># hopefully, the interpreter fills this information with what it knows</span>
            <span class="c1"># fproto = self.functions[fdomain, fname]</span>
            <span class="c1"># for o, no in zip(fproto.output, output_names):</span>
            <span class="c1">#    if builder.has_shape(o):</span>
            <span class="c1">#        shape = builder.get_shape(o)</span>
            <span class="c1">#        if None in shape:</span>
            <span class="c1">#            self.set_rank(no, len(shape))</span>
            <span class="c1">#        else:</span>
            <span class="c1">#            self.set_shape(no, shape)</span>
            <span class="c1">#    if builder.has_type(o):</span>
            <span class="c1">#        self.set_type(no, builder.get_type(o))</span>

            <span class="k">if</span> <span class="n">fdomain</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">[</span><span class="n">fdomain</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">renaming</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">init</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">builder</span><span class="o">.</span><span class="n">initializers_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">init</span> <span class="ow">in</span> <span class="n">builder</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="p">:</span>
                    <span class="c1"># Its copy already exists.</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">init</span> <span class="ow">in</span> <span class="n">builder</span><span class="o">.</span><span class="n">_parameter_norename</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">init</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">init</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">force_rename_with_prefix</span><span class="p">:</span>
                            <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">force_rename_with_prefix</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Parameter </span><span class="si">{</span><span class="n">init</span><span class="si">!r}</span><span class="s2"> was renamed into </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;but it already exists</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">init</span><span class="p">),</span> <span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Parameter </span><span class="si">{</span><span class="n">init</span><span class="si">!r}</span><span class="s2"> must be renamed as another one &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;already exists</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">init</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">renaming</span><span class="p">[</span><span class="n">init</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">TensorProto</span><span class="p">):</span>
                    <span class="n">value</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="s2">&quot;FakeTensor&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)),</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;FakeTensor </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> cannot be an initializer </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="n">src</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;&quot;</span>
                    <span class="k">if</span> <span class="n">init</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">builder</span><span class="o">.</span><span class="n">initializers_dict_sources</span>
                    <span class="ow">or</span> <span class="ow">not</span> <span class="n">builder</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">init</span><span class="p">]</span><span class="o">.</span><span class="n">source</span>
                    <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;##</span><span class="si">{</span><span class="n">builder</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">init</span><span class="p">]</span><span class="o">.</span><span class="n">source</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_initializer</span><span class="p">(</span>
                    <span class="n">name</span><span class="p">,</span>
                    <span class="n">value</span><span class="p">,</span>
                    <span class="n">itype</span><span class="o">=</span><span class="n">builder</span><span class="o">.</span><span class="n">_known_types</span><span class="p">[</span><span class="n">init</span><span class="p">],</span>
                    <span class="n">shape</span><span class="o">=</span><span class="n">builder</span><span class="o">.</span><span class="n">_known_shapes</span><span class="p">[</span><span class="n">init</span><span class="p">],</span>
                    <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;GraphBuilder.make_nodes/from</span><span class="si">{</span><span class="n">init</span><span class="si">}{</span><span class="n">src</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">allow_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">builder</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">make_dynamic_object</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
                <span class="n">builder</span><span class="o">.</span><span class="n">inputs</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Inconsistency between input_names=</span><span class="si">{</span><span class="n">input_names</span><span class="si">}</span><span class="s2"> and inputs=</span><span class="si">{</span><span class="n">builder</span><span class="o">.</span><span class="n">inputs</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">input_names</span><span class="p">,</span> <span class="n">builder</span><span class="o">.</span><span class="n">inputs</span><span class="p">):</span>
                <span class="n">new_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">inp</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">renaming</span><span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_name</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span><span class="s2">&quot;Identity&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="p">[</span><span class="n">new_name</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;.make_nodes&quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">builder</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;None&quot;</span><span class="p">),</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;It is good practice to give every node a name so that is &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;easier to see where this node is created but name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;and op_type=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
                <span class="n">new_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">renaming</span><span class="p">[</span><span class="n">builder</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">]</span>
                <span class="n">new_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">o</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">no</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">new_outputs</span><span class="p">):</span>
                    <span class="n">renaming</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">=</span> <span class="n">no</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="p">,</span>
                    <span class="n">new_inputs</span><span class="p">,</span>
                    <span class="n">new_outputs</span><span class="p">,</span>
                    <span class="n">domain</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
                    <span class="n">attributes</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">,</span>
                    <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">no</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">new_outputs</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">builder</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
                        <span class="n">shape</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
                        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">set_rank</span><span class="p">(</span><span class="n">no</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">set_shape</span><span class="p">(</span><span class="n">no</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">builder</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">no</span><span class="p">,</span> <span class="n">builder</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">builder</span><span class="o">.</span><span class="n">has_device</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_device</span><span class="p">(</span><span class="n">no</span><span class="p">,</span> <span class="n">builder</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>

            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">builder</span><span class="o">.</span><span class="n">outputs</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Inconsistency between </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">builder</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;output_names=</span><span class="si">{</span><span class="n">output_names</span><span class="si">}</span><span class="s2"> and &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;outputs=</span><span class="si">{</span><span class="n">builder</span><span class="o">.</span><span class="n">outputs</span><span class="si">}</span><span class="s2">, renaming=</span><span class="si">{</span><span class="n">renaming</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">out</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">output_names</span><span class="p">,</span> <span class="n">builder</span><span class="o">.</span><span class="n">outputs</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span><span class="s2">&quot;Identity&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">renaming</span><span class="p">[</span><span class="n">out</span><span class="o">.</span><span class="n">name</span><span class="p">]],</span> <span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;.make_nodes&quot;</span><span class="p">)</span>

        <span class="c1"># opsets and domains</span>
        <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">builder</span><span class="o">.</span><span class="n">opsets</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">==</span> <span class="n">builder</span><span class="o">.</span><span class="n">opsets</span><span class="p">[</span><span class="n">o</span><span class="p">],</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Opset mismatch for domain </span><span class="si">{</span><span class="n">o</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">builder</span><span class="o">.</span><span class="n">opsets</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
                <span class="k">continue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">output_names</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_build_large_initializers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">external_threshold</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">full_parameter_name</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">subset</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">external_threshold</span><span class="p">,</span> <span class="nb">int</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">external_threshold</span><span class="p">)</span><span class="si">}</span><span class="s2"> for external_threshold&quot;</span>
        <span class="n">new_inits</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">large_inits</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">subset</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">subset</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">full_parameter_name</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="c1"># Those parameters are present under another name already.</span>
                <span class="k">continue</span>
            <span class="n">doc_string</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">source</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">source</span>
                <span class="k">else</span> <span class="s2">&quot;&quot;</span>
            <span class="p">)</span>
            <span class="n">itype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">vshape</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>  <span class="c1"># TensorProto</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">is_static_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="ow">or</span> <span class="n">shape</span> <span class="o">==</span> <span class="n">vshape</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unexpected shape for initializer </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2">, shape=</span><span class="si">{</span><span class="n">shape</span><span class="si">!r}</span><span class="s2">, itype=</span><span class="si">{</span><span class="n">itype</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;initializer shape=</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, dtype=</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">vshape</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem_size</span><span class="p">(</span><span class="n">itype</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="n">external_threshold</span><span class="p">:</span>
                <span class="n">new_inits</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">location</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;#</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">nt</span> <span class="o">=</span> <span class="n">make_large_tensor_proto</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">itype</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
                <span class="n">nt</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">+=</span> <span class="n">doc_string</span>
                <span class="n">new_inits</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">nt</span>
                <span class="n">large_inits</span><span class="p">[</span><span class="n">location</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">return</span> <span class="n">new_inits</span><span class="p">,</span> <span class="n">large_inits</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_build_initializers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">large_model</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">switch_low_high</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">external_threshold</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">full_parameter_name</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">subset</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">TensorProto</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">TensorProto</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds initializers.</span>

<span class="sd">        :param large_model: build with a large container</span>
<span class="sd">        :param switch_low_high: invert low, high precision</span>
<span class="sd">        :param external_threshold: size to use when moving a tensor to the list of tensors</span>
<span class="sd">            stored outside the model, if can be False for none of them, true for all of them</span>
<span class="sd">            or a number, if the threshold is specified and large_model is False,</span>
<span class="sd">            then all tensors above this threshold are ignored</span>
<span class="sd">        :param full_parameter_name: keeps the full name for the parameters or not</span>
<span class="sd">        :param subset: only consider a subset of the initializers</span>
<span class="sd">        :return: a list of tensors to stored in the model,</span>
<span class="sd">            another list to tensors stored outside the model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">begin</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._build_initializers] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;start with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">)</span><span class="si">}</span><span class="s2"> initializers, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;large_model=</span><span class="si">{</span><span class="n">large_model</span><span class="si">}</span><span class="s2">, external_threshold=</span><span class="si">{</span><span class="n">external_threshold</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">init_dict</span><span class="p">,</span> <span class="n">large_inits</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_large_initializers</span><span class="p">(</span>
                <span class="n">external_threshold</span><span class="p">,</span> <span class="n">full_parameter_name</span><span class="o">=</span><span class="n">full_parameter_name</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="n">subset</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">large_model</span>
            <span class="k">else</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">,</span> <span class="p">{})</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">switch_low_high</span><span class="p">:</span>
            <span class="c1"># Let&#39;s try to minimize the time.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._build_initializers] switch low/high order&quot;</span><span class="p">)</span>
            <span class="n">initializer</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">init_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">subset</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">subset</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">full_parameter_name</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="c1"># Those parameters are present under another name already.</span>
                    <span class="k">continue</span>
                <span class="n">doc_string</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">source</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span>
                    <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">source</span>
                    <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">TensorProto</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._build_initializers] &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;TensorProto-</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">data_type</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span><span class="si">}</span><span class="s2">]&quot;</span>
                        <span class="p">)</span>
                    <span class="n">v</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">+=</span> <span class="n">doc_string</span>
                    <span class="n">initializer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._build_initializers] &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&gt;-</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">]&quot;</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">itype</span> <span class="o">=</span> <span class="n">dtype_to_tensor_dtype</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">itype</span> <span class="ow">in</span> <span class="p">{</span>
                        <span class="n">TensorProto</span><span class="o">.</span><span class="n">BOOL</span><span class="p">,</span>
                        <span class="n">TensorProto</span><span class="o">.</span><span class="n">STRING</span><span class="p">,</span>
                        <span class="n">TensorProto</span><span class="o">.</span><span class="n">UNDEFINED</span><span class="p">,</span>
                        <span class="n">TensorProto</span><span class="o">.</span><span class="n">COMPLEX64</span><span class="p">,</span>
                        <span class="n">TensorProto</span><span class="o">.</span><span class="n">COMPLEX128</span><span class="p">,</span>
                        <span class="nb">getattr</span><span class="p">(</span><span class="n">TensorProto</span><span class="p">,</span> <span class="s2">&quot;UINT4&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                        <span class="nb">getattr</span><span class="p">(</span><span class="n">TensorProto</span><span class="p">,</span> <span class="s2">&quot;INT4&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                    <span class="p">}:</span>
                        <span class="n">t</span> <span class="o">=</span> <span class="n">from_array_extended</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
                        <span class="n">t</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">+=</span> <span class="n">doc_string</span>
                        <span class="n">initializer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                        <span class="k">continue</span>

                    <span class="n">from_np</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
                    <span class="c1"># This should not happen.</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">from_array_extended</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">+=</span> <span class="n">doc_string</span>
                    <span class="n">initializer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">):</span>
                    <span class="c1"># This should not happen.</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">from_array_extended</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">+=</span> <span class="n">doc_string</span>
                    <span class="n">initializer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
                        <span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span>
                    <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;tensor </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2"> has un unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">assert</span> <span class="s2">&quot;FakeTensor&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span>
                        <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;tensor </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2"> cannot be a FakeTensor: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">from_np</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">itype</span> <span class="o">=</span> <span class="n">dtype_to_tensor_dtype</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

                <span class="c1"># How to avoid a copy?</span>
                <span class="k">if</span> <span class="n">from_np</span><span class="p">:</span>
                    <span class="n">tensor</span> <span class="o">=</span> <span class="n">TensorProto</span><span class="p">()</span>
                    <span class="n">tensor</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">k</span>
                    <span class="n">tensor</span><span class="o">.</span><span class="n">dims</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">tensor</span><span class="o">.</span><span class="n">data_type</span> <span class="o">=</span> <span class="n">itype</span>
                    <span class="n">tensor</span><span class="o">.</span><span class="n">raw_data</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">maybe_disable_fake_tensor_mode</span><span class="p">():</span>
                        <span class="n">tensor</span> <span class="o">=</span> <span class="n">proto_from_array</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="s2">&quot;doc_string&quot;</span><span class="p">):</span>
                    <span class="n">tensor</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">+=</span> <span class="n">doc_string</span>
                <span class="n">initializer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="n">begin</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._build_initializers] &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;done in </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">begin</span><span class="si">}</span><span class="s2">s &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">initializer</span><span class="p">)</span><span class="si">}</span><span class="s2"> initializers, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">large_inits</span><span class="p">)</span><span class="si">}</span><span class="s2"> large initializers&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">initializer</span><span class="p">,</span> <span class="n">large_inits</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">large_model</span>
        <span class="p">),</span> <span class="s2">&quot;_build_initializers not implemented when large_model is True&quot;</span>
        <span class="n">large_inits</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">init_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">subset</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">subset</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">full_parameter_name</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="c1"># Those parameters are present under another name already.</span>
                <span class="k">continue</span>
            <span class="n">doc_string</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">source</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">source</span>
                <span class="k">else</span> <span class="s2">&quot;&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">TensorProto</span><span class="p">):</span>
                <span class="n">v</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">+=</span> <span class="n">doc_string</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                <span class="c1"># no string tensor</span>
                <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
                <span class="n">t</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">+=</span> <span class="n">doc_string</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._build_initializers]&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;from_array_extended:</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">]&quot;</span>
                    <span class="p">)</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">from_array_extended</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
                <span class="n">t</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">+=</span> <span class="n">doc_string</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unable to convert initializer </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2"> with type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">}</span><span class="s2"> into a TensorProto.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">begin</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._build_initializers] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;done in </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">begin</span><span class="si">}</span><span class="s2">s &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="si">}</span><span class="s2"> initializers, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">large_inits</span><span class="p">)</span><span class="si">}</span><span class="s2"> large initializers&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">,</span> <span class="n">large_inits</span>

<div class="viewcode-block" id="GraphBuilder.get_initializer_size">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.get_initializer_size">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_initializer_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the size of an initializer.</span>

<span class="sd">        :param name: name</span>
<span class="sd">        :return: size</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Initializer </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> was not found.&quot;</span>
        <span class="n">init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="s2">&quot;numel&quot;</span><span class="p">):</span>
            <span class="c1"># torch.Tensor</span>
            <span class="k">return</span> <span class="n">init</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="s2">&quot;size&quot;</span><span class="p">):</span>
            <span class="c1"># numpy array</span>
            <span class="k">return</span> <span class="n">init</span><span class="o">.</span><span class="n">size</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="s2">&quot;size&quot;</span><span class="p">):</span>
            <span class="c1"># TensorProto</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">init</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">init</span><span class="p">)</span><span class="si">}</span><span class="s2"> for initializer </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="GraphBuilder.get_debug_msg">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.get_debug_msg">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_debug_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a string providing as much information as possible</span>
<span class="sd">        to help the developper understand why a conversion failed.</span>

<span class="sd">        :param limit: limit the string if the model is big</span>
<span class="sd">        :return: many pieces of informations about the on going conversion</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_align</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">length</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">s</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_dtype</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">dtype</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;data_type&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">data_type</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dtype unknown for type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_shape</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">dtype</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;dims&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dtype unknown for type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_size</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;numel&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;size&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;dims&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">dims</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Size unknown for type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_values</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;detach&quot;</span><span class="p">):</span>

                <span class="k">def</span><span class="w"> </span><span class="nf">is_allow_non_fake_inputs_enabled</span><span class="p">():</span>
                    <span class="kn">from</span><span class="w"> </span><span class="nn">torch._guards</span><span class="w"> </span><span class="kn">import</span> <span class="n">detect_fake_mode</span>

                    <span class="k">return</span> <span class="n">detect_fake_mode</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">is_allow_non_fake_inputs_enabled</span><span class="p">():</span>
                    <span class="k">return</span> <span class="s2">&quot;FakeTensorMode enabled&quot;</span>
                <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;size&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;dims&quot;</span><span class="p">):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">onh</span><span class="o">.</span><span class="n">to_array</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Values unknown for type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;--DEBUG--&quot;</span><span class="p">,</span> <span class="s2">&quot;-- to print the exported program: PRINT_EXPORTED_PROGRAM=1&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">]</span>
        <span class="n">hs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="n">hs</span><span class="si">}</span><span class="s2">] Message starts, there are &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">)</span><span class="si">}</span><span class="s2"> initializers, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> nodes, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span><span class="si">}</span><span class="s2"> inputs, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span><span class="si">}</span><span class="s2"> outputs.&quot;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;input_names=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">input_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;output_names=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_implicit_decisions</span><span class="p">:</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;--IMPLICIT DECISIONS--&quot;</span><span class="p">)</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_implicit_decisions</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;--LOCAL FUNCTIONS--&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    </span><span class="si">{</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">input</span><span class="si">}</span><span class="s2">) -&gt; </span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">output</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraints_</span><span class="p">:</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;--CONSTRAINTS--&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">assert_sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraints_</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;--SHAPE--&quot;</span><span class="p">)</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;_dynamic_examples=&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">assert_sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_examples</span><span class="o">.</span><span class="n">items</span><span class="p">())):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">v</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> = ERR: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">!r}</span><span class="s2">:</span><span class="si">{</span><span class="nb">getattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;node&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;node=?&#39;</span><span class="p">)</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">10000</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;dynamic_objects=&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">assert_sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="o">.</span><span class="n">items</span><span class="p">())):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">v</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> = ERR: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">!r}</span><span class="s2">:</span><span class="si">{</span><span class="nb">getattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;node&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;node=?&#39;</span><span class="p">)</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">10000</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;dynamic_objects_rev=&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">assert_sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects_rev</span><span class="o">.</span><span class="n">items</span><span class="p">())):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2"> = </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">vv</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vv</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;     tuple&quot;</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">vvv</span> <span class="ow">in</span> <span class="n">vv</span><span class="p">:</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;       </span><span class="si">{</span><span class="n">vvv</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="sa">f</span><span class="s2">&quot;       ERR**: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">vvv</span><span class="p">)</span><span class="si">!r}</span><span class="s2">:&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">getattr</span><span class="p">(</span><span class="n">vvv</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;node&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;node=?&#39;</span><span class="p">)</span><span class="si">!r}</span><span class="s2">&quot;</span>
                                <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;       </span><span class="si">{</span><span class="n">vv</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;       ERR*: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">vv</span><span class="p">)</span><span class="si">!r}</span><span class="s2">:</span><span class="si">{</span><span class="nb">getattr</span><span class="p">(</span><span class="n">vv</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;node&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;node=?&#39;</span><span class="p">)</span><span class="si">!r}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">v</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> = ERR-: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">!r}</span><span class="s2">:</span><span class="si">{</span><span class="nb">getattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;node&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;node=?&#39;</span><span class="p">)</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">10000</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dynamic_dimensions_source=</span><span class="si">{</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;dynamic_dimensions_source_flat=&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source_flat</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;output_dynamic_dimensions_source_flat=&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dynamic_dimensions_source_flat</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dynamic_alias=</span><span class="si">{</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_alias</span><span class="p">)[:</span><span class="mi">10000</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dynamic_shapes=</span><span class="si">{</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="p">)[:</span><span class="mi">10000</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;_known_shapes=</span><span class="si">{</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_known_shapes</span><span class="p">)[:</span><span class="mi">10000</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;_known_types=</span><span class="si">{</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_known_types</span><span class="p">)[:</span><span class="mi">10000</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;_known_devices=</span><span class="si">{</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_known_devices</span><span class="p">)[:</span><span class="mi">10000</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;_context=</span><span class="si">{</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="p">))[:</span><span class="mi">10000</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">short_sh</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span> <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="k">else</span> <span class="n">string_type</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">with_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;_known_value_shape=</span><span class="si">{</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="n">short_sh</span><span class="p">)[:</span><span class="mi">10000</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;_known_constants=</span><span class="si">{</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">assert_sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants_</span><span class="p">))[:</span><span class="mi">10000</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">reminaing_ranks</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_ranks</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_shapes</span>
        <span class="p">}</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;_known_ranks (with no shape)=</span><span class="si">{</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="n">reminaing_ranks</span><span class="w"> </span><span class="p">)[:</span><span class="mi">10000</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;--PARAMETERS--&quot;</span><span class="p">)</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;_parameter_renaming=&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">assert_sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="o">.</span><span class="n">items</span><span class="p">())):</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">v</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">10000</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;--TORCH-USERS--&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">assert_sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_registered_users</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;--TORCH-SHAPES--&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">kk</span><span class="p">,</span> <span class="n">vv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_torch_value</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;    </span><span class="si">{</span><span class="n">kk</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">vv</span><span class="si">}</span><span class="s2"> --- &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">kk</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">kk</span><span class="p">)</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2">:&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">kk</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">kk</span><span class="p">)</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2">:&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">kk</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">kk</span><span class="p">)</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2">:&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">:</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;...&quot;</span><span class="p">)</span>
                <span class="k">break</span>

        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;--ONNX--&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_msg</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;-- </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> --&quot;</span><span class="p">)</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">:</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;...&quot;</span><span class="p">)</span>
                <span class="k">break</span>

        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;-- </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span><span class="si">}</span><span class="s2"> INPUTS&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
            <span class="n">shh</span> <span class="o">=</span> <span class="n">_nice_shape</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">tensor_type</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="n">hs</span><span class="si">}</span><span class="s2">.1.make_tensor_input] </span><span class="si">{</span><span class="n">io</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">io</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">tensor_type</span><span class="o">.</span><span class="n">elem_type</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">shh</span><span class="si">}</span><span class="s2">]&quot;</span>
            <span class="p">)</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;-- </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">)</span><span class="si">}</span><span class="s2"> INITIALIZERS&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">init</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">sval</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">_size</span><span class="p">(</span><span class="n">init</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;:</span><span class="si">{</span><span class="n">_values</span><span class="p">(</span><span class="n">init</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">source</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">source</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span>
                <span class="k">else</span> <span class="s2">&quot;?&quot;</span>
            <span class="p">)</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="n">hs</span><span class="si">}</span><span class="s2">.1.make_initializer] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">_dtype</span><span class="p">(</span><span class="n">init</span><span class="p">)</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">_shape</span><span class="p">(</span><span class="n">init</span><span class="p">)</span><span class="si">}{</span><span class="n">sval</span><span class="si">}</span><span class="s2">] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;- SOURCE: </span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">:</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;...&quot;</span><span class="p">)</span>
                <span class="k">break</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span> <span class="o">==</span> <span class="s2">&quot;Cast&quot;</span><span class="p">:</span>
                <span class="n">ext</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&gt;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ext</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="n">hs</span><span class="si">}</span><span class="s2">.4.make_node] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">_align</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_debug_string_inputs</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="si">}</span><span class="s2">] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">}{</span><span class="n">ext</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;Loop&quot;</span><span class="p">,</span> <span class="s2">&quot;Scan&quot;</span><span class="p">,</span> <span class="s2">&quot;If&quot;</span><span class="p">}:</span>
                <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span><span class="p">:</span>
                        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="n">hs</span><span class="si">}</span><span class="s2">.4.make_node] -- subgraph </span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">...&quot;</span>
                        <span class="p">)</span>
                        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">indent</span><span class="p">(</span><span class="n">pretty_onnx</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">),</span> <span class="s2">&quot;    &quot;</span><span class="p">))</span>
                        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="n">hs</span><span class="si">}</span><span class="s2">.4.make_node] -- subgraph </span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> -- done&quot;</span>
                        <span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">:</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;...&quot;</span><span class="p">)</span>
                <span class="k">break</span>

        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;-- </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span><span class="si">}</span><span class="s2"> OUTPUTS&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
            <span class="n">shh</span> <span class="o">=</span> <span class="n">_nice_shape</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">tensor_type</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="n">hs</span><span class="si">}</span><span class="s2">.1.make_tensor_output] </span><span class="si">{</span><span class="n">io</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">io</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">tensor_type</span><span class="o">.</span><span class="n">elem_type</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">shh</span><span class="si">}</span><span class="s2">]&quot;</span>
            <span class="p">)</span>

        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="n">hs</span><span class="si">}</span><span class="s2">] Message completed, there are &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">)</span><span class="si">}</span><span class="s2"> initializers, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> nodes, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span><span class="si">}</span><span class="s2"> inputs, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span><span class="si">}</span><span class="s2"> outputs.&quot;</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">:</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;############&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;### PARENT ###&quot;</span><span class="p">)</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;############&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">())</span>
        <span class="n">res</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;DUMPMSG&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="s2">&quot;process.graph_module&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_msg</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;DUMPMSG&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">.module.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_debug_msg</span><span class="p">[</span><span class="s2">&quot;process.graph_module&quot;</span><span class="p">]))</span>
            <span class="k">if</span> <span class="s2">&quot;process.graph_module.graph&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_msg</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;DUMPMSG&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">.graph.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_debug_msg</span><span class="p">[</span><span class="s2">&quot;process.graph_module.graph&quot;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="GraphBuilder.process">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph_module</span><span class="p">:</span> <span class="s2">&quot;torch.fx.GraphModule&quot;</span><span class="p">,</span>  <span class="c1"># noqa: F821</span>
        <span class="n">interpreter</span><span class="p">:</span> <span class="s2">&quot;DynamoInterpreter&quot;</span><span class="p">,</span>  <span class="c1"># noqa: F821</span>
        <span class="n">source_lines</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Environment variable ``ONNX_BUILDER_PROGRESS=1`` can be used to show</span>
<span class="sd">        a progress bar on big models.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_debug_msg</span><span class="p">[</span><span class="s2">&quot;process.graph_module&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">graph_module</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_debug_msg</span><span class="p">[</span><span class="s2">&quot;process.graph_module.graph&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">graph_module</span><span class="o">.</span><span class="n">graph</span>

        <span class="c1"># looks into output marked as &quot;alias_of_input&quot;</span>
        <span class="c1"># see https://pytorch.org/functorch/main/_modules/torch/_functorch/aot_autograd.html</span>
        <span class="c1"># in that case, gen_alias_from_base is mixing the input data and the output stride</span>
        <span class="c1"># places = []</span>
        <span class="c1"># for node in graph_module.graph.nodes:</span>
        <span class="c1">#     if node.op == &quot;placeholder&quot;:</span>
        <span class="c1">#         places.append(node)</span>
        <span class="c1"># for node in places:</span>
        <span class="c1">#     with graph_module.graph.inserting_after(node):</span>
        <span class="c1">#         cloned_node = graph_module.graph.call_method(&quot;clone&quot;, args=(node.target,))</span>
        <span class="c1">#         node.replace_all_uses_with(cloned_node)</span>
        <span class="c1"># graph_module.recompile()</span>
        <span class="n">interpreter</span><span class="o">.</span><span class="n">start_graph</span><span class="p">(</span><span class="n">graph_module</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>

        <span class="n">inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">graph_module</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;placeholder&quot;</span><span class="p">:</span>
                <span class="c1"># Not tensor constant are not captured by the exporter.</span>
                <span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">bool</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">users</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">])</span> <span class="k">if</span> <span class="s2">&quot;val&quot;</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">meta</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="n">inputs_to_remove</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">has_users</span><span class="p">,</span> <span class="n">type_value</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">has_users</span> <span class="ow">or</span> <span class="n">type_value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)}:</span>
                <span class="k">break</span>
            <span class="n">inputs_to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ONNX_BUILDER_PROGRESS&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph_module</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">100</span>
        <span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span><span class="w"> </span><span class="nn">tqdm</span>

                <span class="n">loop</span> <span class="o">=</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">graph_module</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)))</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="n">loop</span> <span class="o">=</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">graph_module</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loop</span> <span class="o">=</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">graph_module</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>

        <span class="n">inputs_to_remove</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">inputs_to_remove</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_debug_msg</span><span class="p">[</span><span class="s2">&quot;process.inputs_to_remove&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inputs_to_remove</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">loop</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_print_node</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_print_node</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;-- PRINT-NODE </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> --&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;node.target=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;node.users=</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">users</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;node.name in inputs_to_remove=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">inputs_to_remove</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="s2">&quot;val&quot;</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">meta</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;value type=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">meta</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;placeholder&quot;</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">inputs_to_remove</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">users</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_debug_msg</span><span class="p">[</span><span class="s2">&quot;process.progress&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;node </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">graph_module</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> target=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">interpreter</span><span class="o">.</span><span class="n">run_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">source_lines</span><span class="o">=</span><span class="n">source_lines</span><span class="p">)</span>
        <span class="n">interpreter</span><span class="o">.</span><span class="n">end_graph</span><span class="p">(</span><span class="n">graph_module</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_extend_local_function_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        All the initializers may not be used in the main function.</span>
<span class="sd">        The function filter out all the unused initializers.</span>
<span class="sd">        The functions also filters out the unused local functions.</span>

<span class="sd">        :param proto: function to modify, modified inplace</span>
<span class="sd">        :param functions: other local functions</span>
<span class="sd">        :param initializers_dict: initializers</span>
<span class="sd">        :return: the new proto, the local functions names, and the used initializers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Let&#39;s sort the additional inputs by size, bigger is first.</span>
        <span class="n">used_initializers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_used_initializers</span><span class="p">()</span>
        <span class="n">inits</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_initializer_size</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">used_initializers</span>
        <span class="p">]</span>
        <span class="n">inits</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">inits</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">inits</span><span class="p">]</span>
        <span class="n">inputs_to_add</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">inits</span><span class="p">]</span>
        <span class="n">used_functions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_used_local_functions</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">inputs_to_add</span><span class="p">,</span> <span class="n">used_functions</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_function_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">known_functions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">node</span><span class="p">:</span>
                <span class="c1"># TODO: This is very restrictive. This should be changed.</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">domain</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;ai.onnx.ml&quot;</span><span class="p">,</span> <span class="s2">&quot;com.microsoft&quot;</span><span class="p">,</span> <span class="s2">&quot;ai.onnx.training&quot;</span><span class="p">}</span>
                    <span class="ow">or</span> <span class="s2">&quot;.onnx&quot;</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">domain</span>
                <span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span>
                <span class="k">assert</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">known_functions</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Function </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> is using function </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> not in </span><span class="si">{</span><span class="n">known_functions</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;available functions are </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span><span class="si">}</span><span class="s2">, node=</span><span class="se">\n</span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">known_functions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">domain</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;ai.onnx.ml&quot;</span><span class="p">,</span> <span class="s2">&quot;com.microsoft&quot;</span><span class="p">,</span> <span class="s2">&quot;ai.onnx.training&quot;</span><span class="p">}</span>
                <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;ai&quot;</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="p">)</span> <span class="ow">in</span> <span class="n">known_functions</span>
            <span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Node &#39;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">}</span><span class="s2">&#39; is unknown (</span><span class="si">{</span><span class="n">pretty_onnx</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">), &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;local functions = </span><span class="si">{</span><span class="n">known_functions</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">NodeProto</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">NodeProto</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2"> for node&quot;</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span> <span class="o">!=</span> <span class="s2">&quot;Constant&quot;</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">: unexpected number of attribute in node </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">: wrong attribute type in node </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_constants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;before-inline&quot;</span><span class="p">,</span> <span class="n">add</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants_node_</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_constant</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">prefix</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_constant</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">prefix</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">node</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_constant</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">-[</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">add</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">FunctionProto</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Not implemented for type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">add</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">add</span><span class="o">.</span><span class="n">node</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_constant</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">-[add]&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_to_onnx_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function_options</span><span class="p">,</span> <span class="n">opsets</span><span class="p">,</span> <span class="n">mask_outputs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_local_function</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.to_onnx] export_as_function </span><span class="si">{</span><span class="n">function_options</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.to_onnx] make_function &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">)</span><span class="si">}</span><span class="s2"> inits &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="p">)</span><span class="si">}</span><span class="s2"> params&quot;</span>
            <span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">function_options</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">FunctionOptions</span><span class="o">.</span><span class="n">empty_names</span>
            <span class="ow">and</span> <span class="n">function_options</span><span class="o">.</span><span class="n">domain</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">FunctionOptions</span><span class="o">.</span><span class="n">empty_names</span>
        <span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Function name=</span><span class="si">{</span><span class="n">function_options</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> cannot be empty and &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Function domain=</span><span class="si">{</span><span class="n">function_options</span><span class="o">.</span><span class="n">domain</span><span class="si">!r}</span><span class="s2"> cannot be empty.&quot;</span>
        <span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">function_options</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">function_options</span><span class="o">.</span><span class="n">name</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;The given name </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> is already taken by a local function</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_text</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">function_options</span><span class="o">.</span><span class="n">move_initializer_to_constant</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_local_function</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.to_onnx] move_initializers_to_constant &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">move_initializers_to_constant</span><span class="p">(</span>
                <span class="n">full_parameter_name</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">threshold</span><span class="o">=</span><span class="n">function_options</span><span class="o">.</span><span class="n">external_threshold</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_local_function</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.to_onnx] remaining_initializers &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">)</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="c1"># if self._parameter_renaming: we don&#39;t necessarily need to rename here.</span>
        <span class="c1"># We better not if we want to make this function equivalent to it.</span>
        <span class="n">proto</span> <span class="o">=</span> <span class="n">oh</span><span class="o">.</span><span class="n">make_function</span><span class="p">(</span>
            <span class="n">function_options</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
            <span class="n">function_options</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">],</span>
            <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">mask</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mask_outputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span> <span class="k">if</span> <span class="n">mask</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span>
            <span class="n">opsets</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">function_options</span><span class="o">.</span><span class="n">return_initializer</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">proto</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">proto</span><span class="o">=</span><span class="n">proto</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
                <span class="n">used_functions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_used_local_functions</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">used_functions</span><span class="p">:</span>
                    <span class="n">res</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">used_functions</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="c1"># We need to move the initializers as inputs, we sort them by decresing size</span>
        <span class="n">inits</span><span class="p">,</span> <span class="n">functions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extend_local_function_inputs</span><span class="p">()</span>
        <span class="n">proto</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">inits</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">proto</span><span class="o">=</span><span class="n">proto</span><span class="p">,</span>
            <span class="n">initializers_name</span><span class="o">=</span><span class="n">inits</span><span class="p">,</span>
            <span class="n">initializers_dict</span><span class="o">=</span><span class="p">{</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span> <span class="n">v</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">inits</span><span class="p">)</span>
            <span class="p">},</span>
            <span class="n">initializers_renaming</span><span class="o">=</span><span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">inits</span><span class="p">)</span>
            <span class="p">},</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">functions</span><span class="p">:</span>
            <span class="n">res</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_model_with_parameter_renaming</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">ModelProto</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Some parameters are renamed </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;but there is no initializer</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="c1"># We rename.</span>
        <span class="n">nodes_add</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">setp</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>

            <span class="n">needs_rewrite</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span><span class="p">:</span>
                    <span class="n">hidden</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hidden_inputs</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">hidden</span> <span class="o">&amp;</span> <span class="n">setp</span><span class="p">:</span>
                        <span class="n">needs_rewrite</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="c1"># needs rewrite</span>
                        <span class="n">new_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rename_inputs_in_subgraph</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">needs_rewrite</span><span class="p">:</span>
                <span class="n">seti</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">seti</span> <span class="o">&amp;</span> <span class="n">setp</span><span class="p">):</span>
                    <span class="n">nodes_add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="k">continue</span>

            <span class="n">node2</span> <span class="o">=</span> <span class="n">NodeProto</span><span class="p">()</span>
            <span class="n">node2</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">doc_string</span>
            <span class="n">node2</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>
            <span class="n">node2</span><span class="o">.</span><span class="n">op_type</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span>
            <span class="n">node2</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">domain</span>
            <span class="n">node2</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">])</span>
            <span class="n">node2</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">metadata_props</span><span class="p">:</span>
                <span class="n">node2</span><span class="o">.</span><span class="n">metadata_props</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">metadata_props</span><span class="p">)</span>

            <span class="n">atts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span><span class="p">:</span>
                    <span class="n">atts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">att</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="n">new_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rename_inputs_in_subgraph</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="p">)</span>
                <span class="n">atts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oh</span><span class="o">.</span><span class="n">make_attribute</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">new_g</span><span class="p">))</span>

            <span class="n">node2</span><span class="o">.</span><span class="n">attribute</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">atts</span><span class="p">)</span>
            <span class="n">nodes_add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node2</span><span class="p">)</span>

        <span class="n">model</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">nodes_add</span><span class="p">)</span>

        <span class="n">seti</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">seti</span> <span class="o">&amp;</span> <span class="n">setp</span><span class="p">:</span>
            <span class="n">new_inputs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">setp</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">ValueInfoProto</span><span class="p">()</span>
                    <span class="n">v</span><span class="o">.</span><span class="n">ParseFromString</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">())</span>
                    <span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                    <span class="n">new_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">model</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_inputs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_metadata_props</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">ModelProto</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">existing_metadata_props</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;existing_metadata_props&quot;</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">{}</span>
        <span class="p">)</span>
        <span class="n">values</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
        <span class="n">values</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;input_args&quot;</span><span class="p">:</span> <span class="n">string_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_args</span><span class="p">,</span> <span class="n">with_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_min_max</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                <span class="s2">&quot;input_kwargs&quot;</span><span class="p">:</span> <span class="n">string_type</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">input_kwargs</span><span class="p">,</span> <span class="n">with_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_min_max</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">),</span>
                <span class="s2">&quot;optimizations&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="p">:</span>
            <span class="n">values</span><span class="p">[</span><span class="s2">&quot;dynamic_shapes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dynamic_shapes</span><span class="p">:</span>
            <span class="n">values</span><span class="p">[</span><span class="s2">&quot;output_dynamic_shapes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dynamic_shapes</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraints_</span><span class="p">:</span>
            <span class="n">values</span><span class="p">[</span><span class="s2">&quot;_discovered_shape_constraints&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraints_</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="p">:</span>
            <span class="n">filtered</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;init&quot;</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">filtered</span><span class="p">:</span>
                <span class="n">values</span><span class="p">[</span><span class="s2">&quot;_known_value_shape&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_dict</span><span class="p">(</span><span class="n">filtered</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">values</span><span class="p">:</span>
            <span class="n">oh</span><span class="o">.</span><span class="n">set_metadata_props</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;torch.Tensor&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">TensorProto</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>  <span class="c1"># noqa: F821</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">size_type</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">TensorProto</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">data_type</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">size_type</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

<div class="viewcode-block" id="GraphBuilder.to_onnx">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.to_onnx">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_onnx</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">optimize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">large_model</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">external_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span>
        <span class="n">return_optimize_report</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">inline</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">function_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">FunctionOptions</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mask_outputs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">as_graph_proto</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">FunctionProto</span><span class="p">,</span> <span class="n">ModelProto</span><span class="p">,</span> <span class="n">GraphProto</span><span class="p">,</span> <span class="n">TorchModelContainer</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Conversion to onnx. Only then the initializers are converted into TensorProto.</span>

<span class="sd">        :param optimize: disable or enable the optimization,</span>
<span class="sd">            the optimization are set when the class constructor is called</span>
<span class="sd">        :param large_model: if True returns a :class:`onnx.model_container.ModelContainer`,</span>
<span class="sd">            it lets the user to decide later if the weights should be part of the model</span>
<span class="sd">            or saved as external weights</span>
<span class="sd">        :param external_threshold: if large_model is True, every tensor above this limit</span>
<span class="sd">            is stored as external</span>
<span class="sd">        :param return_optimize_report: return statistics about the optimization as well</span>
<span class="sd">        :param inline: inline local functions, this is done before</span>
<span class="sd">            any optimization takes place</span>
<span class="sd">        :param function_options: to be set to export as a function</span>
<span class="sd">        :param mask_outputs: to filter out some outputs if not None</span>
<span class="sd">        :param as_graph_proto: return a GraphProto with no initializers,</span>
<span class="sd">            they are returned as well.</span>
<span class="sd">        :return: the proto</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;No node to convert</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">function_options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">function_options</span> <span class="o">=</span> <span class="n">FunctionOptions</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The onnx model is empty (no node).</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inline</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">([],</span> <span class="s2">&quot;before-inline&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_constants</span><span class="p">(</span><span class="s2">&quot;before-inline&quot;</span><span class="p">)</span>
            <span class="n">stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inline_functions</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_constants</span><span class="p">(</span><span class="s2">&quot;after-inline&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">([],</span> <span class="s2">&quot;after-inline&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stats</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">optimize</span><span class="p">:</span>
            <span class="n">statso</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">stats</span><span class="p">:</span>
                <span class="n">stats</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">statso</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stats</span> <span class="o">=</span> <span class="n">statso</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="p">:</span>
                <span class="c1"># Adding the true names back.</span>
                <span class="n">update</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">update_source</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="p">:</span>
                        <span class="n">update</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="n">v</span>
                        <span class="n">update_source</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">update</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">update_source</span><span class="p">)</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;The onnx model is empty after optimization (no node).</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># adding to the model everything we know</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_shape_information_node_metadata</span><span class="p">()</span>
        <span class="n">opsets</span> <span class="o">=</span> <span class="p">[</span><span class="n">oh</span><span class="o">.</span><span class="n">make_opsetid</span><span class="p">(</span><span class="o">*</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
        <span class="k">if</span> <span class="n">mask_outputs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask_outputs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Length mismatch between mask=</span><span class="si">{</span><span class="n">mask_outputs</span><span class="si">}</span><span class="s2"> and outputs &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">function_options</span><span class="o">.</span><span class="n">export_as_function</span><span class="p">:</span>
            <span class="c1"># export as a function</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_onnx_function</span><span class="p">(</span><span class="n">function_options</span><span class="p">,</span> <span class="n">opsets</span><span class="p">,</span> <span class="n">mask_outputs</span><span class="p">)</span>

        <span class="c1"># export as a model</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir_version</span><span class="p">:</span>
            <span class="n">ir_version</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir_version</span>
        <span class="k">elif</span> <span class="s2">&quot;&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">:</span>
            <span class="n">ir_version</span> <span class="o">=</span> <span class="n">_default_OPSET_TO_IR_VERSION</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.to_onnx] make_model &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">)</span><span class="si">}</span><span class="s2"> inits &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="p">)</span><span class="si">}</span><span class="s2"> params&quot;</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.time_evaluation_constants_] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">time_evaluation_constants_</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># building the model</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">ModelProto</span><span class="p">()</span>
        <span class="n">model</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">GraphProto</span><span class="p">())</span>
        <span class="n">model</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;experiment&quot;</span>
        <span class="n">model</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">o</span> <span class="k">for</span> <span class="n">mask</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mask_outputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span> <span class="k">if</span> <span class="n">mask</span><span class="p">)</span>

        <span class="c1"># rename parameters following the original model names if possible</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_model_with_parameter_renaming</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">model</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">as_graph_proto</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">model</span><span class="o">.</span><span class="n">graph</span>

        <span class="c1"># initializers</span>
        <span class="n">initializers</span><span class="p">,</span> <span class="n">large_initializers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_initializers</span><span class="p">(</span>
            <span class="n">switch_low_high</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">!=</span> <span class="s2">&quot;big&quot;</span><span class="p">,</span>
            <span class="n">large_model</span><span class="o">=</span><span class="n">large_model</span><span class="p">,</span>
            <span class="n">external_threshold</span><span class="o">=</span><span class="n">external_threshold</span><span class="p">,</span>
            <span class="n">full_parameter_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span> <span class="ow">or</span> <span class="n">initializers</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Some parameters are renamed </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;self.initializers_dict=</span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;but there is no initializer</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">initializer</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="n">init</span> <span class="k">for</span> <span class="n">init</span> <span class="ow">in</span> <span class="n">initializers</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="n">TensorProto</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;protobuf is limited to 2 Gb, if this fails here, &quot;</span>
                <span class="s2">&quot;it probably means the result is beyond that limit. &quot;</span>
                <span class="s2">&quot;You should use large_model=True.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="n">sparse_initializer</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">init</span> <span class="k">for</span> <span class="n">init</span> <span class="ow">in</span> <span class="n">initializers</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="n">SparseTensorProto</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">sparse_initializer</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
                <span class="n">init</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">init</span> <span class="ow">in</span> <span class="n">sparse_initializer</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Missing name for one sparse initializer among </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sparse_initializer</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">model</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">sparse_initializer</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sparse_initializer</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;protobuf is limited to 2 Gb, if this fails here, &quot;</span>
                    <span class="s2">&quot;it probably means the result is beyond that limit. &quot;</span>
                    <span class="s2">&quot;You should use large_model=True.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

        <span class="c1"># opsets</span>
        <span class="n">model</span><span class="o">.</span><span class="n">opset_import</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">opsets</span><span class="p">)</span>
        <span class="n">model</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">model</span><span class="o">.</span><span class="n">ir_version</span> <span class="o">=</span> <span class="n">ir_version</span>
        <span class="c1"># Rewrites shape informations, operates replacments</span>
        <span class="c1"># to use as much as possible the dynamic dimension given</span>
        <span class="c1"># by the user.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_shape_information</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

        <span class="c1"># final doc_string</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_metadata_props</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span>
            <span class="n">large_model</span><span class="o">=</span><span class="n">large_model</span><span class="p">,</span>
            <span class="n">inline</span><span class="o">=</span><span class="n">inline</span><span class="p">,</span>
            <span class="n">external_threshold</span><span class="o">=</span><span class="n">external_threshold</span><span class="p">,</span>
            <span class="n">function_options</span><span class="o">=</span><span class="n">function_options</span><span class="p">,</span>
            <span class="n">optimize</span><span class="o">=</span><span class="n">optimize</span><span class="p">,</span>
            <span class="n">n_initializers</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">initializers</span><span class="p">),</span>
            <span class="n">n_large_initializers</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">large_initializers</span><span class="p">),</span>
            <span class="n">size_initializers</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span>
                <span class="nb">sum</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
                    <span class="o">*</span> <span class="n">size_type</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">data_type</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">TensorProto</span><span class="p">)</span> <span class="k">else</span> <span class="n">t</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">data_type</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">initializers</span>
                <span class="p">)</span>
            <span class="p">),</span>
            <span class="n">size_large_initializers</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_size</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">large_initializers</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
            <span class="n">n_nodes</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">),</span>
            <span class="n">n_nodes_other_domain</span><span class="o">=</span><span class="nb">len</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">domain</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">]),</span>
            <span class="n">mask_outputs</span><span class="o">=</span><span class="n">mask_outputs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">optimize</span>
            <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">remove_identity</span>
            <span class="ow">or</span> <span class="nb">len</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">op_type</span> <span class="o">==</span> <span class="s2">&quot;Identity&quot;</span><span class="p">])</span>
            <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
        <span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The optimization was not applied. There are two many nodes identity&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_text</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_empty_source</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">init</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">initializer</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">init</span><span class="o">.</span><span class="n">doc_string</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;doc_string is missing for initializer </span><span class="si">{</span><span class="n">init</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_text</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">large_model</span><span class="p">:</span>
            <span class="n">lm</span> <span class="o">=</span> <span class="n">TorchModelContainer</span><span class="p">()</span>
            <span class="n">lm</span><span class="o">.</span><span class="n">model_proto</span> <span class="o">=</span> <span class="n">model</span>
            <span class="k">if</span> <span class="n">large_initializers</span><span class="p">:</span>
                <span class="n">lm</span><span class="o">.</span><span class="n">set_large_initializers</span><span class="p">(</span><span class="n">large_initializers</span><span class="p">)</span>
                <span class="n">lm</span><span class="o">.</span><span class="n">check_large_initializers</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_empty_source</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">init</span> <span class="ow">in</span> <span class="n">lm</span><span class="o">.</span><span class="n">model_proto</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">initializer</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="n">init</span><span class="o">.</span><span class="n">doc_string</span><span class="p">,</span> <span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;doc_string is missing for initializer </span><span class="si">{</span><span class="n">init</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_text</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">lm</span><span class="p">,</span> <span class="n">stats</span><span class="p">)</span> <span class="k">if</span> <span class="n">return_optimize_report</span> <span class="k">else</span> <span class="n">lm</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">stats</span><span class="p">)</span> <span class="k">if</span> <span class="n">return_optimize_report</span> <span class="k">else</span> <span class="n">model</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_rename_dynamic_dimension_inplace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">ValueInfoProto</span><span class="p">,</span> <span class="n">replacements</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValueInfoProto</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Renames dynamic shapes into a proto.&quot;&quot;&quot;</span>
        <span class="n">tensor_type</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">tensor_type</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">tensor_type</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="o">.</span><span class="n">dim_param</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">dim_param</span> <span class="ow">in</span> <span class="n">replacements</span> <span class="ow">and</span> <span class="n">replacements</span><span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">dim_param</span><span class="p">]</span> <span class="o">!=</span> <span class="n">d</span><span class="o">.</span><span class="n">dim_param</span><span class="p">:</span>
                <span class="n">d</span><span class="o">.</span><span class="n">dim_param</span> <span class="o">=</span> <span class="n">replacements</span><span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">dim_param</span><span class="p">]</span>
            <span class="k">elif</span> <span class="s2">&quot;+&quot;</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">dim_param</span> <span class="ow">or</span> <span class="s2">&quot;*&quot;</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">dim_param</span> <span class="ow">or</span> <span class="s2">&quot;-&quot;</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">dim_param</span><span class="p">:</span>
                <span class="c1"># Maybe we should handle more expression?</span>
                <span class="n">d</span><span class="o">.</span><span class="n">dim_param</span> <span class="o">=</span> <span class="n">rename_dynamic_expression</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">dim_param</span><span class="p">,</span> <span class="n">replacements</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_improves_dynamic_dimension_naming</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Improves the naming of the dynamic dimnesion based on what</span>
<span class="sd">        the user gave.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_dyn_dim</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._improves_dynamic_dimension_naming] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraints_</span><span class="p">)</span><span class="si">}</span><span class="s2"> constaints&quot;</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraints_</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_dyn_dim</span> <span class="ow">or</span> <span class="n">v</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_dyn_dim</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._improves_dynamic_dimension_naming] .. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> ~ </span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_update</span><span class="p">(</span><span class="n">dd_flat</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dd_flat</span><span class="p">:</span>
                <span class="c1"># Let&#39;s update the constraints.</span>
                <span class="k">for</span> <span class="n">dyn_name</span><span class="p">,</span> <span class="n">iname</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dd_flat</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
                    <span class="c1"># something like</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dyn_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="k">assert</span> <span class="n">dyn_name</span> <span class="o">==</span> <span class="n">iname</span><span class="p">,</span> <span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Issue with one input name and its associated dynamic shape &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;dyn_name=</span><span class="si">{</span><span class="n">dyn_name</span><span class="si">!r}</span><span class="s2">, input_name=</span><span class="si">{</span><span class="n">iname</span><span class="si">!r}</span><span class="s2">, among &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">dyn_name=</span><span class="si">{</span><span class="n">dd_flat</span><span class="si">}</span><span class="se">\n</span><span class="s2">names=</span><span class="si">{</span><span class="n">names</span><span class="si">!r}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;You should give the dummy inputs in the same order than &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;the forward signature, even if the inputs are given in &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;a dictionary.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">iname</span><span class="p">):</span>
                        <span class="k">continue</span>
                    <span class="n">dd_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">iname</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">sh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dd_shape</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">dim_name</span><span class="p">,</span> <span class="n">where</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">where</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">axis</span><span class="p">:</span>
                                    <span class="k">continue</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">r</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;input_name&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dyn_name</span><span class="p">)</span>
                                <span class="k">except</span> <span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">symbolic_shapes</span><span class="o">.</span><span class="n">GuardOnDataDependentSymNode</span>
                                <span class="p">):</span>
                                    <span class="n">r</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
                                    <span class="k">continue</span>
                                <span class="c1"># We add a constraint.</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">add_to_constraints</span><span class="p">(</span><span class="n">dim_name</span><span class="p">,</span> <span class="n">sh</span><span class="p">)</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">add_to_constraints</span><span class="p">(</span><span class="n">sh</span><span class="p">,</span> <span class="n">dim_name</span><span class="p">)</span>

        <span class="n">_update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source_flat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_names</span><span class="p">)</span>
        <span class="n">_update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dynamic_dimensions_source_flat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_improve_constraints</span><span class="p">()</span>

        <span class="c1"># Before calling rename_dynamic_dimension, we expand the list.</span>
        <span class="n">expanded_constraints</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraints_</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">expanded_constraints</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                <span class="n">expanded_constraints</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">expanded_constraints</span><span class="p">:</span>
                    <span class="n">expanded_constraints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="n">expanded_constraints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|=</span> <span class="n">v</span>
                <span class="n">expanded_constraints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|=</span> <span class="p">{</span><span class="n">k</span><span class="p">}</span>

        <span class="c1"># let&#39;s rename unknown input dimension with basic rules.</span>
        <span class="n">implicit_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;batch&quot;</span><span class="p">,</span> <span class="s2">&quot;channel&quot;</span><span class="p">]</span>
        <span class="n">original</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;DYN&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;+&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">original</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="c1"># We replace it with one implicit name.</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;scalar&quot;</span>
                    <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span>
                    <span class="k">else</span> <span class="p">(</span>
                        <span class="n">implicit_names</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">implicit_names</span><span class="p">)</span>
                        <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;D</span><span class="si">{</span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">implicit_names</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;g0&quot;</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="n">original</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">prefix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;g</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="n">prefix</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">expanded_constraints</span><span class="p">:</span>
                <span class="n">expanded_constraints</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">}</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">expanded_constraints</span><span class="p">:</span>
                    <span class="n">expanded_constraints</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
                <span class="n">original</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">n</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">expanded_constraints</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">n</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">expanded_constraints</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">expanded_constraints</span><span class="p">:</span>
                <span class="n">expanded_constraints</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">original</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="c1"># some cleaning</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="s2">&quot;channel&quot;</span> <span class="ow">in</span> <span class="n">original</span>
            <span class="ow">and</span> <span class="s2">&quot;channel&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_dimensions_source</span>
            <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;cache_length&quot;</span> <span class="ow">in</span> <span class="n">original</span> <span class="ow">or</span> <span class="s2">&quot;seq_length&quot;</span> <span class="ow">in</span> <span class="n">original</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">original</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;channel&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_dyn_dim</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._improves_dynamic_dimension_naming] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;original=</span><span class="si">{</span><span class="n">original</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Let&#39;s process the output constraints.</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dynamic_shapes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_dynamic_shapes</span><span class="p">,</span> <span class="nb">dict</span>
        <span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Not implemented when output_dynamic_shapes is not a dictionary, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;output_dynamic_shapes=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dynamic_shapes</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dynamic_shapes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dynamic_shapes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">WrapDim</span><span class="p">),</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span><span class="si">}</span><span class="s2"> in output_dynamic_shapes=&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dynamic_shapes</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="n">current_name</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
                    <span class="n">new_name</span> <span class="o">=</span> <span class="n">dim</span><span class="o">.</span><span class="n">name</span>
                    <span class="k">if</span> <span class="n">current_name</span> <span class="o">==</span> <span class="n">new_name</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">new_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">expanded_constraints</span><span class="p">:</span>
                        <span class="n">expanded_constraints</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                    <span class="n">expanded_constraints</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">current_name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">current_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">expanded_constraints</span><span class="p">:</span>
                        <span class="n">expanded_constraints</span><span class="p">[</span><span class="n">current_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                    <span class="n">expanded_constraints</span><span class="p">[</span><span class="n">current_name</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_name</span><span class="p">)</span>

        <span class="c1"># once everything is defined, the rewriting can begin.</span>
        <span class="n">replacements</span> <span class="o">=</span> <span class="n">rename_dynamic_dimensions</span><span class="p">(</span><span class="n">expanded_constraints</span><span class="p">,</span> <span class="n">original</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._add_shape_information] dynamic shapes &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;replacements=</span><span class="si">{</span><span class="n">replacements</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_dyn_dim</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._improves_dynamic_dimension_naming] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">replacements</span><span class="p">)</span><span class="si">}</span><span class="s2"> replacements&quot;</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">replacements</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_dyn_dim</span> <span class="ow">or</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_dyn_dim</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._improves_dynamic_dimension_naming] &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;.. </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">v</span><span class="si">!r}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

        <span class="k">if</span> <span class="n">replacements</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;replacements_&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">replacements_dimensions_</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">replacements_for_replacements_dimensions_</span> <span class="o">=</span> <span class="n">replacements</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_shapes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">replacements_dimensions_</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">rename_dynamic_expression</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">replacements</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">_</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">v</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">replacements</span>

<div class="viewcode-block" id="GraphBuilder.get_shape_renamed">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.get_shape_renamed">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_shape_renamed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DYNAMIC_SHAPE</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the shape of a result using user dimension name.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;replacements_dimensions_&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">replacements_dimensions_</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replacements_dimensions_</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_add_shape_information</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">GraphProto</span><span class="p">,</span> <span class="n">ModelProto</span><span class="p">],</span> <span class="n">update_dim_names</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds shape information to the model.</span>

<span class="sd">        :param model: final onnx model</span>
<span class="sd">        :param update_dim_names: the conversion usually detects many dimension equivalent</span>
<span class="sd">            among each others, if True, the function renames as much as possible by using</span>
<span class="sd">            the names the user provides</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">replacements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_improves_dynamic_dimension_naming</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">replacements</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The onnx model is empty after export to onnx (no node).&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># restores the existing value_info</span>
        <span class="n">done</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">init</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">init</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">initializer</span><span class="p">)</span>
            <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">input</span><span class="p">)</span>
            <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">replacements</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">input</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_rename_dynamic_dimension_inplace</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">replacements</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_rename_dynamic_dimension_inplace</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">replacements</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_info</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                <span class="n">model</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">value_info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_rename_dynamic_dimension_inplace</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">replacements</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">done</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># adding shape information</span>
        <span class="n">addition</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">done</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="n">addition</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_rename_dynamic_dimension_inplace</span><span class="p">(</span>
                        <span class="n">oh</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span>
                            <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
                        <span class="p">),</span>
                        <span class="n">replacements</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="n">addition</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_rename_dynamic_dimension_inplace</span><span class="p">(</span>
                        <span class="n">oh</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span>
                            <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                        <span class="p">),</span>
                        <span class="n">replacements</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">addition</span><span class="p">:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">value_info</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">addition</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_add_shape_information_node_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">intypes</span><span class="o">=</span><span class="s2">&quot; / &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="nb">map</span><span class="p">(</span>
                        <span class="nb">str</span><span class="p">,</span>
                        <span class="p">[</span>
                            <span class="p">(</span>
                                <span class="s2">&quot;&quot;</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span>
                                <span class="k">else</span> <span class="p">(</span>
                                    <span class="n">onnx_dtype_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;?&quot;</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span>
                        <span class="p">],</span>
                    <span class="p">)</span>
                <span class="p">),</span>
                <span class="n">outtypes</span><span class="o">=</span><span class="s2">&quot; / &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="nb">map</span><span class="p">(</span>
                        <span class="nb">str</span><span class="p">,</span>
                        <span class="p">[</span>
                            <span class="p">(</span>
                                <span class="s2">&quot;&quot;</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span>
                                <span class="k">else</span> <span class="p">(</span>
                                    <span class="n">onnx_dtype_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;?&quot;</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span>
                        <span class="p">],</span>
                    <span class="p">)</span>
                <span class="p">),</span>
                <span class="n">inshapes</span><span class="o">=</span><span class="s2">&quot; / &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="nb">map</span><span class="p">(</span>
                        <span class="nb">str</span><span class="p">,</span>
                        <span class="p">[</span>
                            <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="k">else</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;?&quot;</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span>
                        <span class="p">],</span>
                    <span class="p">)</span>
                <span class="p">),</span>
                <span class="n">outshapes</span><span class="o">=</span><span class="s2">&quot; / &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="nb">map</span><span class="p">(</span>
                        <span class="nb">str</span><span class="p">,</span>
                        <span class="p">[</span>
                            <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="k">else</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;?&quot;</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span>
                        <span class="p">],</span>
                    <span class="p">)</span>
                <span class="p">),</span>
            <span class="p">)</span>
            <span class="n">invalues</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">value_as_shape</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">]</span>
            <span class="n">outvalues</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">value_as_shape</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">invalues</span><span class="p">):</span>
                <span class="n">data</span><span class="p">[</span><span class="s2">&quot;invalueshapes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot; / &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">invalues</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">outvalues</span><span class="p">):</span>
                <span class="n">data</span><span class="p">[</span><span class="s2">&quot;outvalueshapes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot; / &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">outvalues</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">entry</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">metadata_props</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
                <span class="n">entry</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">k</span>
                <span class="n">entry</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">v</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_improve_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds more correspondances deduced from self.constraints_.&quot;&quot;&quot;</span>

        <span class="n">update</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">it</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">update</span> <span class="ow">or</span> <span class="n">it</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">it</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">update</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraints_</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">vv</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vv</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                        <span class="k">continue</span>
                    <span class="n">simpl</span> <span class="o">=</span> <span class="n">simplify_two_expressions</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">vv</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">simpl</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">simpl</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                    <span class="k">if</span> <span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="n">items</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="k">continue</span>
                    <span class="c1"># adds an equivalence</span>
                    <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">items</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">n1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">update</span><span class="p">:</span>
                        <span class="n">update</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">n2</span><span class="p">}</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">update</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">n2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">update</span><span class="p">:</span>
                        <span class="n">update</span><span class="p">[</span><span class="n">n2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">n1</span><span class="p">}</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">update</span><span class="p">[</span><span class="n">n2</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
                    <span class="n">k2</span> <span class="o">=</span> <span class="n">rename_expression</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">{</span><span class="n">n2</span><span class="p">:</span> <span class="n">n1</span><span class="p">})</span>
                    <span class="n">vv2</span> <span class="o">=</span> <span class="n">rename_expression</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">{</span><span class="n">n1</span><span class="p">:</span> <span class="n">n2</span><span class="p">})</span>
                    <span class="k">assert</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">k2</span> <span class="ow">and</span> <span class="n">vv</span> <span class="o">!=</span> <span class="n">vv2</span>
                    <span class="n">eq</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">vv</span><span class="p">,</span> <span class="n">vv2</span><span class="p">}</span>
                    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">eq</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">update</span><span class="p">:</span>
                            <span class="n">update</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">eq</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">update</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">|=</span> <span class="n">eq</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">update</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_dyn_dim</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_dyn_dim</span> <span class="o">&amp;</span> <span class="p">{</span><span class="n">k</span><span class="p">}:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._improve_constraints] </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_to_constraints</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

<div class="viewcode-block" id="GraphBuilder.io_names">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.io_names">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">io_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the list of inputs, output for nodes.&quot;&quot;&quot;</span>
        <span class="n">input_names</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">}</span>
        <span class="n">init_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">)</span>
        <span class="n">output_names</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">}</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;I&lt;-[</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">assert_sorted</span><span class="p">(</span><span class="n">input_names</span><span class="p">))</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;C&lt;-[</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">assert_sorted</span><span class="p">(</span><span class="n">init_names</span><span class="p">))</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;N:</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">}</span><span class="s2">:[</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">assert_sorted</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">))</span><span class="si">}</span><span class="s2">]&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;-&gt;[</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">assert_sorted</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">))</span><span class="si">}</span><span class="s2">]&quot;</span>
            <span class="p">)</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;O-&gt;[</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">assert_sorted</span><span class="p">(</span><span class="n">output_names</span><span class="p">))</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_check_nodes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">NodeProto</span><span class="p">],</span> <span class="n">known</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">step</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">domain</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Domain </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="si">!r}</span><span class="s2"> is not registered in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">root</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Name </span><span class="si">{</span><span class="n">i</span><span class="si">!r}</span><span class="s2"> not registered, step </span><span class="si">{</span><span class="n">step</span><span class="si">!r}</span><span class="s2">, node type is &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">, root=</span><span class="si">{</span><span class="n">root</span><span class="si">!r}</span><span class="s2">, node name is </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;input are </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="si">}</span><span class="s2">, i=</span><span class="si">{</span><span class="n">i</span><span class="si">!r}</span><span class="s2"> in known=</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">known</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">assert</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">known</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unknown input </span><span class="si">{</span><span class="n">i</span><span class="si">!r}</span><span class="s2">, step </span><span class="si">{</span><span class="n">step</span><span class="si">!r}</span><span class="s2"> in node type &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">}</span><span class="s2">, name is </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_subgraph_possibly</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span><span class="p">:</span>
                        <span class="n">g</span> <span class="o">=</span> <span class="n">att</span><span class="o">.</span><span class="n">g</span>
                        <span class="n">k2</span> <span class="o">=</span> <span class="n">known</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">k2</span> <span class="o">|=</span> <span class="p">(</span>
                            <span class="nb">set</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">input</span><span class="p">)</span>
                            <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">initializer</span><span class="p">)</span>
                            <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">sparse_initializer</span><span class="p">)</span>
                        <span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_check_nodes</span><span class="p">(</span>
                            <span class="n">g</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">step</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                            <span class="k">assert</span> <span class="n">o</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">k2</span><span class="p">,</span> <span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Unknown output </span><span class="si">{</span><span class="n">o</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, step </span><span class="si">{</span><span class="n">step</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;op_type=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">, att.name=</span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;node.name=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
            <span class="n">known</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stats</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span> <span class="n">step</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">shadowing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">begin</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The onnx model is empty (step </span><span class="si">{</span><span class="n">step</span><span class="si">!r}</span><span class="s2">, no node, shadowing=</span><span class="si">{</span><span class="n">shadowing</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">known</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">)</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">_context</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">known</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">o</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">known</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unknown output </span><span class="si">{</span><span class="n">o</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, step </span><span class="si">{</span><span class="n">step</span><span class="si">!r}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">shadowing</span><span class="p">:</span>
            <span class="n">shadow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shadowing_names</span><span class="p">()</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">shadow</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Shadowing names were found (</span><span class="si">{</span><span class="n">shadow</span><span class="si">}</span><span class="s2">).&quot;</span>
        <span class="n">stats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">pattern</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;check_</span><span class="si">{</span><span class="n">step</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">time_in</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">begin</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_import_context_from_parent_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="c1"># We cannot overwrite a local result.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;optimize_node_subgraphs_inplace&quot;</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>
        <span class="n">parent_name</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">,</span> <span class="n">name</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span><span class="p">:</span>
            <span class="c1"># Coming from a Scan, If, Loop, Node</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_names</span><span class="p">:</span>
                <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">position</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span><span class="o">.</span><span class="n">input</span><span class="p">),</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;No corresponding input name for </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> in node</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pretty_onnx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span><span class="p">,</span><span class="w"> </span><span class="n">with_attributes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">---</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">parent_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="n">position</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">parent_name</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_shape</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">parent_name</span><span class="p">),</span> <span class="n">allow_zero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">parent_name</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_rank</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">parent_name</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">parent_name</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">parent_name</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">has_device</span><span class="p">(</span><span class="n">parent_name</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_device</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">parent_name</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">parent_name</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">constants_</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constants_</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">constants_</span><span class="p">[</span><span class="n">parent_name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">parent_name</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">constants_node_</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constants_node_</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">constants_node_</span><span class="p">[</span><span class="n">parent_name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">parent_name</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="p">[</span><span class="n">parent_name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">parent_name</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">_parameter_norename</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_norename</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

<div class="viewcode-block" id="GraphBuilder.optimize_node_subgraphs_inplace">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.optimize_node_subgraphs_inplace">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize_node_subgraphs_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">NodeProto</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Optimizes the subgraphs for a node.&quot;&quot;&quot;</span>
        <span class="n">new_atts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span><span class="p">:</span>
                <span class="n">new_atts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">att</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">] optimizes attribute &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> from node </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">, name=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="p">(</span>
                <span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">,</span>
                <span class="n">optimization_options</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                <span class="n">_opsets</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">,</span>
                <span class="n">_context</span><span class="o">=</span><span class="n">context</span><span class="p">,</span>
                <span class="n">_parent</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">functions</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;unexpected functions in a subgraphs</span><span class="si">{</span><span class="n">g</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="c1"># We need to populate whatever exists.</span>
            <span class="n">g</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>

            <span class="n">renaming</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="n">nk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="n">renaming</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">nk</span>
            <span class="k">if</span> <span class="n">renaming</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">rename_names</span><span class="p">(</span><span class="n">renaming</span><span class="p">)</span>

            <span class="n">new_g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">to_onnx</span><span class="p">(</span><span class="n">optimize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">as_graph_proto</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_g</span><span class="p">,</span> <span class="n">GraphProto</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">new_g</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">] done optimizing attribute &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> from node </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">, name=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">new_atts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oh</span><span class="o">.</span><span class="n">make_attribute</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">new_g</span><span class="p">))</span>

            <span class="c1"># We need to append functions and initiliazers to the main graph.</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">initializers_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span>
                <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;name </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2"> already present. That should not be the case.&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span>
                    <span class="n">k</span><span class="p">,</span>
                    <span class="n">marker</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">_events</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="s2">&quot;set_event&quot;</span><span class="p">),</span> <span class="s2">&quot;optimize_node_subgraphs_inplace&quot;</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_shape</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">has_device</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_device</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">constants_</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">constants_</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">constants_</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">_parameter_norename</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_norename</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">_known_torch_value</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_known_torch_value</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">_known_torch_value</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="k">del</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">[:]</span>
        <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_atts</span><span class="p">)</span></div>


<div class="viewcode-block" id="GraphBuilder.optimize">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.optimize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recursive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimizes a graph.</span>
<span class="sd">        Returns the list of applied processes.</span>

<span class="sd">        :param recursive: to overwrite the value provided by the options if True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">statistics</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">main_begin</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

        <span class="n">begin</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_improves_dynamic_dimension_naming</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_another_pass_at_shape_inference</span><span class="p">()</span>
        <span class="n">statistics</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">pattern</span><span class="o">=</span><span class="s2">&quot;dynamic_dimension_naming&quot;</span><span class="p">,</span>
                <span class="n">removed</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">added</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">time_in</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">begin</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">statistics</span><span class="p">,</span> <span class="s2">&quot;A-dynamic_dimension_naming&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.optimize] start with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> nodes&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.optimize] &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;options=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-- GRAPH BEFORE OPTIMIZATON --&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_text</span><span class="p">())</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-- END --&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n_patterns</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mi">0</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span> <span class="ow">is</span> <span class="kc">None</span>
                    <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">patterns</span> <span class="ow">is</span> <span class="kc">None</span>
                    <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">patterns</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.optimize] #patterns=</span><span class="si">{</span><span class="n">n_patterns</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">recursive</span> <span class="ow">and</span> <span class="n">recursive</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.optimize] start with subgraphs&quot;</span><span class="p">)</span>
            <span class="n">context</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">set</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">)</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">_context</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span> <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.optimize] &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;optimize </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">optimize_node_subgraphs_inplace</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.optimize] &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;done </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                <span class="n">context</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span> <span class="k">if</span> <span class="n">o</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.optimize] done with subgraphs&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">statistics</span><span class="p">,</span> <span class="s2">&quot;A-opt-sub&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">statistics</span><span class="p">,</span> <span class="s2">&quot;A-opt&quot;</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">order</span><span class="p">,</span> <span class="n">pass_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">passes</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optimize_pass</span><span class="p">(</span><span class="n">pass_name</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">statistics</span><span class="o">=</span><span class="n">statistics</span><span class="p">)</span>

        <span class="n">na</span><span class="p">,</span> <span class="n">nr</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="k">else</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">duration</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">main_begin</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.optimize] done with &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> nodes in </span><span class="si">{</span><span class="n">duration</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_compile_statistics</span><span class="p">(</span><span class="n">statistics</span><span class="p">))</span>
        <span class="n">statistics</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">pattern</span><span class="o">=</span><span class="s2">&quot;optimization&quot;</span><span class="p">,</span>
                <span class="n">removed</span><span class="o">=</span><span class="n">nr</span><span class="p">,</span>
                <span class="n">added</span><span class="o">=</span><span class="n">na</span><span class="p">,</span>
                <span class="n">time_in</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">main_begin</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">statistics</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">optimize_pass</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pass_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">order</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">statistics</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">begin</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="n">nr</span><span class="p">,</span> <span class="n">na</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">local_stats</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">pass_name</span> <span class="o">==</span> <span class="s2">&quot;remove_identity&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">remove_identity</span><span class="p">:</span>
                <span class="n">nr</span><span class="p">,</span> <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_identity_nodes</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">pass_name</span> <span class="o">==</span> <span class="s2">&quot;remove_unused&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">remove_unused</span><span class="p">:</span>
                <span class="n">nr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_unused</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">pass_name</span> <span class="o">==</span> <span class="s2">&quot;constant_folding&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">constant_folding</span><span class="p">:</span>
                <span class="n">stats_cf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant_folding</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">constant_folding</span><span class="p">)</span>
                <span class="n">nr</span> <span class="o">=</span> <span class="n">stats_cf</span><span class="p">[</span><span class="s2">&quot;n&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">stats_cf</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;n&quot;</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">local_stats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="nb">dict</span><span class="p">(</span>
                            <span class="n">pattern</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;apply_constant_folding_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                            <span class="n">value</span><span class="o">=</span><span class="n">v</span><span class="p">,</span>
                            <span class="n">iteration</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
        <span class="k">elif</span> <span class="n">pass_name</span> <span class="o">==</span> <span class="s2">&quot;patterns&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">patterns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
                <span class="n">local_stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize_with_patterns</span><span class="p">(</span><span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                    <span class="n">nr</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">na</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span>
        <span class="k">elif</span> <span class="n">pass_name</span> <span class="o">==</span> <span class="s2">&quot;remove_duplicated_initializer&quot;</span><span class="p">:</span>
            <span class="n">nr</span><span class="p">,</span> <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_duplicated_initializer</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">pass_name</span> <span class="o">==</span> <span class="s2">&quot;order&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">order</span><span class="p">:</span>
                <span class="n">local_stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize_order</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown pass name </span><span class="si">{</span><span class="n">pass_name</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">statistics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">statistics</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">pattern</span><span class="o">=</span><span class="n">pass_name</span><span class="p">,</span>
                    <span class="n">removed</span><span class="o">=</span><span class="n">nr</span><span class="p">,</span>
                    <span class="n">added</span><span class="o">=</span><span class="n">na</span><span class="p">,</span>
                    <span class="n">time_in</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">begin</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">local_stats</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">local_stats</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">statistics</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">local_stats</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">statistics</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">local_stats</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">statistics</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pass_name</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">order</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="mi">0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">statistics</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compile_statistics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">statistics</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">obs</span> <span class="ow">in</span> <span class="n">statistics</span><span class="p">:</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="n">obs</span><span class="p">[</span><span class="s2">&quot;pattern&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">pattern</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stats</span><span class="p">:</span>
                <span class="n">stats</span><span class="p">[</span><span class="n">pattern</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;time_in&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
                    <span class="s2">&quot;iteration&quot;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s2">&quot;match_index&quot;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s2">&quot;removed&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s2">&quot;added&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s2">&quot;instances&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s2">&quot;repeated&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s2">&quot;max_match&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s2">&quot;n_nodes&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="n">pattern</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">obs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;pattern&quot;</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;time_in&quot;</span><span class="p">,</span> <span class="s2">&quot;removed&quot;</span><span class="p">,</span> <span class="s2">&quot;added&quot;</span><span class="p">,</span> <span class="s2">&quot;instances&quot;</span><span class="p">,</span> <span class="s2">&quot;repeated&quot;</span><span class="p">,</span> <span class="s2">&quot;n_nodes&quot;</span><span class="p">}:</span>
                    <span class="n">o</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">v</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;changed&quot;</span><span class="p">,</span> <span class="s2">&quot;scale&quot;</span><span class="p">}:</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">o</span><span class="p">:</span>
                        <span class="n">o</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">o</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">v</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;iter&quot;</span><span class="p">,</span> <span class="s2">&quot;max_match&quot;</span><span class="p">}:</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">o</span><span class="p">:</span>
                        <span class="n">o</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">o</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">o</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">v</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;algo&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="s2">&quot;exit_point&quot;</span><span class="p">}</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">o</span><span class="p">:</span>
                    <span class="n">o</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">assert</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">o</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Missing k=</span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2"> from statistics=</span><span class="si">{</span><span class="n">statistics</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="n">o</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">assert_sorted</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;    STAT </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> +</span><span class="si">{</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;added&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> -</span><span class="si">{</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;removed&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;#it=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;iteration&#39;</span><span class="p">]))</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;maxmatch=</span><span class="si">{</span><span class="nb">max</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;match_index&#39;</span><span class="p">])</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;match_index&#39;</span><span class="p">]</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="mi">0</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;i=</span><span class="si">{</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;instances&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> - time=</span><span class="si">{</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;time_in&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

        <span class="c1"># adding statistics on node type</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_compile_model_statistics</span><span class="p">(</span><span class="kc">False</span><span class="p">))</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_compile_model_statistics</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compile_model_statistics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">detailed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;--MODEL: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> nodes, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span><span class="si">}</span><span class="s2"> inputs, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span><span class="si">}</span><span class="s2"> outputs, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">)</span><span class="si">}</span><span class="s2"> initializers--&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;DETAILED--&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">detailed</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">detailed</span><span class="p">:</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">_shape</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">return</span> <span class="s2">&quot;1&quot;</span>
                    <span class="k">return</span> <span class="s2">&quot;x&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">return</span> <span class="s2">&quot;1&quot;</span>
                    <span class="k">return</span> <span class="s2">&quot;x&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;?&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span>
                <span class="k">return</span> <span class="s2">&quot;?&quot;</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">_key</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
                    <span class="k">return</span> <span class="s2">&quot;&quot;</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">tt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;?&quot;</span>
                    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tt</span><span class="si">}</span><span class="s2">t[</span><span class="si">{</span><span class="n">_shape</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="s2">]&quot;</span>
                <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">op_type</span> <span class="o">==</span> <span class="s2">&quot;Transpose&quot;</span><span class="p">:</span>
                    <span class="n">perm</span> <span class="o">=</span> <span class="s2">&quot;;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;perm&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">ints</span><span class="p">))</span>
                    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">_key</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2">-perm=</span><span class="si">{</span><span class="n">perm</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">return</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_key</span><span class="p">,</span> <span class="n">name</span><span class="o">.</span><span class="n">input</span><span class="p">))</span>

            <span class="n">cc</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">([</span><span class="n">_key</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_names</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">assert_sorted</span><span class="p">(</span><span class="n">cc</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;     INPUT: </span><span class="si">{</span><span class="n">v</span><span class="si">:</span><span class="s2">3d</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">([</span><span class="n">_key</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">assert_sorted</span><span class="p">(</span><span class="n">cc</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    OUTPUT: </span><span class="si">{</span><span class="n">v</span><span class="si">:</span><span class="s2">3d</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">([</span><span class="n">_key</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">assert_sorted</span><span class="p">(</span><span class="n">cc</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;      INIT: </span><span class="si">{</span><span class="n">v</span><span class="si">:</span><span class="s2">3d</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">op_types</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">op_type</span><span class="p">,</span> <span class="n">_key</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">]</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">op_types</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">assert_sorted</span><span class="p">(</span><span class="n">cc</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                    <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;      NODE: </span><span class="si">{</span><span class="n">v</span><span class="si">:</span><span class="s2">3d</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> -SIG- </span><span class="si">{</span><span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;      NODE: </span><span class="si">{</span><span class="n">v</span><span class="si">:</span><span class="s2">3d</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> -SIG- </span><span class="si">{</span><span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_names</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sequence</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">assert_sorted</span><span class="p">(</span><span class="n">cc</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;         INPUT: </span><span class="si">{</span><span class="n">v</span><span class="si">:</span><span class="s2">3d</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">t&quot;</span><span class="p">)</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">is_sequence</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_names</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">assert_sorted</span><span class="p">(</span><span class="n">cc</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;     INPUT-SEQ: </span><span class="si">{</span><span class="n">v</span><span class="si">:</span><span class="s2">3d</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">t&quot;</span><span class="p">)</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sequence</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">assert_sorted</span><span class="p">(</span><span class="n">cc</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;        OUTPUT: </span><span class="si">{</span><span class="n">v</span><span class="si">:</span><span class="s2">3d</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">t&quot;</span><span class="p">)</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">is_sequence</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">assert_sorted</span><span class="p">(</span><span class="n">cc</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    OUTPUT-SEQ: </span><span class="si">{</span><span class="n">v</span><span class="si">:</span><span class="s2">3d</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">t&quot;</span><span class="p">)</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">assert_sorted</span><span class="p">(</span><span class="n">cc</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;          INIT: </span><span class="si">{</span><span class="n">v</span><span class="si">:</span><span class="s2">3d</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">t&quot;</span><span class="p">)</span>
            <span class="n">op_types</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">op_type</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">]</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">op_types</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">assert_sorted</span><span class="p">(</span><span class="n">cc</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                    <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;          NODE: </span><span class="si">{</span><span class="n">v</span><span class="si">:</span><span class="s2">3d</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;          NODE: </span><span class="si">{</span><span class="n">v</span><span class="si">:</span><span class="s2">3d</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>

<div class="viewcode-block" id="GraphBuilder.optimize_with_patterns">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.optimize_with_patterns">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize_with_patterns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recursive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimizes this graph with patterns.</span>

<span class="sd">        :param recursive: overwrite the value given by the option if this one is True</span>
<span class="sd">        :return: the method returns informations about the applied processes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">..xoptim</span><span class="w"> </span><span class="kn">import</span> <span class="n">GraphBuilderPatternOptimization</span>

        <span class="n">gro</span> <span class="o">=</span> <span class="n">GraphBuilderPatternOptimization</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">verbose</span><span class="p">),</span>
            <span class="n">patterns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">patterns</span><span class="p">,</span>
            <span class="n">recursive</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">recursive</span><span class="p">,</span>
            <span class="n">verifies</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">verifies</span><span class="p">,</span>
            <span class="n">dump_applied_patterns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">dump_applied_patterns</span><span class="p">,</span>
            <span class="n">processor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">processor</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">gro</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span>
            <span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span>
            <span class="n">remove_identity</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">remove_identity</span><span class="p">,</span>
            <span class="n">remove_duplicated_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">remove_duplicated_shape</span><span class="p">,</span>
            <span class="n">stop_after</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">stop_after</span><span class="p">,</span>
            <span class="n">recursive</span><span class="o">=</span><span class="n">recursive</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">optimize_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">..xoptim.order_optim</span><span class="w"> </span><span class="kn">import</span> <span class="n">OrderOptimization</span>

        <span class="n">opt</span> <span class="o">=</span> <span class="n">OrderOptimization</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">order</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">verbose</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">opt</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_hidden_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="n">GraphProto</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the hidden inputs (inputs coming from an upper context)</span>
<span class="sd">        used by a subgraph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hidden</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">memo</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">{</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">initializer</span><span class="p">}</span>
            <span class="o">|</span> <span class="p">{</span><span class="n">i</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">sparse_initializer</span><span class="p">}</span>
            <span class="o">|</span> <span class="p">{</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">input</span><span class="p">}</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span>
                    <span class="n">hidden</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span> <span class="ow">and</span> <span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">:</span>
                    <span class="n">hid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hidden_inputs</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">)</span>
                    <span class="n">less</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">h</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hid</span> <span class="k">if</span> <span class="n">h</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">)</span>
                    <span class="n">hidden</span> <span class="o">|=</span> <span class="n">less</span>
            <span class="n">memo</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hidden</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_used_initializers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the initializers name involved in the graph.&quot;&quot;&quot;</span>
        <span class="n">hidden</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">memo</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span>
                    <span class="n">hidden</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span> <span class="ow">and</span> <span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">:</span>
                    <span class="n">hid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hidden_inputs</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">)</span>
                    <span class="n">less</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">h</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hid</span> <span class="k">if</span> <span class="n">h</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">)</span>
                    <span class="n">hidden</span> <span class="o">|=</span> <span class="n">less</span>
            <span class="n">memo</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">hidden</span> <span class="k">if</span> <span class="n">name</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Some hidden inputs in </span><span class="si">{</span><span class="n">assert_sorted</span><span class="p">(</span><span class="n">hidden</span><span class="p">)</span><span class="si">!r}</span><span class="s2"> are not initializers &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">assert_sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">)</span><span class="si">}</span><span class="s2">. It is unexpected.&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">hidden</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_used_local_functions</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">NodeProto</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the local functions used in the graph.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span>
        <span class="n">used</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
                <span class="n">used</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span> <span class="ow">and</span> <span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">:</span>
                    <span class="n">used</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_used_local_functions</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>
        <span class="c1"># Looking into used functions</span>
        <span class="n">done</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">used</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">done</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="n">used</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_used_local_functions</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>
                <span class="n">done</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">used</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_has_subgraph_possibly</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">NodeProto</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;LSI&quot;</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;Loop&quot;</span><span class="p">,</span> <span class="s2">&quot;Scan&quot;</span><span class="p">,</span> <span class="s2">&quot;If&quot;</span><span class="p">,</span> <span class="s2">&quot;SequenceMap&quot;</span><span class="p">}</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_enumerate_inputs_with_subgraph_plus_hidden</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">NodeProto</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enumerates all inputs from a node including all the hidden inputs</span>
<span class="sd">        from subgraphs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield from</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_has_subgraph_possibly</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span><span class="p">:</span>
                    <span class="n">hidden_inputs</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_hidden_inputs</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">)</span>
                    <span class="k">yield from</span> <span class="n">hidden_inputs</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="p">(</span>
                        <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPHS</span>
                    <span class="p">),</span> <span class="s2">&quot;Not implemented when att.type == AttributeProto.GRAPHS&quot;</span>

<div class="viewcode-block" id="GraphBuilder.remove_unused">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.remove_unused">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_unused</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simple function to remove unused nodes.</span>
<span class="sd">        It does not look into subgraphs and assumes there is none.</span>
<span class="sd">        Everything is done in one pass.</span>
<span class="sd">        Returns the number of removed nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clean_values_cache</span><span class="p">()</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="c1"># mark outputs</span>
        <span class="n">marked</span> <span class="o">=</span> <span class="p">{</span><span class="n">o</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">):</span>
            <span class="n">used</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">node_inputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_enumerate_inputs_with_subgraph_plus_hidden</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">marked</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node_inputs</span><span class="p">:</span>
                        <span class="n">marked</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="n">used</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">used</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_not_remove</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node_inputs</span><span class="p">:</span>
                    <span class="n">marked</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># removed nodes</span>
        <span class="n">removed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">marked_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">marked</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">marked_set</span><span class="p">):</span>
                <span class="n">removed</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">n_not_marked</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">marked</span><span class="p">:</span>
                    <span class="n">n_not_marked</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">):</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.remove_unused] &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;remove_initializer </span><span class="si">{</span><span class="n">n_not_marked</span><span class="si">}</span><span class="s2">:&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">)</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">]&quot;</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.remove_unused] &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;remove_initializer </span><span class="si">{</span><span class="n">n_not_marked</span><span class="si">}</span><span class="s2">:&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">)</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">marked</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constants_</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants_</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">marked</span><span class="p">}</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">removed</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.remove_unused_node] remove &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">removed</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_refresh_values_cache</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">start</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span></div>


<div class="viewcode-block" id="GraphBuilder.constant_folding">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.constant_folding">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">constant_folding</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">convert_into_initializer</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Folds all constants. Constants are marked during the creation of the graph.</span>
<span class="sd">        There is no need to propagate this information.</span>

<span class="sd">        :param options: a boolean to fold anything</span>
<span class="sd">            which can be folded or a list of operator type</span>
<span class="sd">        :param convert_into_initializer: moves the constant as an initializer,</span>
<span class="sd">            otherwise, just evaluates it</span>
<span class="sd">        :return: dictionary of statistics</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">begin_</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.constant_folding] -- starts with &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants_</span><span class="p">)</span><span class="si">}</span><span class="s2"> constants and &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> nodes.&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_names</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.constant_folding] cst:: &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mi">1</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;.&#39;</span><span class="si">}</span><span class="s2"> :: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
        <span class="n">stats_cf</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;new_inits&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">updates</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">node_to_remove</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants_</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># this is an initiliazer</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.constant_folding] initializer: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_foldnot</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.constant_folding.0] &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;unable to fold </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2"> (v is None)&quot;</span>
                    <span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">NodeProto</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">}</span><span class="s2"> for k=</span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.constant_folding] from: </span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">op_type</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">op_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">options</span>
                <span class="ow">and</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">op_type</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">options</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_foldnot</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.constant_folding.P] unable to fold &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">op_type</span><span class="si">}{</span><span class="n">v</span><span class="o">.</span><span class="n">input</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">output</span><span class="si">}</span><span class="s2">  [</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">], k=</span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;options=</span><span class="si">{</span><span class="n">options</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="k">continue</span>
            <span class="c1"># a node</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_constant</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">input</span><span class="p">)):</span>
                <span class="c1"># node evaluation</span>
                <span class="n">output</span><span class="p">,</span> <span class="n">feeds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_constant</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">exc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Evaluation failed.</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_foldnot</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.constant_folding.A] unable to fold &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">op_type</span><span class="si">}{</span><span class="n">v</span><span class="o">.</span><span class="n">input</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">output</span><span class="si">}</span><span class="s2">  [</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">], k=</span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                    <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_constant_folding</span><span class="p">,</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;constant folding unable to fold node [</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_node</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">}</span><span class="s2">], &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;self.compute_constant(k, exc=False)=&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">string_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_constant</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">exc</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="k">continue</span>
                <span class="n">key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">domain</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">op_type</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stats_cf</span><span class="p">:</span>
                    <span class="n">stats_cf</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">stats_cf</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">convert_into_initializer</span><span class="p">:</span>
                    <span class="n">node_to_remove</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">output</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="n">output</span><span class="p">,)</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
                    <span class="n">updates</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">convert_into_initializer</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="s2">&quot;FakeTensor&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)),</span> <span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;FakeTensor </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> cannot be an initializer </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;v.op_type=</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2"> (input types: &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">feeds</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span><span class="si">}</span><span class="s2">)&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                        <span class="n">sources</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">feeds</span><span class="p">:</span>
                            <span class="n">sources</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;##</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">/&quot;</span>
                                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span>
                                <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">source</span>
                                <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;##</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">source</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
                        <span class="n">text_sources</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="k">if</span> <span class="n">sources</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">add_initializer</span><span class="p">(</span>
                            <span class="n">name</span><span class="p">,</span>
                            <span class="n">value</span><span class="p">,</span>
                            <span class="n">existing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;GraphBuilder.constant_folding.from/fold&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">assert_sorted</span><span class="p">(</span><span class="n">feeds</span><span class="p">))</span><span class="si">}</span><span class="s2">)</span><span class="si">{</span><span class="n">text_sources</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                            <span class="n">allow_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">stats_cf</span><span class="p">[</span><span class="s2">&quot;new_inits&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_foldnot</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.constant_folding.B] unable to &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;fold </span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">op_type</span><span class="si">}{</span><span class="n">v</span><span class="o">.</span><span class="n">input</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">output</span><span class="si">}</span><span class="s2">  [</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">]&quot;</span>
                            <span class="p">)</span>
                        <span class="n">updates</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.constant_folding] fold_constant:&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">op_type</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">:&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">]:from:</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">assert_sorted</span><span class="p">(</span><span class="n">feeds</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">updates</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_node_constant</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="n">new_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_not_remove</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="n">new_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_foldnot</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.constant_folding.C] unable to fold &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">}{</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="si">}</span><span class="s2">  [</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">]&quot;</span>
                    <span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">)</span> <span class="ow">in</span> <span class="n">node_to_remove</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">new_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">new_nodes</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.constant_folding] ends with &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants_</span><span class="p">)</span><span class="si">}</span><span class="s2"> constants and &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> nodes in &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">begin_</span><span class="si">}</span><span class="s2"> seconds&quot;</span>
            <span class="p">)</span>
        <span class="n">stats_cf</span><span class="p">[</span><span class="s2">&quot;n&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_refresh_values_cache</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">stats_cf</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_clean_values_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cleans the cache. The cache is used to avoid the creation of new constants</span>
<span class="sd">        while creating a graph. It should be removed the graph is modified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_refresh_values_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rebuilds the cache. The cache is used to avoid the creation of new constants</span>
<span class="sd">        while creating a graph. It should be removed the graph is modified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clean_values_cache</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_key</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>

<div class="viewcode-block" id="GraphBuilder.remove_duplicated_initializer">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.remove_duplicated_initializer">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_duplicated_initializer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes duplicated initializers and inserts identity nodes.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clean_values_cache</span><span class="p">()</span>
        <span class="n">replacements</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_key</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">replacements</span>
                <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Constant name </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2"> is duplicated</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">replacements</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">replacements</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rename_names</span><span class="p">(</span><span class="n">replacements</span><span class="p">,</span> <span class="n">with_existing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">replacements</span><span class="p">),</span> <span class="mi">0</span></div>


    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_rename_inputs_in_node</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">NodeProto</span><span class="p">,</span> <span class="n">replacements</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">to_rename</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NodeProto</span><span class="p">:</span>
        <span class="n">set_inputs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_enumerate_inputs_with_subgraph_plus_hidden</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">set_inputs</span> <span class="o">&amp;</span> <span class="n">to_rename</span><span class="p">:</span>
            <span class="n">new_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">replacements</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">]</span>
            <span class="n">new_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">replacements</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">new_inputs</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">new_outputs</span><span class="p">)</span> <span class="ow">in</span> <span class="p">({</span><span class="s2">&quot;&quot;</span><span class="p">},</span> <span class="nb">set</span><span class="p">()),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Node type </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> is incorrectly replaced &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="n">new_inputs</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="n">new_outputs</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;replacements are</span><span class="se">\n</span><span class="si">{</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="n">replacements</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="n">oh</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="p">,</span>
                <span class="n">new_inputs</span><span class="p">,</span>
                <span class="n">new_outputs</span><span class="p">,</span>
                <span class="n">domain</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_has_subgraph_possibly</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="c1"># Hidden inputs must be taken care of.</span>
                <span class="n">node_attributes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                    <span class="n">node_attributes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">att</span>
                        <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span>
                        <span class="k">else</span> <span class="n">oh</span><span class="o">.</span><span class="n">make_attribute</span><span class="p">(</span>
                            <span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                            <span class="bp">cls</span><span class="o">.</span><span class="n">_rename_inputs_in_subgraph</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">replacements</span><span class="p">),</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node_attributes</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span>
            <span class="n">new_node</span><span class="o">.</span><span class="n">attribute</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">node_attributes</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_node</span>
        <span class="k">return</span> <span class="n">node</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_rename_inputs_in_subgraph</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="n">GraphProto</span><span class="p">,</span> <span class="n">replacements</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">GraphProto</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Renames inputs.</span>
<span class="sd">        There is a weird case when one of the result defined in the inner context</span>
<span class="sd">        is overriden by the subgraph itself. We should assume this case never happens.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># graph inputs and outputs should not be changed, initializer as well</span>
        <span class="n">to_rename</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">replacements</span><span class="p">)</span>
        <span class="n">was_copied</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">input</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">to_rename</span><span class="p">:</span>
            <span class="c1"># An input of the graph is overrides one of the replacements.</span>
            <span class="c1"># The replacement should noe take place then.</span>
            <span class="n">replacements</span> <span class="o">=</span> <span class="n">replacements</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">input</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">to_rename</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">replacements</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
            <span class="n">to_rename</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">replacements</span><span class="p">)</span>
            <span class="n">was_copied</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">node</span><span class="p">:</span>
            <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_rename_inputs_in_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">replacements</span><span class="p">,</span> <span class="n">to_rename</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">to_rename</span><span class="p">:</span>
                <span class="c1"># An output overrides a replacement</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">was_copied</span><span class="p">:</span>
                    <span class="n">replacements</span> <span class="o">=</span> <span class="n">replacements</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">was_copied</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">to_rename</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">replacements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">to_rename</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">replacements</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">oh</span><span class="o">.</span><span class="n">make_graph</span><span class="p">(</span>
            <span class="n">nodes</span><span class="p">,</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">input</span><span class="p">,</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">output</span><span class="p">,</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">initializer</span><span class="p">,</span>
            <span class="n">sparse_initializer</span><span class="o">=</span><span class="n">graph</span><span class="o">.</span><span class="n">sparse_initializer</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="GraphBuilder.remove_identity_nodes">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.remove_identity_nodes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_identity_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes identity nodes. Returns the number of removed nodes</span>
<span class="sd">        and the number of added nodes.</span>

<span class="sd">        .. note::</span>

<span class="sd">            onnxruntime does not handle well when it is executing from domain</span>
<span class="sd">            *&#39;org.pytorch.aten&#39;* (ATen for example) which outputs results</span>
<span class="sd">            on CPU where the expected output is on CUDA. An identity node must be</span>
<span class="sd">            kept or inserted in that case. In that particular case, a node can be</span>
<span class="sd">            marked so that it does not get deleted: its name must start with</span>
<span class="sd">            ``&#39;_DONOTREMOVE_&#39;``.</span>

<span class="sd">        The default behavior is to keep the name coming from the node producing the result</span>
<span class="sd">        unless this name is an output.</span>
<span class="sd">        Shadowing is not an issue but there is also post-shadowing, a result is creating</span>
<span class="sd">        after a subgraph has created the same name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clean_values_cache</span><span class="p">()</span>
        <span class="c1"># make_initializer</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">begin_</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.remove_identity_nodes] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;-- starts with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="c1"># first pass: detect replacements</span>
        <span class="n">new_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">input_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">input_names_and_init</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">)</span> <span class="o">|</span> <span class="n">input_names</span>
        <span class="n">output_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>
        <span class="n">replacements</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">replacements_rev</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">removed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span> <span class="o">!=</span> <span class="s2">&quot;Identity&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_not_remove</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="n">new_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">output_names</span><span class="p">:</span>
                <span class="n">old_name</span><span class="p">,</span> <span class="n">new_name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">input_names_and_init</span>
                <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">output_names</span>
                <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">replacements</span>
                <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_context</span>  <span class="c1"># needed for subgraphs</span>
            <span class="p">):</span>
                <span class="n">old_name</span><span class="p">,</span> <span class="n">new_name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># the new name can be set for replacements as well</span>
            <span class="k">if</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="n">replacements</span><span class="p">:</span>
                <span class="n">new_name</span> <span class="o">=</span> <span class="n">replacements</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span>
                <span class="k">assert</span> <span class="n">new_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">replacements</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Name </span><span class="si">{</span><span class="n">old_name</span><span class="si">!r}</span><span class="s2"> still in </span><span class="si">{</span><span class="n">replacements</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;node.op_type=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;node.input=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="si">}</span><span class="s2">, node.output=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;input_names=</span><span class="si">{</span><span class="n">input_names</span><span class="si">}</span><span class="s2">, output_names=</span><span class="si">{</span><span class="n">output_names</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">old_name</span> <span class="ow">in</span> <span class="n">replacements_rev</span><span class="p">:</span>
                <span class="n">old_old_name</span> <span class="o">=</span> <span class="n">replacements_rev</span><span class="p">[</span><span class="n">old_name</span><span class="p">]</span>
                <span class="n">replacements</span><span class="p">[</span><span class="n">old_old_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_name</span>
                <span class="n">replacements_rev</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_old_name</span>
            <span class="k">if</span> <span class="n">old_name</span> <span class="ow">in</span> <span class="n">replacements</span><span class="p">:</span>
                <span class="n">replacements</span><span class="p">[</span><span class="n">replacements</span><span class="p">[</span><span class="n">old_name</span><span class="p">]]</span> <span class="o">=</span> <span class="n">new_name</span>
            <span class="k">assert</span> <span class="n">new_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">replacements</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Name </span><span class="si">{</span><span class="n">old_name</span><span class="si">!r}</span><span class="s2"> still in </span><span class="si">{</span><span class="n">replacements</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;node.op_type=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;node.input=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="si">}</span><span class="s2">, node.output=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;input_names=</span><span class="si">{</span><span class="n">input_names</span><span class="si">}</span><span class="s2">, output_names=</span><span class="si">{</span><span class="n">output_names</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">old_name</span> <span class="ow">in</span> <span class="n">replacements_rev</span><span class="p">:</span>
                <span class="c1"># A tricky case:</span>
                <span class="c1"># x -&gt; Identity -&gt; a -&gt; Identity -&gt; b -&gt; Flatten -&gt; output1</span>
                <span class="c1"># x -&gt; Identity -&gt; output0</span>
                <span class="c1"># How x should be renamed?</span>
                <span class="k">assert</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="n">output_names</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;replacement </span><span class="si">{</span><span class="n">old_name</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="n">new_name</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;is not possible because of &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">replacements_rev</span><span class="p">[</span><span class="n">old_name</span><span class="p">]</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="n">old_name</span><span class="si">}</span><span class="s2">] &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;and </span><span class="si">{</span><span class="n">new_name</span><span class="si">!r}</span><span class="s2"> is not an output&quot;</span>
                <span class="p">)</span>
                <span class="n">updates</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">replacements</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">old_name</span><span class="p">:</span>
                        <span class="n">updates</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_name</span>
                <span class="n">replacements</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">updates</span><span class="p">)</span>

            <span class="n">replacements</span><span class="p">[</span><span class="n">old_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_name</span>
            <span class="n">replacements_rev</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_name</span>

            <span class="c1"># verification</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">replacements</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">500</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">replacements</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">assert</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">replacements</span><span class="p">,</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;replacement </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2"> is not possible because of &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="n">replacements</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="si">}</span><span class="s2">], old_name=</span><span class="si">{</span><span class="n">old_name</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;new_name=</span><span class="si">{</span><span class="n">new_name</span><span class="si">!r}</span><span class="se">\n</span><span class="s2">---</span><span class="se">\n</span><span class="si">{</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="n">replacements</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
            <span class="n">removed</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># second pass: replacements in initializer</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.remove_identity_nodes] found &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">replacements</span><span class="p">)</span><span class="si">}</span><span class="s2"> replacements&quot;</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">replacements</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.remove_identity_nodes] &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;rename initializer </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2"> by </span><span class="si">{</span><span class="n">v</span><span class="si">!r}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="k">assert</span> <span class="s2">&quot;FakeTensor&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">[</span><span class="n">k</span><span class="p">])),</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;FakeTensor </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2"> cannot be an initializer &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">source</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;&quot;</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span>
                    <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">source</span>
                    <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;##</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">source</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">k_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_initializer</span><span class="p">(</span>
                    <span class="n">v</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                    <span class="n">itype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">k</span><span class="p">),</span>
                    <span class="n">shape</span><span class="o">=</span><span class="n">k_shape</span><span class="p">,</span>
                    <span class="n">cst</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">constants_</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                    <span class="n">existing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;GraphBuilder.remove_identity_nodes/from(</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">)</span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">allow_empty</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">k_shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">k_shape</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants_</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="c1"># third pass: replacements in node</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.remove_identity_nodes] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;kept </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">new_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> nodes&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">added</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">new_nodes</span><span class="p">:</span>
            <span class="n">repo</span> <span class="o">=</span> <span class="p">{</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span> <span class="k">if</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">replacements</span><span class="p">}</span>
            <span class="n">repi</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">o</span>
                <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enumerate_inputs_with_subgraph_plus_hidden</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">replacements</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">repi</span> <span class="ow">or</span> <span class="n">repo</span><span class="p">:</span>
                <span class="n">new_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">replacements</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">]</span>
                <span class="n">new_outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">replacements</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">]</span>
                <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">new_inputs</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">new_outputs</span><span class="p">)</span> <span class="ow">in</span> <span class="p">({</span><span class="s2">&quot;&quot;</span><span class="p">},</span> <span class="nb">set</span><span class="p">()),</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Node type </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> is incorrectly replaced &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="n">new_inputs</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="n">new_outputs</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;replacements are</span><span class="se">\n</span><span class="si">{</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="n">replacements</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.remove_identity_nodes] &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;node </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">:&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="n">new_inputs</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="n">new_outputs</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="n">new_node</span> <span class="o">=</span> <span class="n">node</span>
                <span class="k">del</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[:]</span>
                <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_inputs</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[:]</span>
                <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_outputs</span><span class="p">)</span>

                <span class="c1"># oh.make_node(</span>
                <span class="c1">#    node.op_type,</span>
                <span class="c1">#    new_inputs,</span>
                <span class="c1">#    new_outputs,</span>
                <span class="c1">#    domain=node.domain,</span>
                <span class="c1">#    name=node.name,</span>
                <span class="c1"># )</span>

                <span class="n">added</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">removed</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_subgraph_possibly</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                    <span class="c1"># Hidden inputs must be taken care of.</span>
                    <span class="n">short_replacements</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">replacements</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">repi</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">replacements</span><span class="p">}</span>
                    <span class="n">node_attributes</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                        <span class="n">node_attributes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">att</span>
                            <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span>
                            <span class="k">else</span> <span class="n">oh</span><span class="o">.</span><span class="n">make_attribute</span><span class="p">(</span>
                                <span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_rename_inputs_in_subgraph</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">short_replacements</span><span class="p">),</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">del</span> <span class="n">new_node</span><span class="o">.</span><span class="n">attribute</span><span class="p">[:]</span>
                    <span class="n">new_node</span><span class="o">.</span><span class="n">attribute</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">node_attributes</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new_node</span><span class="o">.</span><span class="n">input</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">new_node</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">update_node_constant</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">new_node</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.remove_identity_nodes] ends with &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> nodes in &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">begin_</span><span class="si">}</span><span class="s2"> seconds&quot;</span>
            <span class="p">)</span>

        <span class="c1"># fourth pass: simplify the graph.</span>
        <span class="n">identity_outputs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span> <span class="o">!=</span> <span class="s2">&quot;Identity&quot;</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">domain</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">anc</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">anc</span> <span class="ow">in</span> <span class="n">identity_outputs</span><span class="p">:</span>
                <span class="n">anc</span> <span class="o">=</span> <span class="n">identity_outputs</span><span class="p">[</span><span class="n">anc</span><span class="p">]</span>
            <span class="n">identity_outputs</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">anc</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">new_inputs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">rename</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">identity_outputs</span><span class="p">:</span>
                    <span class="n">new_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">identity_outputs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">rename</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rename</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[:]</span>
                <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_inputs</span><span class="p">)</span>

        <span class="c1"># results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_refresh_values_cache</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">removed</span><span class="p">,</span> <span class="n">added</span></div>


<div class="viewcode-block" id="GraphBuilder.remove_duplicated_shape_nodes">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.remove_duplicated_shape_nodes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_duplicated_shape_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replaces duplicated operator Shape.</span>
<span class="sd">        If one of them return the same output, it is replace by an identity node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">changes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span> <span class="o">==</span> <span class="s2">&quot;Shape&quot;</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_as_shape</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
                        <span class="n">cache</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">changes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">oh</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
                            <span class="s2">&quot;Identity&quot;</span><span class="p">,</span>
                            <span class="p">[</span><span class="n">cache</span><span class="p">[</span><span class="n">value</span><span class="p">]],</span>
                            <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;remove_duplicated_shape_nodes&quot;</span><span class="p">,</span>
                            <span class="n">doc_string</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">doc_string</span><span class="p">,</span>
                        <span class="p">)</span>
        <span class="k">if</span> <span class="n">changes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">changes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">changes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">changes</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_position_msg</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">NodeProto</span><span class="p">],</span> <span class="n">around</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="s2">&quot;Builds an error message.&quot;</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">posi</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">pos</span><span class="p">[</span><span class="n">make_idn</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                <span class="n">pos</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">input</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">o</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">posi</span><span class="p">:</span>
                    <span class="n">posi</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">)</span><span class="si">}</span><span class="s2">) -&gt; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">)</span><span class="si">}</span><span class="s2">]  -- </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">:</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  -&gt; pos(</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">pos</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39; -&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">posi</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39; -&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  &lt;- pos(</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">pos</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39; -&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">posi</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39; -&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">around</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>

        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;---&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">around</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span> <span class="n">around</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;P</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">n</span><span class="o">.</span><span class="n">op_type</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">input</span><span class="p">)</span><span class="si">}</span><span class="s2">) -&gt; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">output</span><span class="p">)</span><span class="si">}</span><span class="s2">]                   -- </span><span class="si">{</span><span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_needed_at_first_at</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Needed by insert_and_remove_nodes.&quot;</span>
        <span class="n">needed_at</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">first_at</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">needed_at</span><span class="p">:</span>
                    <span class="n">needed_at</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">first_at</span><span class="p">:</span>
                    <span class="n">first_at</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">needed_at</span><span class="p">,</span> <span class="n">first_at</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_move_node_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tries to move a node at position pos closed to the beginning.&quot;&quot;&quot;</span>
        <span class="n">the_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
        <span class="n">first_at</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">pos</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">first_at</span><span class="p">:</span>
                    <span class="n">first_at</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">can_be</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">first_at</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">the_node</span><span class="o">.</span><span class="n">input</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">can_be</span> <span class="o">&gt;=</span> <span class="n">pos</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">can_be</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">can_be</span><span class="p">:</span><span class="n">pos</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">can_be</span><span class="p">]</span> <span class="o">=</span> <span class="n">the_node</span>
        <span class="k">return</span> <span class="n">can_be</span>

<div class="viewcode-block" id="GraphBuilder.insert_and_remove_nodes">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.insert_and_remove_nodes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">insert_and_remove_nodes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">insert_at</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">new_nodes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">NodeProto</span><span class="p">],</span>
        <span class="n">removed</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">opsets</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">debug</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">stats</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">NodeProto</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inserts new nodes and removes others.</span>

<span class="sd">        :param insert_at: insert the new nodes at this position,</span>
<span class="sd">            if empty, the function guesses where to add them</span>
<span class="sd">        :param new_nodes: list of nodes to insert</span>
<span class="sd">        :param removed: list of nodes to removed (based on their positions)</span>
<span class="sd">        :param opsets: opsets used</span>
<span class="sd">        :param debug: anything added to exception messages</span>
<span class="sd">        :param stats: to get information about time processing</span>
<span class="sd">        :return: list of removed nodes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">begin</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">insert_at</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">removed</span> <span class="ow">or</span> <span class="nb">min</span><span class="p">(</span><span class="n">removed</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">insert_at</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The position </span><span class="si">{</span><span class="n">insert_at</span><span class="si">}</span><span class="s2"> must be higher than the position &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;of the removed nodes </span><span class="si">{</span><span class="n">removed</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">remove_constants</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">memo</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">removed</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unable to remove node position </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, there are </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;type is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">op_type</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span><span class="p">:</span>
                <span class="c1"># already marked as removed</span>
                <span class="k">continue</span>
            <span class="k">assert</span> <span class="n">n</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_not_remove</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Node </span><span class="si">{</span><span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> marked as &#39;DONOTREMOVE&#39; cannot be removed &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;for node </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> and type </span><span class="si">{</span><span class="n">n</span><span class="o">.</span><span class="n">op_type</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">memo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="c1"># We need to remove the constant.</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants_</span><span class="p">:</span>
                    <span class="n">remove_constants</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># finding the position and updating the opsets if needed.</span>
        <span class="n">n_existing</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">new_nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enumerate_inputs_with_subgraph_plus_hidden</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span><span class="p">:</span>
                    <span class="c1"># optional input</span>
                    <span class="k">continue</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Input </span><span class="si">{</span><span class="n">i</span><span class="si">!r}</span><span class="s2"> does not exist for node </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;debug=</span><span class="si">{</span><span class="n">debug</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">---------</span><span class="se">\n</span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
                    <span class="c1"># connecting to existing output</span>
                    <span class="n">n_existing</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">o</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;insert_and_remove_nodes_</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">o</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">node_domain</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">domain</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span>
            <span class="k">if</span> <span class="n">node_domain</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">opsets</span> <span class="ow">and</span> <span class="n">node_domain</span> <span class="ow">in</span> <span class="n">opsets</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">compatible_opsets</span><span class="p">(</span>
                        <span class="n">node_domain</span><span class="p">,</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="p">,</span>
                        <span class="n">current</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">[</span><span class="n">node_domain</span><span class="p">],</span>
                        <span class="n">new_version</span><span class="o">=</span><span class="n">opsets</span><span class="p">[</span><span class="n">node_domain</span><span class="p">],</span>
                    <span class="p">),</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Incompatible opset for node </span><span class="si">{</span><span class="n">node_domain</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;from domain </span><span class="si">{</span><span class="n">node_domain</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;current is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">[</span><span class="n">node_domain</span><span class="p">]</span><span class="si">}</span><span class="s2">, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;new is </span><span class="si">{</span><span class="n">opsets</span><span class="p">[</span><span class="n">node_domain</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">opsets</span> <span class="ow">and</span> <span class="n">node_domain</span> <span class="ow">in</span> <span class="n">opsets</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">[</span><span class="n">node_domain</span><span class="p">]</span> <span class="o">=</span> <span class="n">opsets</span><span class="p">[</span><span class="n">node_domain</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">[</span><span class="n">node_domain</span><span class="p">]</span> <span class="o">=</span> <span class="n">choose_consistent_domain_opset</span><span class="p">(</span>
                        <span class="n">node_domain</span><span class="p">,</span>
                        <span class="n">opsets</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="k">assert</span> <span class="n">n_existing</span><span class="p">,</span> <span class="s2">&quot;Any output of the new node is connected to existing names.&quot;</span>
        <span class="k">if</span> <span class="n">insert_at</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_nodes</span><span class="p">):</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">NodeProto</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="si">}</span><span class="s2"> for a node&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">insert_at</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_make_node_set_type_shape_constant</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_make_node_set_type_shape</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">simple_update_value_shape_with_node</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="n">n</span><span class="o">.</span><span class="n">domain</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span>
                    <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_subgraph_possibly</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_sequence</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">input</span> <span class="k">if</span> <span class="n">o</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_sequence</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">output</span> <span class="k">if</span> <span class="n">o</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">input</span> <span class="k">if</span> <span class="n">o</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">output</span> <span class="k">if</span> <span class="n">o</span><span class="p">)</span>
                <span class="p">),</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Missing one output type in node=[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_node</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="si">}</span><span class="s2">], &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;input_has_type=</span><span class="si">{</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;-&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">n</span><span class="o">.</span><span class="n">input</span><span class="p">]</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;output_has_type=</span><span class="si">{</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;-&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">n</span><span class="o">.</span><span class="n">output</span><span class="p">]</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;io_has_sequence=</span><span class="si">{</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_sequence</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;-&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">n</span><span class="o">.</span><span class="n">input</span><span class="p">]</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_sequence</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;-&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">n</span><span class="o">.</span><span class="n">output</span><span class="p">]</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">stats</span><span class="p">:</span>
                <span class="n">stats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="nb">dict</span><span class="p">(</span>
                        <span class="n">pattern</span><span class="o">=</span><span class="s2">&quot;insert_and_remove_nodes&quot;</span><span class="p">,</span>
                        <span class="n">time_in</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">begin</span><span class="p">,</span>
                        <span class="n">exit_point</span><span class="o">=</span><span class="s2">&quot;insert_at&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">memo</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

        <span class="c1"># Needs to insert the nodes at the right location.</span>
        <span class="c1"># Let&#39;s find out where the best position is.</span>
        <span class="n">needed_at</span><span class="p">,</span> <span class="n">first_at</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_needed_at_first_at</span><span class="p">()</span>

        <span class="c1"># First loop to check positions are ok otherwise move a node or two.</span>
        <span class="n">needs_sort</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">inode</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">inode</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_nodes</span><span class="p">):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">new_nodes</span><span class="p">[</span><span class="n">inode</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">:</span>
                <span class="n">min_position</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">first_at</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span> <span class="k">if</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># a constant node</span>
                <span class="n">min_position</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">max_position</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">needed_at</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">min_position</span> <span class="o">&lt;=</span> <span class="n">max_position</span><span class="p">:</span>
                <span class="n">inode</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>

            <span class="c1"># trouble, let&#39;s assume one move is ok.</span>
            <span class="n">mini</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">first_at</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span> <span class="k">if</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">pos</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">mini</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">output</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Name </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> should be at node position </span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">new_position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_move_node_position</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">new_position</span><span class="p">:</span>
                <span class="n">needs_sort</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">position_to_insert</span> <span class="o">=</span> <span class="n">mini</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.insert_and_remove_nodes] needs full sort &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;to add new nodes at because node at position </span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2"> &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;cannot be moved.</span><span class="se">\n</span><span class="s2">----</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_position_msg</span><span class="p">([</span><span class="n">node</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-------</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_position_msg</span><span class="p">(</span><span class="n">new_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="k">break</span>
            <span class="n">needed_at</span><span class="p">,</span> <span class="n">first_at</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_needed_at_first_at</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">needs_sort</span><span class="p">:</span>
            <span class="c1"># Requires full sort.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span> <span class="n">position_to_insert</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[:</span><span class="n">pos</span><span class="p">],</span> <span class="o">*</span><span class="n">new_nodes</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">:]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">topological_sort</span><span class="p">(</span><span class="n">stats</span><span class="p">)</span>
            <span class="n">new_nodes_p</span> <span class="o">=</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">new_nodes</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># guess the position to insert the nodes at</span>
            <span class="c1"># the order of the new nodes is consistent but it may have to be changed</span>
            <span class="c1"># if it does not fit the existing order</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">err_msg</span><span class="p">():</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">new_nodes</span><span class="p">:</span>
                    <span class="n">first</span> <span class="o">=</span> <span class="s2">&quot; - &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">first_at</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">input</span> <span class="k">if</span> <span class="n">i</span><span class="p">])</span>
                    <span class="n">need</span> <span class="o">=</span> <span class="s2">&quot; - &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">needed_at</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">output</span> <span class="k">if</span> <span class="n">i</span><span class="p">])</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">first</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">need</span><span class="si">}</span><span class="s2"> -- </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_node</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

            <span class="n">insert_needed_at</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">insert_first_at</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">inserted_at</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">new_nodes_p</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">init</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_nodes</span><span class="p">):</span>
                <span class="n">min_position</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">first_at</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span> <span class="k">if</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="p">)</span>
                <span class="n">max_position</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">needed_at</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>

                <span class="k">assert</span> <span class="n">min_position</span> <span class="o">&lt;=</span> <span class="n">max_position</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unable to insert node </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;min_position=</span><span class="si">{</span><span class="n">min_position</span><span class="si">}</span><span class="s2">, max_position=</span><span class="si">{</span><span class="n">max_position</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;len(nodes)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">, previous insertions=</span><span class="si">{</span><span class="n">inserted_at</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;insert_needed_at=</span><span class="si">{</span><span class="n">insert_needed_at</span><span class="si">}</span><span class="s2">, insert_first_at=</span><span class="si">{</span><span class="n">insert_first_at</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;inserted_at=</span><span class="si">{</span><span class="n">inserted_at</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_position_msg</span><span class="p">([</span><span class="n">node</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-------</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_position_msg</span><span class="p">(</span><span class="n">new_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

                <span class="n">local_min_position</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="nb">max</span><span class="p">(</span><span class="n">insert_first_at</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span> <span class="k">if</span> <span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="p">)</span>
                <span class="n">local_max_position</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">insert_needed_at</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>

                <span class="k">assert</span> <span class="n">local_min_position</span> <span class="o">&lt;=</span> <span class="n">local_max_position</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unable to insert node </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;local_min_position=</span><span class="si">{</span><span class="n">local_min_position</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;local_max_position=</span><span class="si">{</span><span class="n">local_max_position</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;len(nodes)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">, previous insertions=</span><span class="si">{</span><span class="n">inserted_at</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;insert_needed_at=</span><span class="si">{</span><span class="n">insert_needed_at</span><span class="si">}</span><span class="s2">, insert_first_at=</span><span class="si">{</span><span class="n">insert_first_at</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">----</span><span class="se">\n</span><span class="si">{</span><span class="n">err_msg</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">---</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;insert_needed_at=</span><span class="si">{</span><span class="n">insert_needed_at</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;insert_first_at=</span><span class="si">{</span><span class="n">insert_first_at</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

                <span class="n">insert_position</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">min_position</span><span class="p">,</span> <span class="n">local_min_position</span><span class="p">)</span>

                <span class="k">assert</span> <span class="n">insert_position</span> <span class="o">&lt;=</span> <span class="n">max_position</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Insertion will fail, for output </span><span class="si">{</span><span class="n">o</span><span class="si">!r}</span><span class="s2"> from node</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">because insert_position=&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">insert_position</span><span class="si">}</span><span class="s2">, local_min_position=</span><span class="si">{</span><span class="n">local_min_position</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;local_max_position=</span><span class="si">{</span><span class="n">local_max_position</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;min_position=</span><span class="si">{</span><span class="n">min_position</span><span class="si">}</span><span class="s2">, max_position=</span><span class="si">{</span><span class="n">max_position</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">----</span><span class="se">\n</span><span class="si">{</span><span class="n">err_msg</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">---</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;insert_needed_at=</span><span class="si">{</span><span class="n">insert_needed_at</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;insert_first_at=</span><span class="si">{</span><span class="n">insert_first_at</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

                <span class="n">new_nodes_p</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">insert_position</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span><span class="p">:</span>
                        <span class="n">insert_needed_at</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                            <span class="n">insert_position</span><span class="p">,</span> <span class="n">insert_needed_at</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">insert_position</span><span class="p">)</span>
                        <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span><span class="p">:</span>
                        <span class="n">insert_first_at</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                            <span class="n">insert_position</span><span class="p">,</span> <span class="n">insert_first_at</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">insert_position</span><span class="p">)</span>
                        <span class="p">)</span>

            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_nodes_p</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Length mismatch between len(new_nodes)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">new_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> == &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;len(new_nodes_p)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">new_nodes_p</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">new_nodes_p</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

            <span class="c1"># do the addition</span>
            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">new_nodes_p</span><span class="p">):</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">NodeProto</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="si">}</span><span class="s2"> for a node&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="c1"># finalization</span>
        <span class="n">init_nams</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">new_nodes_p</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">init_nams</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_node_set_type_shape_constant</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_node_set_type_shape</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simple_update_value_shape_with_node</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">n</span><span class="o">.</span><span class="n">domain</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span>
                <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">input</span> <span class="k">if</span> <span class="n">o</span><span class="p">)</span>
                <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">output</span> <span class="k">if</span> <span class="n">o</span><span class="p">)</span>
            <span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Missing one output type in node=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_node</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;input_has_type=</span><span class="si">{</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">n</span><span class="o">.</span><span class="n">input</span><span class="p">]</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;output_has_type=</span><span class="si">{</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">n</span><span class="o">.</span><span class="n">output</span><span class="p">]</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="c1"># final removal of the unneeded constants</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">remove_constants</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants_</span><span class="p">[</span><span class="n">o</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_refresh_values_cache</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">stats</span><span class="p">:</span>
            <span class="n">stats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">pattern</span><span class="o">=</span><span class="s2">&quot;insert_and_remove_nodes&quot;</span><span class="p">,</span>
                    <span class="n">time_in</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">begin</span><span class="p">,</span>
                    <span class="n">exit_point</span><span class="o">=</span><span class="s2">&quot;topological_sort&quot;</span> <span class="k">if</span> <span class="n">needs_sort</span> <span class="k">else</span> <span class="s2">&quot;positions&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">memo</span></div>


<div class="viewcode-block" id="GraphBuilder.topological_sort">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.topological_sort">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">topological_sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stats</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reorders the nodes in order to make sure no node is using an output</span>
<span class="sd">        created by a node after.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Gathering IO</span>
        <span class="n">begin</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">output_index_node</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_names</span><span class="p">}</span>  <span class="c1"># noqa: C420</span>
        <span class="n">output_index_node</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">})</span>  <span class="c1"># noqa: C420</span>
        <span class="n">ios</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">):</span>
            <span class="n">unique</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">)</span>
            <span class="n">subgraphs</span> <span class="o">=</span> <span class="p">[</span><span class="n">att</span><span class="o">.</span><span class="n">g</span> <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span> <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">subgraphs</span><span class="p">:</span>
                <span class="n">unique</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_hidden_inputs</span><span class="p">(</span><span class="n">sub</span><span class="p">))</span>
            <span class="n">ios</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                <span class="n">output_index_node</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="c1"># Begin sorting</span>
        <span class="n">new_order</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))]</span>
        <span class="n">it</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">changes</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)):</span>
                <span class="n">inputs</span> <span class="o">=</span> <span class="n">ios</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">inputs</span><span class="p">:</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">output_index_node</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">]</span>
                    <span class="n">minis</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">minis</span><span class="p">:</span>
                        <span class="n">mini</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">minis</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">mini</span> <span class="o">&gt;</span> <span class="n">new_order</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                            <span class="n">changes</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">new_order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mini</span>
            <span class="k">if</span> <span class="n">changes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">it</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">it</span><span class="si">}</span><span class="s2"> (with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">) iterations were necessary to sort the graph. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;There may be a cycle.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="n">sorted_nodes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">node</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">__</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">new_order</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">sorted_nodes</span>
        <span class="k">if</span> <span class="n">stats</span><span class="p">:</span>
            <span class="n">stats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">pattern</span><span class="o">=</span><span class="s2">&quot;topological_sort&quot;</span><span class="p">,</span> <span class="n">time_in</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">begin</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">stats</span> <span class="ow">or</span> <span class="p">[],</span> <span class="s2">&quot;topological_sort&quot;</span><span class="p">)</span></div>


    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_clean_shapes</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">proto</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">GraphProto</span><span class="p">,</span> <span class="n">ModelProto</span><span class="p">]):</span>
        <span class="c1"># cleaning unresolved shapes</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="n">ModelProto</span><span class="p">):</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_clean_shapes</span><span class="p">(</span><span class="n">proto</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">new_shapes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sh</span> <span class="ow">in</span> <span class="n">proto</span><span class="o">.</span><span class="n">value_info</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sh</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">tensor_type</span><span class="o">.</span><span class="n">elem_type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">new_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">proto</span><span class="o">.</span><span class="n">value_info</span><span class="p">[:]</span>
        <span class="n">proto</span><span class="o">.</span><span class="n">value_info</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_shapes</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_shape_types_with_proto_one_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">ValueInfoProto</span><span class="p">):</span>
        <span class="n">itype</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">tensor_type</span><span class="o">.</span><span class="n">elem_type</span>
        <span class="k">if</span> <span class="n">itype</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">itype</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">d</span><span class="o">.</span><span class="n">dim_param</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">dim_param</span>
                <span class="k">else</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">dim_value</span> <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">dim_value</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_dimension_name</span><span class="p">(</span><span class="s2">&quot;NEWDIM&quot;</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">val</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">tensor_type</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">dim</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">)</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
            <span class="c1"># Some converters uses -1 to specify a dynamic dimension.</span>
            <span class="c1"># We replace the value with a string</span>
            <span class="n">new_shape</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">new_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="n">dyn_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">val</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">new_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dyn_name</span><span class="p">)</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sh</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">make_dynamic_object</span><span class="p">(</span><span class="n">sh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">(</span><span class="n">sh</span><span class="p">),</span> <span class="n">input_name</span><span class="o">=</span><span class="n">val</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="mi">0</span> <span class="ow">in</span> <span class="n">shape</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">min</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">max</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="c1"># something like (0, 0, 0), we skip.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[_update_shape_types_with_proto_one_result] cannot &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;update shape(</span><span class="si">{</span><span class="n">val</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">) with </span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[_update_shape_types_with_proto_one_result] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;update shape(</span><span class="si">{</span><span class="n">val</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">) with </span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_shape</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">exc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_zero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_shape_types_with_proto</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">proto</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">GraphProto</span><span class="p">,</span> <span class="n">ModelProto</span><span class="p">],</span>
        <span class="n">infer_shapes_options</span><span class="p">:</span> <span class="n">InferShapesOptions</span> <span class="o">=</span> <span class="n">InferShapesOptions</span><span class="o">.</span><span class="n">NONE</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the shapes and types for an existing model.</span>

<span class="sd">        :param proto: model proto</span>
<span class="sd">        :param infer_shapes_options: infer shapes to fill information about type and shapes</span>
<span class="sd">            run shape inference, if the value is `&#39;new&#39;`,</span>
<span class="sd">            existing shapes are ignored</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">proto</span><span class="p">,</span> <span class="p">(</span><span class="n">GraphProto</span><span class="p">,</span> <span class="n">ModelProto</span><span class="p">)</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">proto</span><span class="p">)</span><span class="si">}</span><span class="s2"> for proto&quot;</span>
        <span class="n">proto_graph</span> <span class="o">=</span> <span class="n">proto</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="n">GraphProto</span><span class="p">)</span> <span class="k">else</span> <span class="n">proto</span><span class="o">.</span><span class="n">graph</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">begin_</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._update_shape_types_with_proto] -- starts with &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> nodes and </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">proto_graph</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;value_info&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;shapes.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># if infer_shapes_options &amp; InferShapesOptions.NEW:</span>
        <span class="c1">#     clean_shapes(proto)</span>
        <span class="k">if</span> <span class="n">infer_shapes_options</span> <span class="o">&amp;</span> <span class="n">InferShapesOptions</span><span class="o">.</span><span class="n">ONNX</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[GraphBuilder._update_shape_types_with_proto] infer shapes&quot;</span><span class="p">)</span>
            <span class="n">new_proto</span> <span class="o">=</span> <span class="n">onnx_infer_shapes</span><span class="p">(</span>
                <span class="n">proto</span><span class="p">,</span> <span class="n">data_prop</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">infer_shapes_options</span> <span class="o">&amp;</span> <span class="n">InferShapesOptions</span><span class="o">.</span><span class="n">DATA_PROP</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;[GraphBuilder._update_shape_types_with_proto] &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;infer shapes done </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">begin_</span><span class="si">}</span><span class="s2"> seconds&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clean_shapes</span><span class="p">(</span><span class="n">new_proto</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;[GraphBuilder._update_shape_types_with_proto] &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;_clean_shapes after </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">begin_</span><span class="si">}</span><span class="s2"> seconds&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_proto</span> <span class="o">=</span> <span class="n">proto</span>

        <span class="n">new_proto_graph</span> <span class="o">=</span> <span class="n">new_proto</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_proto</span><span class="p">,</span> <span class="n">GraphProto</span><span class="p">)</span> <span class="k">else</span> <span class="n">new_proto</span><span class="o">.</span><span class="n">graph</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">new_proto_graph</span><span class="p">,</span> <span class="s2">&quot;value_info&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._update_shape_types_with_proto] ends in &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">begin_</span><span class="si">}</span><span class="s2"> seconds.&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">begin_</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._update_shape_types_with_proto] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;walk through </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">proto_graph</span><span class="o">.</span><span class="n">value_info</span><span class="p">)</span><span class="si">}</span><span class="s2"> shapes.&quot;</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">new_proto_graph</span><span class="o">.</span><span class="n">value_info</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_shape_types_with_proto_one_result</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">infer_shapes_options</span> <span class="o">&amp;</span> <span class="n">InferShapesOptions</span><span class="o">.</span><span class="n">BUILDER</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">infer_shapes</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._update_shape_types_with_proto] ends in &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">begin_</span><span class="si">}</span><span class="s2"> seconds.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_make_node_set_type_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">NodeProto</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Updates shapes for a node.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">+=</span> <span class="s2">&quot;#Io1&quot;</span>
            <span class="n">set_shape_type_op_any</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Missing type means it is probably coming from an inlined function.</span>
            <span class="n">node</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="s2">&quot;#Io3&quot;</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">else</span> <span class="s2">&quot;#Io2&quot;</span>
            <span class="p">)</span>
            <span class="n">set_shape_type_custom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

<div class="viewcode-block" id="GraphBuilder.infer_shapes">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.infer_shapes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">infer_shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">DYNAMIC_SHAPE</span><span class="p">,</span> <span class="n">DYNAMIC_SHAPE</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Runs custom shape inference. Returns the updates.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">begin</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[GraphBuilder.infer_shapes]&quot;</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">old_shapes</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simple_update_value_shape_with_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_node_set_type_shape</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">new_shapes</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">]</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">old_shapes</span><span class="p">,</span> <span class="n">new_shapes</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">:</span>
                    <span class="n">diff</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">diff</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.infer_shapes] &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;update node </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;name </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, updates=</span><span class="si">{</span><span class="n">diff</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.infer_shapes] node </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;name </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, shape=</span><span class="si">{</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="n">new_shapes</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.infer_shapes] done in &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">begin</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span><span class="si">}</span><span class="s2"> changes&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_update_structures_with_proto</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">proto</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ModelProto</span><span class="p">,</span> <span class="n">GraphProto</span><span class="p">],</span> <span class="n">infer_shapes_options</span><span class="p">:</span> <span class="n">InferShapesOptions</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Updates the shapes and types for an existing model.&quot;&quot;&quot;</span>
        <span class="n">proto_graph</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">graph</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="n">ModelProto</span><span class="p">)</span> <span class="k">else</span> <span class="n">proto</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">begin_</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._update_structures_with_proto] -- starts with &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">proto_graph</span><span class="o">.</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2"> nodes&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">existing_metadata_props</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="n">key</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">proto</span><span class="o">.</span><span class="n">metadata_props</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="p">(</span><span class="n">FunctionProto</span><span class="p">,</span> <span class="n">ModelProto</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span> <span class="o">=</span> <span class="p">{</span><span class="n">d</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span> <span class="n">d</span><span class="o">.</span><span class="n">version</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">proto</span><span class="o">.</span><span class="n">opset_import</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">,</span> <span class="s2">&quot;opsets must be not None&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir_version</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="n">ModelProto</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ir_version</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">ir_version</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions_builder</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proto_graph</span><span class="p">,</span> <span class="n">GraphProto</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">proto_graph</span><span class="o">.</span><span class="n">initializer</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_initializer</span><span class="p">(</span>
                    <span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">i</span><span class="p">,</span>
                    <span class="n">allow_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;GraphBuilder._update_structures_with_proto.1/from(</span><span class="si">{</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">proto_graph</span><span class="o">.</span><span class="n">sparse_initializer</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_initializer</span><span class="p">(</span>
                    <span class="n">i</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">i</span><span class="p">,</span>
                    <span class="n">allow_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;GraphBuilder._update_structures_with_proto.2/from(</span><span class="si">{</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="n">ModelProto</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">proto</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_function</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">proto_graph</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value_info</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="n">proto_graph</span><span class="o">.</span><span class="n">value_info</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">infer_shapes_options</span> <span class="o">&amp;</span> <span class="n">InferShapesOptions</span><span class="o">.</span><span class="n">NEW</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">[]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proto_graph</span><span class="p">,</span> <span class="n">GraphProto</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">proto_graph</span><span class="o">.</span><span class="n">input</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">proto_graph</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">proto_graph</span><span class="o">.</span><span class="n">input</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">proto_graph</span><span class="p">,</span> <span class="n">FunctionProto</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">proto_graph</span><span class="p">)</span><span class="si">}</span><span class="s2"> for proto_graph&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">oh</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">TEMPLATE_TYPE</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">proto_graph</span><span class="o">.</span><span class="n">input</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">oh</span><span class="o">.</span><span class="n">make_tensor_value_info</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">TEMPLATE_TYPE</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">proto_graph</span><span class="o">.</span><span class="n">output</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">proto_graph</span><span class="o">.</span><span class="n">input</span><span class="p">)</span>

        <span class="n">available_shapes</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">{</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">proto_graph</span><span class="o">.</span><span class="n">value_info</span><span class="p">}</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">proto_graph</span><span class="p">,</span> <span class="s2">&quot;value_info&quot;</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">{}</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_update_structures_with_proto_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">tensor_type</span><span class="o">.</span><span class="n">elem_type</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">tensor_type</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="n">d</span><span class="o">.</span><span class="n">dim_param</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">dim_param</span>
                        <span class="k">else</span> <span class="p">(</span>
                            <span class="n">d</span><span class="o">.</span><span class="n">dim_value</span>
                            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">dim_value</span>
                            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_dimension_name</span><span class="p">(</span><span class="s2">&quot;UNKNOWNDIM&quot;</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">tensor_type</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">dim</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">)</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
                    <span class="c1"># Some converters uses -1 to specify a dynamic dimension.</span>
                    <span class="c1"># We replace the value with a string</span>
                    <span class="n">new_shape</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">new_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                            <span class="k">continue</span>
                        <span class="n">dyn_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="n">new_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dyn_name</span><span class="p">)</span>
                    <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
                <span class="n">new_shape</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">sh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sh</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">sh</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">new_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span>
                            <span class="k">continue</span>
                        <span class="c1"># We replace it with a letter.</span>
                        <span class="n">sh</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;dim_</span><span class="si">{</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">new_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">make_dynamic_object</span><span class="p">(</span>
                        <span class="n">sh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">(</span><span class="n">sh</span><span class="p">),</span> <span class="n">input_name</span><span class="o">=</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span>
                    <span class="p">)</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_shape</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="n">TensorProto</span><span class="o">.</span><span class="n">INT64</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="nb">tuple</span><span class="p">)</span>
                <span class="ow">and</span> <span class="s2">&quot;dim&quot;</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">name</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_value_shape</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="p">,))</span>

        <span class="n">need_identity_removal</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">new_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">:</span>
                <span class="c1"># This is a subgraph, let&#39;s import information from</span>
                <span class="c1"># the parent graph.</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_import_context_from_parent_graph</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="c1"># ready to add the node</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unique_names</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
            <span class="n">shape_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simple_update_value_shape_with_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_unique_node_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">shape_set</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_make_node_set_type_shape_constant</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="p">{})</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_make_node_set_type_shape</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_update_structures_with_proto_n_</span><span class="si">{</span><span class="n">o</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">new_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span> <span class="o">==</span> <span class="s2">&quot;SequenceConstruct&quot;</span><span class="p">:</span>
                <span class="n">dtypes</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">]</span>
                <span class="n">ranks</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">]</span>
                <span class="n">unique_dtypes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dtypes</span><span class="p">)</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">unique_dtypes</span><span class="p">:</span>
                    <span class="n">unique_dtypes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">u</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">unique_dtypes</span> <span class="k">if</span> <span class="n">u</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_dtypes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span>
                                <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                <span class="sa">f</span><span class="s2">&quot;_update_structures_with_proto_SC1_</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_sequence</span><span class="p">(</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shapes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ranks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unknown</span><span class="o">=</span><span class="kc">True</span>
                        <span class="p">)</span>
                        <span class="n">new_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                        <span class="k">continue</span>

                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_dtypes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;A sequence has distinct dtype: </span><span class="si">{</span><span class="n">dtypes</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(unique_dtypes=</span><span class="si">{</span><span class="n">unique_dtypes</span><span class="si">}</span><span class="s2">), node.name=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;node.input=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;_update_structures_with_proto_SC2_</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_sequence</span><span class="p">(</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="nb">next</span><span class="p">(</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">unique_dtypes</span><span class="p">),</span>
                    <span class="n">shapes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">ranks</span><span class="o">=</span><span class="n">ranks</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">new_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span> <span class="o">==</span> <span class="s2">&quot;SequenceAt&quot;</span><span class="p">:</span>
                <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_constant</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">computed_value</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sequence</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="s2">&quot;dtype&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="c1"># More than one type is allowed in torch sequences.</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">position</span><span class="p">)]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;_update_structures_with_proto_SAt_</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">seq</span><span class="p">[</span><span class="s2">&quot;ranks&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">new_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="n">rank</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="s2">&quot;ranks&quot;</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="n">position</span><span class="p">)]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_rank</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rank</span><span class="p">)</span>
                <span class="n">new_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">assert</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;SplitToSequence&quot;</span><span class="p">,</span> <span class="s2">&quot;SequenceErase&quot;</span><span class="p">},</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Sequence operators are not supported yet and op_type=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(name=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">).&quot;</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span> <span class="o">==</span> <span class="s2">&quot;Constant&quot;</span><span class="p">:</span>
                <span class="n">exist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_exact_same_constant</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">exist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">oh</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
                        <span class="s2">&quot;Identity&quot;</span><span class="p">,</span>
                        <span class="p">[</span><span class="n">exist</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                        <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;._update_structures_with_proto&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">replaced</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">need_identity_removal</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_constant_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="n">replaced</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">update_node_constant</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;_update_structures_with_proto_Cst_</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="n">replaced</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_shape</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">allow_zero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_device</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_device</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_shape</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tensor_shape</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">allow_zero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tensor_type</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span> <span class="o">==</span> <span class="s2">&quot;ConstantOfShape&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">exist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_exact_same_constant</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">exist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">oh</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
                        <span class="s2">&quot;Identity&quot;</span><span class="p">,</span>
                        <span class="p">[</span><span class="n">exist</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                        <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;._update_structures_with_proto&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">replaced</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">need_identity_removal</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_constant_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="n">replaced</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">update_node_constant</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;_update_structures_with_proto_CoF_</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="n">replaced</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_shape</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_device</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_device</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_constant</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">computed_value</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">value</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_shape</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">t</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="o">.</span><span class="n">data_type</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">o</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_update_structures_with_proto_l_</span><span class="si">{</span><span class="n">o</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_make_node_set_type_shape_constant</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="p">{})</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_make_node_set_type_shape</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

            <span class="n">new_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">available_shapes</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_update_shape_types_with_proto_one_result</span><span class="p">(</span><span class="n">available_shapes</span><span class="p">[</span><span class="n">o</span><span class="p">])</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">infer_shapes_options</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">available_shapes</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">):</span>
                    <span class="c1"># second try</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_make_node_set_type_shape</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

                <span class="c1"># This test should be enabled when shape inference is complete.</span>
                <span class="c1"># assert all(</span>
                <span class="c1">#     map(</span>
                <span class="c1">#         lambda x: x in available_shapes or self.has_type(x), node.output</span>
                <span class="c1">#     )</span>
                <span class="c1"># ), (</span>
                <span class="c1">#     f&quot;One output of node {node.op_type!r} &quot;</span>
                <span class="c1">#     f&quot;(name={node.name!r}) has no type: &quot;</span>
                <span class="c1">#     f&quot;{&#39;, &#39;.join(o + ((&#39;:&#39; + str(self.get_type(o))) &quot;</span>
                <span class="c1">#     f&quot;if self.has_type(o) else &#39;:0&#39;) for o in node.output)}&quot;</span>
                <span class="c1"># )</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">new_nodes</span>

        <span class="k">if</span> <span class="n">need_identity_removal</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_identity_nodes</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._update_structures_with_proto] ends with &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> nodes in &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">begin_</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

<div class="viewcode-block" id="GraphBuilder.parse_dimension_expression">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.parse_dimension_expression">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_dimension_expression</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">exc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">allow_new_dynamic_dimension</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expression</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parses an expression involving dimension.</span>

<span class="sd">        :param expr: expr</span>
<span class="sd">        :param exc: raises an exception if it fails</span>
<span class="sd">        :param allow_new_dynamic_dimension: the new dimension is considered as a new one,</span>
<span class="sd">            if the dimension is only one variable (:meth:`str.isidentifier`)</span>
<span class="sd">        :return: an expression or None if exc is False and the parsing failed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">parse_expression</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">exc</span><span class="o">=</span><span class="n">exc</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">allow_new_dynamic_dimension</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">parse_expression</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">exc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">isidentifier</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">name</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unable to parse an expression expr=[</span><span class="si">{</span><span class="n">expr</span><span class="si">!r}</span><span class="s2">], &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;allow_new_dynamic_dimension=</span><span class="si">{</span><span class="n">allow_new_dynamic_dimension</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;due to </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">, self.dynamic_objects=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;set(self.dynamic_objects_rev)=</span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects_rev</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;self.dynamic_shapes=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;self._dynamic_alias=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_alias</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_constant_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">NodeProto</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds a unique key for a constant.</span>
<span class="sd">        Returns None if the constant if too big.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span> <span class="o">==</span> <span class="s2">&quot;ConstantOfShape&quot;</span><span class="p">:</span>
            <span class="c1"># We assume initializer are fused.</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants_alias_</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants_alias_</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="n">name</span><span class="o">.</span><span class="n">encode</span><span class="p">()]</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                <span class="n">key</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">())</span>
            <span class="k">return</span> <span class="sa">b</span><span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span> <span class="o">==</span> <span class="s2">&quot;Constant&quot;</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tensor_shape</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">shape</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">constant_size</span><span class="p">:</span>
                <span class="c1"># It would be too long.</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="o">.</span><span class="n">encode</span><span class="p">()]</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                <span class="n">key</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">())</span>
            <span class="k">return</span> <span class="sa">b</span><span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected node type </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">!r}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="GraphBuilder.add_constant_node">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.add_constant_node">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_constant_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">NodeProto</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a constant node. Any constant equivalent to this one</span>
<span class="sd">        will be fused.</span>
<span class="sd">        `self.optimization_options.constant_fusing` must be True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">NodeProto</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2"> for a node&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">constant_fusing</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constant_key</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants_node_</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;A constant with the same key </span><span class="si">{</span><span class="n">key</span><span class="si">!r}</span><span class="s2"> was already added</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constants_node_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
        <span class="k">return</span> <span class="n">key</span></div>


<div class="viewcode-block" id="GraphBuilder.is_exact_same_constant">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.is_exact_same_constant">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_exact_same_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">NodeProto</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">NodeProto</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a constant node. Any constant equivalent to this one</span>
<span class="sd">        will be fused.</span>
<span class="sd">        `self.optimization_options.constant_fusing` must be True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">constant_fusing</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constant_key</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants_node_</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants_node_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">None</span></div>


    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_format_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="s2">&quot;Formats a dictionay to avoid a too long string.&quot;</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;{&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">sv</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="ow">in</span> <span class="n">sv</span><span class="p">:</span>
                <span class="n">s_</span> <span class="o">=</span> <span class="n">sv</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">sv</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">s_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">...</span><span class="si">{</span><span class="n">s_</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">:</span>
                <span class="n">sv</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sv</span><span class="p">[:</span><span class="mi">20</span><span class="p">]</span><span class="si">}</span><span class="s2">...</span><span class="si">{</span><span class="n">sv</span><span class="p">[</span><span class="o">-</span><span class="mi">20</span><span class="p">:]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">sv</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;}&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>

<div class="viewcode-block" id="GraphBuilder.make_local_function">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.make_local_function">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_local_function</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">builder</span><span class="p">:</span> <span class="s2">&quot;GraphBuilder&quot;</span><span class="p">,</span>
        <span class="n">function_options</span><span class="p">:</span> <span class="n">FunctionOptions</span><span class="p">,</span>
        <span class="n">optimize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">metadata_props</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a local function to exiting graph.</span>

<span class="sd">        :param builder: builder</span>
<span class="sd">        :param function_options: to define how to handle weights</span>
<span class="sd">        :param optimize: optimize the function</span>
<span class="sd">        :param metadata_props: metadata to add to the function</span>
<span class="sd">        :return: the list of added initializers if</span>
<span class="sd">            *move_initializer_to_constant* is True,</span>
<span class="sd">            and the function name (domain, name),</span>
<span class="sd">            it can be changed if one is already existing</span>

<span class="sd">        Method :meth:`GraphBuilder.inline_functions`,</span>
<span class="sd">        :meth:`GraphBuilder.move_initializers_to_constant` are called on</span>
<span class="sd">        the builder if *move_initializer_to_constant* is True.</span>
<span class="sd">        It modifies the builder inplace.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">function_options</span><span class="o">.</span><span class="n">name</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">function_options</span><span class="o">.</span><span class="n">domain</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_local_function</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_local_function] </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">domain</span><span class="si">}</span><span class="s2">]&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">name</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">builder</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span><span class="si">}</span><span class="s2">) &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;-&gt; </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">name</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">builder</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">assert</span> <span class="n">name</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;function_options is wrong </span><span class="si">{</span><span class="n">function_options</span><span class="si">!r}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">function_options</span><span class="o">.</span><span class="n">rename_allowed</span>
            <span class="ow">or</span> <span class="n">function_options</span><span class="o">.</span><span class="n">merge_allowed</span>
            <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_local_function</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">domain</span><span class="p">)</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Function </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, domain=</span><span class="si">{</span><span class="n">domain</span><span class="si">!r}</span><span class="s2"> already exists&quot;</span>

        <span class="k">if</span> <span class="n">function_options</span><span class="o">.</span><span class="n">move_initializer_to_constant</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">function_options</span><span class="o">.</span><span class="n">inline</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_constants</span><span class="p">(</span><span class="s2">&quot;before-inline_functions&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_local_function</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_local_function] inline_functions &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">builder</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="n">builder</span><span class="o">.</span><span class="n">inline_functions</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_local_function</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_local_function] after inlining &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">builder</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_constants</span><span class="p">(</span><span class="s2">&quot;after-inline_functions&quot;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">builder</span><span class="o">.</span><span class="n">initializers_dict</span>
            <span class="ow">or</span> <span class="n">function_options</span><span class="o">.</span><span class="n">return_initializer</span>
            <span class="ow">or</span> <span class="n">function_options</span><span class="o">.</span><span class="n">move_initializer_to_constant</span>
        <span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;incompatible options, return_initializer or &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;move_initializer_to_constant must be True, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;move_initializer_to_constant=</span><span class="si">{</span><span class="n">function_options</span><span class="o">.</span><span class="n">move_initializer_to_constant</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;function_options.inline=</span><span class="si">{</span><span class="n">function_options</span><span class="o">.</span><span class="n">inline</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;but function_options=</span><span class="si">{</span><span class="n">function_options</span><span class="si">!r}</span><span class="s2"> with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;initializers&quot;</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">function_options</span><span class="o">.</span><span class="n">rename_allowed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_other_builder_local_function_before_merging</span><span class="p">(</span>
                <span class="n">builder</span><span class="p">,</span> <span class="n">merge_allowed</span><span class="o">=</span><span class="n">function_options</span><span class="o">.</span><span class="n">merge_allowed</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_function_order</span><span class="p">()</span>

        <span class="n">fct</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="n">to_onnx</span><span class="p">(</span>
            <span class="n">function_options</span><span class="o">=</span><span class="n">function_options</span><span class="p">,</span>
            <span class="n">optimize</span><span class="o">=</span><span class="n">optimize</span><span class="p">,</span>
            <span class="n">inline</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fct</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">FunctionProto</span><span class="p">)),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">fct</span><span class="p">)</span><span class="si">}</span><span class="s2">, function_options=</span><span class="si">{</span><span class="n">function_options</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">onx</span> <span class="o">=</span> <span class="n">fct</span><span class="p">[</span><span class="s2">&quot;proto&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fct</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">else</span> <span class="n">fct</span>

        <span class="k">if</span> <span class="n">metadata_props</span><span class="p">:</span>
            <span class="n">oh</span><span class="o">.</span><span class="n">set_metadata_props</span><span class="p">(</span><span class="n">onx</span><span class="p">,</span> <span class="n">metadata_props</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_local_function</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fct</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_local_function] keys=</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fct</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;initializers_name&quot;</span> <span class="ow">in</span> <span class="n">fct</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_local_function] initializers_name=&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fct</span><span class="p">[</span><span class="s1">&#39;initializers_name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_local_function] initializers_dict=&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">fct</span><span class="p">[</span><span class="s1">&#39;initializers_dict&#39;</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_local_function] initializers_renaming=&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fct</span><span class="p">[</span><span class="s1">&#39;initializers_renaming&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_local_function] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;create </span><span class="si">{</span><span class="n">onx</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">onx</span><span class="o">.</span><span class="n">domain</span><span class="si">}</span><span class="s2">]&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">onx</span><span class="o">.</span><span class="n">input</span><span class="p">)</span><span class="si">}</span><span class="s2">) -&gt; </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">onx</span><span class="o">.</span><span class="n">output</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
        <span class="n">doc_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;-- function_options=</span><span class="si">{</span><span class="n">function_options</span><span class="si">!r}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraints_</span><span class="p">:</span>
            <span class="n">doc_string</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-- shape-constraints: </span><span class="si">{</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraints_</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="p">:</span>
            <span class="n">filtered</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;init&quot;</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">filtered</span><span class="p">:</span>
                <span class="n">doc_string</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-- known-value-shape: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_format_dict</span><span class="p">(</span><span class="n">filtered</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">onx</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">+=</span> <span class="n">doc_string</span> <span class="o">+</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-- optimized:</span><span class="si">{</span><span class="n">builder</span><span class="o">.</span><span class="n">optimization_options</span><span class="si">!r}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">optimize</span> <span class="k">else</span> <span class="s2">&quot;not-optimized&quot;</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">builder</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_function</span><span class="p">(</span>
                <span class="n">f</span><span class="p">,</span>
                <span class="n">rename_allowed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">merge_allowed</span><span class="o">=</span><span class="n">function_options</span><span class="o">.</span><span class="n">merge_allowed</span><span class="p">,</span>
                <span class="n">builder</span><span class="o">=</span><span class="n">builder</span><span class="o">.</span><span class="n">functions_builder</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="c1"># Let&#39;s rename the initializers.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fct</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;initializers_dict&quot;</span> <span class="ow">in</span> <span class="n">fct</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">fct</span><span class="p">[</span><span class="s2">&quot;initializers_dict&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">fct</span><span class="p">[</span><span class="s2">&quot;initializers_name&quot;</span><span class="p">]),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Names mismatch between </span><span class="si">{</span><span class="n">fct</span><span class="p">[</span><span class="s1">&#39;initializers_name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> and &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">fct</span><span class="p">[</span><span class="s1">&#39;initializers_dict&#39;</span><span class="p">])</span><span class="si">}{</span><span class="n">builder</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">repl</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">fct</span><span class="p">[</span><span class="s2">&quot;initializers_dict&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">new_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_initializer</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="n">k</span><span class="p">),</span>
                    <span class="n">v</span><span class="p">,</span>
                    <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;GraphBuilder.make_local_function/from(</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">repl</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_name</span>
            <span class="n">renaming</span> <span class="o">=</span> <span class="n">fct</span><span class="p">[</span><span class="s2">&quot;initializers_renaming&quot;</span><span class="p">]</span>
            <span class="n">new_inits</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">input_name</span> <span class="ow">in</span> <span class="n">fct</span><span class="p">[</span><span class="s2">&quot;initializers_name&quot;</span><span class="p">]:</span>
                <span class="n">init_name</span> <span class="o">=</span> <span class="n">renaming</span><span class="p">[</span><span class="n">input_name</span><span class="p">]</span>
                <span class="n">repl_name</span> <span class="o">=</span> <span class="n">repl</span><span class="p">[</span><span class="n">init_name</span><span class="p">]</span>
                <span class="n">new_inits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">repl_name</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_local_function</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_local_function] new_inits=</span><span class="si">{</span><span class="n">new_inits</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_inits</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">onx</span><span class="p">,</span> <span class="n">FunctionProto</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">onx</span><span class="p">)</span><span class="si">}</span><span class="s2">, name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, domain=</span><span class="si">{</span><span class="n">domain</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;function_options=</span><span class="si">{</span><span class="n">function_options</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span> <span class="o">!=</span> <span class="n">name</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">domain</span> <span class="o">!=</span> <span class="n">domain</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">onx</span><span class="o">.</span><span class="n">node</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Recursivity is not allowed in function </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, domain=</span><span class="si">{</span><span class="n">domain</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;function_options=</span><span class="si">{</span><span class="n">function_options</span><span class="si">}</span><span class="se">\n</span><span class="s2">------ONNX----</span><span class="se">\n</span><span class="si">{</span><span class="n">pretty_onnx</span><span class="p">(</span><span class="n">onx</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">optimize</span>
            <span class="ow">or</span> <span class="ow">not</span> <span class="n">builder</span><span class="o">.</span><span class="n">optimization_options</span><span class="o">.</span><span class="n">remove_identity</span>
            <span class="ow">or</span> <span class="nb">len</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">onx</span><span class="o">.</span><span class="n">node</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">op_type</span> <span class="o">==</span> <span class="s2">&quot;Identity&quot;</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">onx</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
        <span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The optimization was not applied. There are two many nodes identity&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="n">builder</span><span class="o">.</span><span class="n">pretty_text</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="n">new_domain</span><span class="p">,</span> <span class="n">new_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_function</span><span class="p">(</span>
            <span class="n">onx</span><span class="p">,</span>
            <span class="n">rename_allowed</span><span class="o">=</span><span class="n">function_options</span><span class="o">.</span><span class="n">rename_allowed</span><span class="p">,</span>
            <span class="n">merge_allowed</span><span class="o">=</span><span class="n">function_options</span><span class="o">.</span><span class="n">merge_allowed</span><span class="p">,</span>
            <span class="n">builder</span><span class="o">=</span><span class="n">builder</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">new_domain</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">[</span><span class="n">new_domain</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">locf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_local_function</span><span class="p">(</span><span class="n">new_name</span><span class="p">,</span> <span class="n">new_domain</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_local_function</span><span class="p">(</span><span class="n">new_name</span><span class="p">,</span> <span class="n">new_domain</span><span class="p">,</span> <span class="n">builder</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_local_function</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_local_function] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;done with </span><span class="si">{</span><span class="n">onx</span><span class="o">.</span><span class="n">domain</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">onx</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">onx</span><span class="o">.</span><span class="n">input</span><span class="p">)</span><span class="si">}</span><span class="s2">) -&gt; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">onx</span><span class="o">.</span><span class="n">output</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_local_function] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;new_domain=</span><span class="si">{</span><span class="n">new_domain</span><span class="si">!r}</span><span class="s2">, new_name=</span><span class="si">{</span><span class="n">new_name</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_local_function] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;check proto </span><span class="si">{</span><span class="n">locf</span><span class="o">.</span><span class="n">domain</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">onx</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">locf</span><span class="o">.</span><span class="n">input</span><span class="p">)</span><span class="si">}</span><span class="s2">) -&gt; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">locf</span><span class="o">.</span><span class="n">output</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">input_names</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">locf</span><span class="o">.</span><span class="n">input</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.make_local_function] &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;last inputs are constants, builder is &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">input_names</span><span class="p">)</span><span class="si">}</span><span class="s2">) -&gt; </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">output_names</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">locf</span><span class="o">.</span><span class="n">input</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="o">.</span><span class="n">input_names</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Local builder and local function disagrees on the inputs &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">locf</span><span class="o">.</span><span class="n">input</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">b</span><span class="o">.</span><span class="n">input_names</span><span class="si">}</span><span class="se">\n</span><span class="s2">-----</span><span class="si">{</span><span class="n">b</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">----&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">####</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">new_inits</span><span class="p">,</span> <span class="p">(</span><span class="n">new_domain</span><span class="p">,</span> <span class="n">new_name</span><span class="p">)</span></div>


<div class="viewcode-block" id="GraphBuilder.rename_in_local_functions">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.rename_in_local_functions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rename_in_local_functions</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">replacements</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span>
        <span class="n">list_keys</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">proto</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">FunctionProto</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">FunctionProto</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">FunctionProto</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">FunctionProto</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Renames local function in a given list of local functions.</span>

<span class="sd">        :param replacements: replacements to make</span>
<span class="sd">        :param list_keys: list of local function to modify, if None,</span>
<span class="sd">            it is equal to the list of functions in the builder itself,</span>
<span class="sd">            proto must be None in that case</span>
<span class="sd">        :param proto: one function to update as well, if None</span>
<span class="sd">        :param delete_replaced: deletes the replaced functions</span>
<span class="sd">        :return: the modified proto for proto</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We need to keep the functions order to avoid having a function</span>
        <span class="c1"># using a function declared after.</span>
        <span class="n">ordered_functions</span> <span class="o">=</span> <span class="p">[</span><span class="n">replacements</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">]</span>
        <span class="c1"># ...</span>
        <span class="k">if</span> <span class="n">list_keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">list_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functions_builder</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">proto</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;proto must be None if list_keys is None&quot;</span>
            <span class="n">proto</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">list_keys</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Local function </span><span class="si">{</span><span class="n">key</span><span class="si">!r}</span><span class="s2"> is missing from </span><span class="si">{</span><span class="n">assert_sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">new_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rename_op_type_in_local_functions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">replacements</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_f</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">replacements</span><span class="p">:</span>
                <span class="n">new_f</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">new_f</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">replacements</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">replacements</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span> <span class="o">=</span> <span class="n">new_f</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions_builder</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">functions_builder</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">rename_local_functions</span><span class="p">(</span><span class="n">replacements</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">replacements</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">functions_builder</span><span class="p">[</span><span class="n">replacements</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions_builder</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">functions</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">replacements</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions_builder</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions_builder</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">replacements</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ordered_functions</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions_builder</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions_builder</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ordered_functions</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions_builder</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">proto</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_rename_op_type_in_local_functions</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">replacements</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">proto</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rename_op_type_in_local_functions</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="n">replacements</span><span class="p">)</span></div>


<div class="viewcode-block" id="GraphBuilder.rename_local_functions">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.rename_local_functions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rename_local_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replacements</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Renames local functions in the builder.</span>

<span class="sd">        :param replacements: dictionary mapping old (domain, name) to new (domain, name)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">replacements</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">replacements</span><span class="p">:</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="n">replacements</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="n">node</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">new_key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">node</span><span class="o">.</span><span class="n">op_type</span> <span class="o">=</span> <span class="n">new_key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_rename_local_functions_in_graph</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">replacements</span><span class="p">)</span>

        <span class="c1"># Rename in self.functions</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rename_in_local_functions</span><span class="p">(</span><span class="n">replacements</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_rename_local_functions_in_graph</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="n">GraphProto</span><span class="p">,</span> <span class="n">replacements</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Renames local function calls in a GraphProto (inplace).</span>

<span class="sd">        :param g: the graph to modify</span>
<span class="sd">        :param replacements: dictionary mapping old (domain, name) to new (domain, name)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">to_rename</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">replacements</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">node</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">to_rename</span><span class="p">:</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="n">replacements</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="n">node</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">new_key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">node</span><span class="o">.</span><span class="n">op_type</span> <span class="o">=</span> <span class="n">new_key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Recursively check subgraphs</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_rename_local_functions_in_graph</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">replacements</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_detect_op_type_replacements</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">proto</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">FunctionProto</span><span class="p">,</span> <span class="n">GraphProto</span><span class="p">],</span>
        <span class="n">replacements</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Detects a replacements to make in a proto.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">proto</span><span class="o">.</span><span class="n">node</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="p">)</span> <span class="ow">in</span> <span class="n">replacements</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_detect_op_type_replacements</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">replacements</span><span class="p">):</span>
                        <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_rename_op_type_in_local_functions</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">proto</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">FunctionProto</span><span class="p">,</span> <span class="n">GraphProto</span><span class="p">],</span>
        <span class="n">replacements</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">FunctionProto</span><span class="p">,</span> <span class="n">GraphProto</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modifies the function to replace a call by another one.</span>

<span class="sd">        :param proto: the proto to modify</span>
<span class="sd">        :param replacements: the replacements to do</span>
<span class="sd">        :return: the new proto, or the existing one if no replacements was found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detect_op_type_replacements</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="n">replacements</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">proto</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="n">FunctionProto</span><span class="p">):</span>
            <span class="n">new_proto</span> <span class="o">=</span> <span class="n">FunctionProto</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="n">GraphProto</span><span class="p">):</span>
            <span class="n">new_proto</span> <span class="o">=</span> <span class="n">GraphProto</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">proto</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">new_proto</span><span class="o">.</span><span class="n">ParseFromString</span><span class="p">(</span><span class="n">proto</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_constants</span><span class="p">(</span><span class="s2">&quot;begin-renaming&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">new_proto</span><span class="o">.</span><span class="n">node</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">replacements</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span> <span class="o">=</span> <span class="n">replacements</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">node_attributes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">modified</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span><span class="p">:</span>
                    <span class="n">node_attributes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">att</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detect_op_type_replacements</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">replacements</span><span class="p">):</span>
                    <span class="n">node_attributes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">att</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="n">modified</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">node_attributes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">oh</span><span class="o">.</span><span class="n">make_attribute</span><span class="p">(</span>
                        <span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_rename_op_type_in_local_functions</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">replacements</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">modified</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">[:]</span>
                <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">node_attributes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_constants</span><span class="p">(</span><span class="s2">&quot;after-renaming&quot;</span><span class="p">,</span> <span class="n">new_proto</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_proto</span>

<div class="viewcode-block" id="GraphBuilder.add_function">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.add_function">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_function</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">f</span><span class="p">:</span> <span class="n">FunctionProto</span><span class="p">,</span>
        <span class="n">rename_allowed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">merge_allowed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">builder</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;GraphBuilder&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a new local function.</span>

<span class="sd">        :param f: new function to register</span>
<span class="sd">        :param rename_allowed: the function can be renamed if a function</span>
<span class="sd">            with the same name already exists,</span>
<span class="sd">            the proto is modified inplace</span>
<span class="sd">        :param merge_allowed: the function is not added if another function</span>
<span class="sd">            of the same name already exists and is the same</span>
<span class="sd">        :param builder: GraphBuilder used to build the local function,</span>
<span class="sd">            it contains shape information the function does not have</span>
<span class="sd">        :return: function name</span>

<span class="sd">        This function does not add the domain to the list of supported opsets.</span>
<span class="sd">        You should use method :meth:`make_local_function` for this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_function_order</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">builder</span><span class="p">:</span>
            <span class="n">builder</span><span class="o">.</span><span class="n">_check_function_order</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">node</span><span class="p">:</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">domain</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;ai.onnx.ml&quot;</span><span class="p">,</span> <span class="s2">&quot;ai.onnx.training&quot;</span><span class="p">,</span> <span class="s2">&quot;com.microsoft&quot;</span><span class="p">}</span>
                    <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;ai&quot;</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span>
                <span class="p">),</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Node &#39;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">}</span><span class="s2">&#39; is unknown (</span><span class="si">{</span><span class="n">pretty_onnx</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">), &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;local functions = </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="n">key</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span>
        <span class="k">assert</span> <span class="s2">&quot;.&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;&#39;.&#39; not allowed in function &#39;</span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="n">domain</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
        <span class="k">if</span> <span class="n">merge_allowed</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
            <span class="n">existing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">same_function_proto</span><span class="p">(</span><span class="n">existing</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
                <span class="c1"># No need to add it again.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_local_function</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.add_function]&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot; -- existing </span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="n">domain</span><span class="si">}</span><span class="s2">] &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">input</span><span class="p">)</span><span class="si">}</span><span class="s2">) -&gt; </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">output</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="n">rename_allowed</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
            <span class="c1"># Let&#39;s rename the function. We assume other local functions in the builder itself</span>
            <span class="c1"># have already been renamed.</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_l</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">l&quot;</span>
            <span class="k">while</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_l</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">l&quot;</span>
            <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">assert</span> <span class="s2">&quot;.&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;&#39;.&#39; not allowed in function &#39;</span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="n">domain</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
        <span class="k">assert</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Function </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> was already added, rename_allowed=</span><span class="si">{</span><span class="n">rename_allowed</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;merge_allowed=</span><span class="si">{</span><span class="n">merge_allowed</span><span class="si">}</span><span class="s2">, same: &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">same_function_proto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">key</span><span class="p">],</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">----------------------------------------------&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="n">pretty_onnx</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">----------------------------------------------&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="n">pretty_onnx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_local_function</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.add_function] ---- adding </span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="n">domain</span><span class="si">}</span><span class="s2">] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">input</span><span class="p">)</span><span class="si">}</span><span class="s2">) -&gt; </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">output</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>
        <span class="k">if</span> <span class="n">builder</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">functions_builder</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">builder</span>
        <span class="k">elif</span> <span class="n">f</span><span class="o">.</span><span class="n">domain</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">domain</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_function_order</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span></div>


<div class="viewcode-block" id="GraphBuilder.has_local_function">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.has_local_function">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_local_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">domain</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">builder</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks if a local function exists.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">builder</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions_builder</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span></div>


<div class="viewcode-block" id="GraphBuilder.get_local_function">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.get_local_function">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_local_function</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">domain</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">builder</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FunctionProto</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a local function.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">builder</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions_builder</span><span class="p">[</span><span class="n">domain</span><span class="p">,</span> <span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">domain</span><span class="p">,</span> <span class="n">name</span><span class="p">]</span></div>


<div class="viewcode-block" id="GraphBuilder.get_local_function_outputs">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.get_local_function_outputs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_local_function_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">domain</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the outputs of a local function.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">domain</span><span class="p">,</span> <span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">output</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">add_to_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Set</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]):</span>
        <span class="k">if</span> <span class="n">dim_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraints_</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constraints_</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constraints_</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span> <span class="o">|=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constraints_</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="GraphBuilder.register_constraint_dimension">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.register_constraint_dimension">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">register_constraint_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers a constraint on a dimension.</span>

<span class="sd">        :param dim_name: dimension name</span>
<span class="sd">        :param value: value to register</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_dyn_dim</span> <span class="ow">and</span> <span class="n">dim_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug_dyn_dim</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.register_constraint_dimension] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;dim_name=</span><span class="si">{</span><span class="n">dim_name</span><span class="si">!r}</span><span class="s2">, value=</span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_to_constraints</span><span class="p">(</span><span class="n">dim_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="GraphBuilder.get_registered_constraints">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.get_registered_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_registered_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Set</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the constraints registered so far.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraints_</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_to_torch_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;torch.Tensor&quot;</span><span class="p">:</span>  <span class="c1"># noqa: F821</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Torch does not convert numpy dtype very well.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">a</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Then torch may consider this as a the creation of empty array.</span>
                <span class="n">tt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,))</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="n">tt</span> <span class="o">=</span> <span class="n">tt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_torch_tensor_from_np_array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">ttype</span> <span class="o">=</span> <span class="n">onnx_dtype_to_torch_dtype</span><span class="p">(</span><span class="n">dtype_to_tensor_dtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">tt</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">ttype</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unexpected shape </span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, expecting shape=</span><span class="si">{</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;dtype=</span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">, expected dtype=</span><span class="si">{</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="si">}</span><span class="s2">, unable to convert to a torch.Tensor.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="GraphBuilder.inline_functions">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.inline_functions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">inline_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Inlines local functions. Returns the number of inlined nodes.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
            <span class="c1"># Nothing to do</span>
            <span class="k">return</span>

        <span class="n">begin0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

        <span class="c1"># Checks opsets</span>
        <span class="n">skip_functions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">metadata_props</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">metadata_props</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;inline&quot;</span> <span class="ow">and</span> <span class="n">p</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;False&quot;</span><span class="p">,</span> <span class="s2">&quot;false&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                        <span class="n">skip_functions</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">v</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">opset_import</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">op</span><span class="o">.</span><span class="n">version</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">domain</span><span class="p">],</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Opset version mismatch for domain </span><span class="si">{</span><span class="n">op</span><span class="o">.</span><span class="n">domain</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;existing version is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">domain</span><span class="p">]</span><span class="si">}</span><span class="s2">, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;version for function </span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> is </span><span class="si">{</span><span class="n">op</span><span class="o">.</span><span class="n">version</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">opsets</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">domain</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">version</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.inline_functions] begin inlining graph&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.inline_functions] skip_functions=</span><span class="si">{</span><span class="n">skip_functions</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="s2">&quot;before inline&quot;</span><span class="p">)</span>
        <span class="n">begin</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="n">inlined</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inline_functions_iteration</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">skip_functions</span><span class="o">=</span><span class="n">skip_functions</span><span class="p">)</span>
        <span class="n">stats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">pattern</span><span class="o">=</span><span class="s2">&quot;inline&quot;</span><span class="p">,</span>
                <span class="n">time_in</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">begin</span><span class="p">,</span>
                <span class="n">iteration</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">inlined</span><span class="o">=</span><span class="n">inlined</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="s2">&quot;after inline iteration 0&quot;</span><span class="p">)</span>
        <span class="n">it</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">inlined</span><span class="p">:</span>
            <span class="n">it</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">begin</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
            <span class="n">inlined</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inline_functions_iteration</span><span class="p">(</span>
                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">skip_functions</span><span class="o">=</span><span class="n">skip_functions</span>
            <span class="p">)</span>
            <span class="n">stats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">pattern</span><span class="o">=</span><span class="s2">&quot;inline&quot;</span><span class="p">,</span>
                    <span class="n">time_in</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">begin</span><span class="p">,</span>
                    <span class="n">iteration</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">inlined</span><span class="o">=</span><span class="n">inlined</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;after inline iteration </span><span class="si">{</span><span class="n">it</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># We can remove the local functions now.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">skip_functions</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">.inline_functions] done inlining graph &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span><span class="o">-</span><span class="n">begin0</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">stats</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">local_functions_found</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="n">GraphProto</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">node</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPHS</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;node.op_type=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">, node.name=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;att.name=</span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, not implemented with att.type=</span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(AttributeProto.GRAPHS)&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_local_function</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">):</span>
                        <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_inline_functions_iteration</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">skip_functions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inlines local functions. Returns the number of replacements.</span>

<span class="sd">        :param skip_functions: do not inline these functions</span>
<span class="sd">        :param verbose: verbosity</span>
<span class="sd">        :return: number of replacements</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">skip_functions</span> <span class="o">=</span> <span class="n">skip_functions</span> <span class="ow">or</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">n_replacements</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">replacements</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPHS</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;node.op_type=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">, node.name=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;att.name=</span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, not implemented with att.type=</span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(AttributeProto.GRAPHS)&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_functions_found</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">):</span>
                    <span class="c1"># A function was detected in a subgraphs.</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._inline_functions_iterations] &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;replace local functions in node </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;name=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                    <span class="n">n_replacements</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inline_functions_subgraph</span><span class="p">(</span>
                        <span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">skip_functions</span><span class="o">=</span><span class="n">skip_functions</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">att</span><span class="o">.</span><span class="n">ref_attr_name</span><span class="p">:</span>
                    <span class="c1"># we need to retrieve the value of the parameter</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to inline a function with attribute </span><span class="si">{</span><span class="n">att</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">key</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span> <span class="ow">or</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">skip_functions</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">n_replacements</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._inline_functions_iterations] inline function &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> domain </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">domain</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;[n_replacements=</span><span class="si">{</span><span class="n">n_replacements</span><span class="si">}</span><span class="s2">]&quot;</span>
                <span class="p">)</span>
            <span class="n">new_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_function</span><span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">attributes</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">attribute</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_propaggate_metadata</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">new_nodes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._inline_functions_iterations] &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;done with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">new_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> new nodes &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">domain</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">replacements</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pos</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">new_nodes</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">n_replacements</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># No replacements to do.</span>
            <span class="k">return</span> <span class="n">n_replacements</span>

        <span class="n">stat</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">new_nodes</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">replacements</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">insert_and_remove_nodes</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">new_nodes</span><span class="p">,</span> <span class="n">removed</span><span class="o">=</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;after inlining function </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n_replacements</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_inline_functions_subgraph</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">g</span><span class="p">:</span> <span class="n">GraphProto</span><span class="p">,</span>
        <span class="n">skip_functions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inlines local functions in subgraph (inplace).</span>
<span class="sd">        Returns the number of replacements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._inline_functions_subgraph] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;inline subgraph </span><span class="si">{</span><span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">stat</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="s2">&quot;before inline&quot;</span><span class="p">)</span>
        <span class="n">inlined</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inline_functions_subgraph_iteration</span><span class="p">(</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">skip_functions</span><span class="o">=</span><span class="n">skip_functions</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="s2">&quot;after inline iteration 0&quot;</span><span class="p">)</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">inlined</span>
        <span class="n">it</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">inlined</span><span class="p">:</span>
            <span class="n">it</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">inlined</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inline_functions_subgraph_iteration</span><span class="p">(</span>
                <span class="n">g</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">skip_functions</span><span class="o">=</span><span class="n">skip_functions</span>
            <span class="p">)</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">inlined</span>
            <span class="n">it</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">stat</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;after inline iteration </span><span class="si">{</span><span class="n">it</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._inline_functions_subgraph] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;inlined subgraph </span><span class="si">{</span><span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, total=</span><span class="si">{</span><span class="n">total</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">total</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_inline_functions_subgraph_iteration</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">g</span><span class="p">:</span> <span class="n">GraphProto</span><span class="p">,</span>
        <span class="n">skip_functions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">skip_functions</span> <span class="o">=</span> <span class="n">skip_functions</span> <span class="ow">or</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">new_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[_inline_functions_subgraph_iteration] begin with </span><span class="si">{</span><span class="n">make_idg</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">n_replacements</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">node</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPHS</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;node.op_type=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">, node.name=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;att.name=</span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, not implemented with att.type=</span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(AttributeProto.GRAPHS)&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_functions_found</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">):</span>
                    <span class="c1"># A function was detected in a subgraphs.</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;[_inline_functions_subgraph_iteration] replace local &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;functions in node </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">, name=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                    <span class="n">n_replacements</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inline_functions_subgraph</span><span class="p">(</span>
                        <span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">skip_functions</span><span class="o">=</span><span class="n">skip_functions</span>
                    <span class="p">)</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="ow">not</span> <span class="n">att</span><span class="o">.</span><span class="n">ref_attr_name</span>
                <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Missing information to replace </span><span class="si">{</span><span class="n">att</span><span class="si">}</span><span class="s2"> in node </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="n">key</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">op_type</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span> <span class="ow">or</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">skip_functions</span><span class="p">:</span>
                <span class="n">new_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">n_replacements</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[_inline_functions_subgraph_iteration] inline function &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> domain </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">domain</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">functions_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rename_results</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_convert_function</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">key</span><span class="p">]),</span>
                <span class="n">replacements</span><span class="o">=</span><span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">))},</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_propaggate_metadata</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">functions_nodes</span><span class="p">)</span>
            <span class="n">new_nodes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">functions_nodes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[_inline_functions_subgraph_iteration] </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">new_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> new nodes &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">domain</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">n_replacements</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">g</span><span class="o">.</span><span class="n">node</span><span class="p">[:]</span>
            <span class="n">g</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_nodes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[_inline_functions_subgraph_iteration] done with &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">make_idg</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">n_replacements</span><span class="si">}</span><span class="s2"> replacements&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">n_replacements</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_propaggate_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node</span><span class="p">:</span> <span class="n">NodeProto</span><span class="p">,</span> <span class="n">new_nodes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">NodeProto</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Propagates some of the metadata to the created nodes.&quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">source_node</span><span class="o">.</span><span class="n">metadata_props</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span>
                <span class="s2">&quot;intypes&quot;</span><span class="p">,</span>
                <span class="s2">&quot;outtypes&quot;</span><span class="p">,</span>
                <span class="s2">&quot;inshapes&quot;</span><span class="p">,</span>
                <span class="s2">&quot;outshapes&quot;</span><span class="p">,</span>
                <span class="s2">&quot;invalueshapes&quot;</span><span class="p">,</span>
                <span class="s2">&quot;outvalueshapes&quot;</span><span class="p">,</span>
            <span class="p">}:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">new_nodes</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">metadata_props</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_rename_results</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">NodeProto</span><span class="p">],</span> <span class="n">replacements</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">NodeProto</span><span class="p">]:</span>
        <span class="n">new_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">replacements</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;An input from </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="si">}</span><span class="s2"> is unknown in node &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">, name=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">new_outputs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">replacements</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="p">(</span>
                        <span class="n">replacements</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">==</span> <span class="n">o</span>
                    <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;o=</span><span class="si">{</span><span class="n">o</span><span class="si">!r}</span><span class="s2"> must be an output in </span><span class="si">{</span><span class="n">assert_sorted</span><span class="p">(</span><span class="n">replacements</span><span class="p">)</span><span class="si">!r}</span><span class="s2">&quot;</span>
                    <span class="n">new_outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="n">new_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
                <span class="n">replacements</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_name</span>
                <span class="n">new_outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_name</span><span class="p">)</span>

            <span class="n">new_node</span> <span class="o">=</span> <span class="n">oh</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="p">,</span>
                <span class="p">[</span><span class="n">replacements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">],</span>
                <span class="n">new_outputs</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_node_name</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
                <span class="n">domain</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">new_atts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPHS</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;node.op_type=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">, node.name=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;att.name=</span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, not implemented with att.type=</span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(AttributeProto.GRAPHS)&quot;</span>
                <span class="p">)</span>
                <span class="n">new_atts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">oh</span><span class="o">.</span><span class="n">make_attribute</span><span class="p">(</span>
                        <span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_rename_results_in_subgraph</span><span class="p">(</span>
                            <span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">replacements</span><span class="o">=</span><span class="n">replacements</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">check_ref_attr</span><span class="o">=</span><span class="kc">True</span>
                        <span class="p">),</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span>
                    <span class="k">else</span> <span class="n">att</span>
                <span class="p">)</span>
            <span class="n">new_node</span><span class="o">.</span><span class="n">attribute</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_atts</span><span class="p">)</span>
            <span class="n">new_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_nodes</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_rename_results_in_subgraph</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">g</span><span class="p">:</span> <span class="n">GraphProto</span><span class="p">,</span>
        <span class="n">replacements</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
        <span class="n">check_ref_attr</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">attributes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">AttributeProto</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">GraphProto</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">v</span><span class="p">}</span>

            <span class="k">assert</span> <span class="n">g</span><span class="o">.</span><span class="n">name</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._rename_results_in_subgraph] name=</span><span class="si">{</span><span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._rename_results_in_subgraph] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;replacements=</span><span class="si">{</span><span class="n">_</span><span class="p">(</span><span class="n">replacements</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">set_rep</span> <span class="o">=</span> <span class="nb">set</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">replacements</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">v</span><span class="p">})</span>
        <span class="n">new_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">do</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">node</span><span class="p">:</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">set_rep</span><span class="p">)</span>
            <span class="n">new_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">replacements</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">]</span>
            <span class="n">new_atts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPHS</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;node.op_type=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="si">!r}</span><span class="s2">, node.name=</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;att.name=</span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, not implemented with att.type=</span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(AttributeProto.GRAPHS)&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span><span class="p">:</span>
                    <span class="n">new_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rename_results_in_subgraph</span><span class="p">(</span>
                        <span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">,</span>
                        <span class="n">replacements</span><span class="o">=</span><span class="n">replacements</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                        <span class="n">check_ref_attr</span><span class="o">=</span><span class="n">check_ref_attr</span><span class="p">,</span>
                        <span class="n">attributes</span><span class="o">=</span><span class="n">attributes</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">make_idg</span><span class="p">(</span><span class="n">new_g</span><span class="p">)</span> <span class="o">!=</span> <span class="n">make_idg</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
                        <span class="n">diff</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">new_atts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">oh</span><span class="o">.</span><span class="n">make_attribute</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">new_g</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span>
                            <span class="k">else</span> <span class="n">att</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_atts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">att</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">attributes</span> <span class="ow">and</span> <span class="n">att</span><span class="o">.</span><span class="n">ref_attr_name</span><span class="p">:</span>
                    <span class="n">find</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attributes</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">att</span><span class="o">.</span><span class="n">ref_attr_name</span><span class="p">]</span>
                    <span class="k">assert</span> <span class="ow">not</span> <span class="n">check_ref_attr</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">find</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Missing replacement for </span><span class="si">{</span><span class="n">att</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;attributes=</span><span class="si">{</span><span class="n">attributes</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="n">new_att</span> <span class="o">=</span> <span class="n">AttributeProto</span><span class="p">()</span>
                    <span class="n">new_att</span><span class="o">.</span><span class="n">ParseFromString</span><span class="p">(</span><span class="n">find</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">())</span>
                    <span class="n">new_att</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">att</span><span class="o">.</span><span class="n">name</span>
                    <span class="n">new_atts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_att</span><span class="p">)</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_atts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">att</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">diff</span><span class="p">:</span>
                <span class="n">do</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">new_node</span> <span class="o">=</span> <span class="n">oh</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="p">,</span> <span class="n">new_inputs</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">name</span>
                <span class="p">)</span>
                <span class="n">new_node</span><span class="o">.</span><span class="n">attribute</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_atts</span><span class="p">)</span>
                <span class="n">new_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">set_rep</span><span class="p">:</span>
                <span class="c1"># This is shadowing. We can&#39;t continue with replacement.</span>
                <span class="n">set_rep</span> <span class="o">-=</span> <span class="nb">set</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">do</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._rename_results_in_subgraph] &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;no replacement for </span><span class="si">{</span><span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">g</span>
        <span class="n">g2</span> <span class="o">=</span> <span class="n">oh</span><span class="o">.</span><span class="n">make_graph</span><span class="p">(</span>
            <span class="n">new_nodes</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">input</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">initializer</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">sparse_initializer</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._rename_results_in_subgraph] done </span><span class="si">{</span><span class="n">g2</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">g2</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_convert_function</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">outputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">proto</span><span class="p">:</span> <span class="n">FunctionProto</span><span class="p">,</span>
        <span class="n">attributes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">AttributeProto</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">NodeProto</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a function into a list of nodes.</span>

<span class="sd">        :param inputs: inputs in the calling nodes</span>
<span class="sd">        :param outputs: outputs in the calling nodes</span>
<span class="sd">        :param proto: function proto</span>
<span class="sd">        :param attributes: attribute of the node, needed if the function</span>
<span class="sd">            has arguments</span>
<span class="sd">        :return: list of nodes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mapatt</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">attributes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
                <span class="n">mapatt</span><span class="p">[</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">att</span>
        <span class="n">renamed</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">proto</span><span class="o">.</span><span class="n">input</span><span class="p">,</span> <span class="n">inputs</span><span class="p">))</span>
        <span class="n">renamed</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">proto</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">v</span><span class="p">}</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._convert_function] </span><span class="si">{</span><span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">proto</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._convert_function] renamed=</span><span class="si">{</span><span class="n">_</span><span class="p">(</span><span class="n">renamed</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">new_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">proto</span><span class="o">.</span><span class="n">node</span><span class="p">:</span>
            <span class="n">new_inputs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
                    <span class="n">new_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">assert</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">renamed</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unable to find </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> in renamed=</span><span class="si">{</span><span class="n">renamed</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="n">new_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">renamed</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
            <span class="n">new_outputs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
                    <span class="n">new_outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">renamed</span><span class="p">:</span>
                    <span class="n">new_outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">renamed</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                    <span class="n">renamed</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_name</span>
                    <span class="n">new_outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_name</span><span class="p">)</span>

            <span class="n">new_node</span> <span class="o">=</span> <span class="n">oh</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="p">,</span>
                <span class="n">new_inputs</span><span class="p">,</span>
                <span class="n">new_outputs</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_node_name</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
                <span class="n">domain</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">new_attributes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">ref_attr_name</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">att</span><span class="o">.</span><span class="n">ref_attr_name</span> <span class="ow">in</span> <span class="n">mapatt</span><span class="p">,</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;The node relies on one attribute </span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> with a reference &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;to a function attribute but none is provided in the available &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;set </span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="n">mapatt</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>
                    <span class="n">known_att</span> <span class="o">=</span> <span class="n">mapatt</span><span class="p">[</span><span class="n">att</span><span class="o">.</span><span class="n">ref_attr_name</span><span class="p">]</span>
                    <span class="k">assert</span> <span class="n">known_att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Type mimatch netween the attribute </span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;type </span><span class="si">{</span><span class="n">att</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2"> of the node &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;inside the function and the one &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">known_att</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2"> outside the function (name </span><span class="si">{</span><span class="n">known_att</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">)&quot;</span>
                    <span class="p">)</span>
                    <span class="n">new_att</span> <span class="o">=</span> <span class="n">AttributeProto</span><span class="p">()</span>
                    <span class="n">new_att</span><span class="o">.</span><span class="n">ParseFromString</span><span class="p">(</span><span class="n">known_att</span><span class="o">.</span><span class="n">SerializeToString</span><span class="p">())</span>
                    <span class="n">new_att</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">att</span><span class="o">.</span><span class="n">name</span>
                    <span class="n">new_attributes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_att</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span><span class="p">:</span>
                    <span class="n">new_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rename_results_in_subgraph</span><span class="p">(</span>
                        <span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">,</span>
                        <span class="n">replacements</span><span class="o">=</span><span class="n">renamed</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                        <span class="n">check_ref_attr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">attributes</span><span class="o">=</span><span class="n">attributes</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">make_idg</span><span class="p">(</span><span class="n">new_g</span><span class="p">)</span> <span class="o">==</span> <span class="n">make_idg</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="p">):</span>
                        <span class="n">new_attributes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">att</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_attributes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oh</span><span class="o">.</span><span class="n">make_attribute</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">new_g</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_attributes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">att</span><span class="p">)</span>
            <span class="n">new_node</span><span class="o">.</span><span class="n">attribute</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_attributes</span><span class="p">)</span>
            <span class="n">new_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[GraphBuilder-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">()</span><span class="si">}</span><span class="s2">._convert_function] done &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">proto</span><span class="o">.</span><span class="n">domain</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">proto</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">new_nodes</span>

<div class="viewcode-block" id="GraphBuilder.move_initializers_to_constant">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.move_initializers_to_constant">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">move_initializers_to_constant</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">full_parameter_name</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Moves initializers as constant nodes.</span>

<span class="sd">        :param full_parameter_name: keeps the local name or the full name for the parameters</span>
<span class="sd">        :param threshold: only move intializers to constant if their size is below this limit</span>
<span class="sd">        :param verbose: verbosity</span>
<span class="sd">        :return: number of moved initializers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_not_turn_constant_initializers</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">initializers</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_initializers</span><span class="p">(</span>
            <span class="n">switch_low_high</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">!=</span> <span class="s2">&quot;big&quot;</span><span class="p">,</span>
            <span class="n">large_model</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">external_threshold</span><span class="o">=</span><span class="n">threshold</span> <span class="ow">or</span> <span class="mi">2</span><span class="o">**</span><span class="mi">30</span><span class="p">,</span>
            <span class="n">full_parameter_name</span><span class="o">=</span><span class="n">full_parameter_name</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">to_remove</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cst_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">proto</span> <span class="ow">in</span> <span class="n">initializers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">proto</span><span class="o">.</span><span class="n">external_data</span><span class="p">:</span>
                <span class="c1"># external tensor</span>
                <span class="k">continue</span>
            <span class="n">to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proto</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[move_initializers_to_constant] convert &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">proto</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> into a node &#39;Constant&#39;&quot;</span>
                <span class="p">)</span>
            <span class="n">cst</span> <span class="o">=</span> <span class="n">oh</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span>
                <span class="s2">&quot;Constant&quot;</span><span class="p">,</span>
                <span class="p">[],</span>
                <span class="p">[</span><span class="n">proto</span><span class="o">.</span><span class="n">name</span><span class="p">],</span>
                <span class="n">value</span><span class="o">=</span><span class="n">proto</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_node_name</span><span class="p">(</span><span class="s2">&quot;init2cst&quot;</span><span class="p">),</span>
                <span class="n">doc_string</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;move_initializers_to_constant/</span><span class="si">{</span><span class="n">proto</span><span class="o">.</span><span class="n">doc_string</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">cst_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cst</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_constant_node</span><span class="p">(</span><span class="n">cst</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_node_constant</span><span class="p">(</span><span class="n">proto</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">cst</span><span class="p">)</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">proto</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Type is missing for initializer </span><span class="si">{</span><span class="n">proto</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">proto</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Shape is missing for initializer </span><span class="si">{</span><span class="n">proto</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="n">to_remove</span><span class="p">:</span>
            <span class="n">remove</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">to_remove</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">remove</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">cst_nodes</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">]</span></div>


<div class="viewcode-block" id="GraphBuilder.get_input_dynamic_shape">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.get_input_dynamic_shape">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_input_dynamic_shape</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">input_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">example_shape</span><span class="p">:</span> <span class="n">STATIC_SHAPE</span><span class="p">,</span>
        <span class="n">dynamic_shapes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">example_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DYNAMIC_SHAPE</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the shape based on the available information.</span>

<span class="sd">        :param name: input name</span>
<span class="sd">        :param input_index: input index</span>
<span class="sd">        :param example_shape: the shape of the given input</span>
<span class="sd">        :param dynamic_shapes: used to handle nested dynamic shapes</span>
<span class="sd">        :param example_value: one example of the value</span>
<span class="sd">        :return: dynamic shape</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dynamic_shapes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dynamic_shapes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span>
        <span class="k">if</span> <span class="n">dynamic_shapes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">example_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_static_shape</span><span class="p">(</span><span class="n">example_shape</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">example_shape</span><span class="p">)</span>
            <span class="c1"># Should we convert SymInt to str.</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">example_shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">example_value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dynamic_shapes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># No info, we use the example values</span>
                <span class="k">return</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_torch_sym_int_to_str</span><span class="p">,</span> <span class="n">example_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">))]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dynamic_shapes</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">info</span> <span class="o">=</span> <span class="n">dynamic_shapes</span><span class="p">[</span><span class="n">input_index</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dynamic_shapes</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">info</span> <span class="o">=</span> <span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unexpected type for dynamic_shapes=</span><span class="si">{</span><span class="n">dynamic_shapes</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;example_value=</span><span class="si">{</span><span class="n">string_type</span><span class="p">(</span><span class="n">example_value</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_input_dynamic_shape</span><span class="p">(</span>
                    <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">example_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">info</span> <span class="k">if</span> <span class="n">info</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="n">example_shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">example_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">input_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_args</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_args</span><span class="p">[</span><span class="n">input_index</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">VirtualTensor</span><span class="p">):</span>
                    <span class="n">example_shape</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;example_shape is None, example_value as well, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;type input_arg=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_args</span><span class="p">[</span><span class="n">input_index</span><span class="p">])</span><span class="si">}</span><span class="s2">, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;dynamic_shapes=</span><span class="si">{</span><span class="n">dynamic_shapes</span><span class="si">}</span><span class="s2">, input_index=</span><span class="si">{</span><span class="n">input_index</span><span class="si">}</span><span class="s2">, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;self.input_args=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">input_args</span><span class="si">}</span><span class="s2">, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;as_function=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">as_function</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">example_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;example_shape is None, example_value is None, the input &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;VirtualTensor has no shape as well, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;type input_arg=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_args</span><span class="p">[</span><span class="n">input_index</span><span class="p">])</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;dynamic_shapes=</span><span class="si">{</span><span class="n">dynamic_shapes</span><span class="si">}</span><span class="s2">, input_index=</span><span class="si">{</span><span class="n">input_index</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;self.input_args=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">input_args</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;as_function=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">as_function</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_function</span><span class="p">:</span>
                <span class="c1"># We don&#39;t need the shape for function.</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;example_shape is None, example_value as well, there is no input_args, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;input_index=</span><span class="si">{</span><span class="n">input_index</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;input_args=</span><span class="si">{</span><span class="n">string_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_args</span><span class="p">,</span><span class="w"> </span><span class="n">with_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;dynamic_shapes=</span><span class="si">{</span><span class="n">dynamic_shapes</span><span class="si">}</span><span class="s2">, input_index=</span><span class="si">{</span><span class="n">input_index</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;self.input_args=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">input_args</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;as_function=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">as_function</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">example_value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">example_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">example_shape</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;At this stage, a tensor is expected but example_value=&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">string_type</span><span class="p">(</span><span class="n">example_value</span><span class="p">)</span><span class="si">}</span><span class="s2">, example_shape=</span><span class="si">{</span><span class="n">example_shape</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;dynamic_shapes=</span><span class="si">{</span><span class="n">dynamic_shapes</span><span class="si">}</span><span class="s2">, input_index=</span><span class="si">{</span><span class="n">input_index</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;self.input_args=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">input_args</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;as_function=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">as_function</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dynamic_shapes</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">info</span> <span class="o">=</span> <span class="n">dynamic_shapes</span><span class="p">[</span><span class="n">input_index</span><span class="p">]</span> <span class="k">if</span> <span class="n">input_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">dynamic_shapes</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dynamic_shapes</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">info</span> <span class="o">=</span> <span class="n">dynamic_shapes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dynamic_shapes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unexpected type for dynamic_shapes=</span><span class="si">{</span><span class="n">string_type</span><span class="p">(</span><span class="n">dynamic_shapes</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;self.dynamic_shapes=</span><span class="si">{</span><span class="n">string_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_shapes</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;example_value=</span><span class="si">{</span><span class="n">string_type</span><span class="p">(</span><span class="n">example_value</span><span class="p">)</span><span class="si">}</span><span class="s2">, name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;example_shape=</span><span class="si">{</span><span class="n">example_shape</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># We could return example_shape.shape (s0, ...) when info is (batch, ...)</span>
        <span class="c1"># In case example_shape is missing, then dynamic_shape should prevail.</span>
        <span class="k">if</span> <span class="n">example_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">example_shape</span><span class="p">)</span>

            <span class="c1"># In that case, we need to make sure that dynamic dimmensions</span>
            <span class="c1"># appears at the same position.</span>
            <span class="n">ret_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">example_shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">info</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">assert</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret_shape</span><span class="p">),</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, input_index=</span><span class="si">{</span><span class="n">input_index</span><span class="si">}</span><span class="s2">, info=</span><span class="si">{</span><span class="n">info</span><span class="si">}</span><span class="s2">, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;dimension </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> does not extist in shape </span><span class="si">{</span><span class="n">ret_shape</span><span class="si">!r}</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret_shape</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">):</span>
                        <span class="c1"># We let it, set_shape will replace it</span>
                        <span class="c1"># by the dynamic dimension name and register an alias.</span>
                        <span class="k">continue</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret_shape</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Incompatible types between example_shape=</span><span class="si">{</span><span class="n">example_shape</span><span class="si">}</span><span class="s2">, k=</span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2">, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">string_type</span><span class="p">(</span><span class="n">example_shape</span><span class="p">)</span><span class="si">}</span><span class="s2">, info=</span><span class="si">{</span><span class="n">info</span><span class="si">}</span><span class="s2">, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, input_index=</span><span class="si">{</span><span class="n">input_index</span><span class="si">!r}</span><span class="s2">, dynamic_shapes=&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dynamic_shapes</span><span class="si">}</span><span class="s2">, example_value=</span><span class="si">{</span><span class="n">string_type</span><span class="p">(</span><span class="n">example_value</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="c1"># example_shape[k] is int but dynamic_shape says otherwise,</span>
                    <span class="c1"># we trust dynamic shape</span>
                    <span class="n">ret_shape</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">WrapDim</span><span class="p">)</span> <span class="k">else</span> <span class="n">v</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">info</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret_shape</span><span class="p">):</span>
                        <span class="c1"># torch.export.export flattens everything</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret_shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">):</span>
                        <span class="c1"># We let it, set_shape will replace it</span>
                        <span class="c1"># by the dynamic dimension name and register an alias.</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;__name__&quot;</span><span class="p">):</span>
                        <span class="c1"># it should be (self.torch.export.Dim,</span>
                        <span class="c1">#               self.torch.export.dynamic_shapes._DerivedDim)):</span>
                        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret_shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Incompatible types between example_shape=</span><span class="si">{</span><span class="n">example_shape</span><span class="si">}</span><span class="s2">, &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;i=</span><span class="si">{</span><span class="n">i</span><span class="si">!r}</span><span class="s2">, </span><span class="si">{</span><span class="n">string_type</span><span class="p">(</span><span class="n">example_shape</span><span class="p">)</span><span class="si">}</span><span class="s2">, info=</span><span class="si">{</span><span class="n">info</span><span class="si">}</span><span class="s2">, &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, input_index=</span><span class="si">{</span><span class="n">input_index</span><span class="si">!r}</span><span class="s2">, dynamic_shapes=&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dynamic_shapes</span><span class="si">}</span><span class="s2">, example_value=</span><span class="si">{</span><span class="n">string_type</span><span class="p">(</span><span class="n">example_value</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                        <span class="c1"># example_shape[i] is int but dynamic_shape says otherwise,</span>
                        <span class="c1"># we truct dynamic shape</span>
                        <span class="n">ret_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="vm">__name__</span>
                    <span class="c1"># v should be None or a dictionary but the signature forward(*args)</span>
                    <span class="c1"># is confusing sometimes.</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ret_shape</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;unable to return shape, example_shape=</span><span class="si">{</span><span class="n">example_shape</span><span class="si">}</span><span class="s2">, info=</span><span class="si">{</span><span class="n">info</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;name=</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, input_index=</span><span class="si">{</span><span class="n">input_index</span><span class="si">!r}</span><span class="s2">, dynamic_shapes=&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dynamic_shapes</span><span class="si">}</span><span class="s2">, example_value=</span><span class="si">{</span><span class="n">string_type</span><span class="p">(</span><span class="n">example_value</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="GraphBuilder.make_new_dynamic_shape">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.make_new_dynamic_shape">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_new_dynamic_shape</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">rank</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;d&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="s2">&quot;torch.SymInt&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>  <span class="c1"># noqa: F821</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a dynamic shape of a known rank with new dynamic dimension.&quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_new_name</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">d</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">n</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">while</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_objects</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">n</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">return</span> <span class="n">n</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">SymInt</span><span class="p">(</span><span class="n">_new_name</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">_d</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rank</span><span class="p">))</span></div>


<div class="viewcode-block" id="GraphBuilder.make_torch_tensor_from_np_array">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.make_torch_tensor_from_np_array">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_torch_tensor_from_np_array</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">np_array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;torch.Tensor&quot;</span><span class="p">:</span>  <span class="c1"># noqa: F821</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts a numpy array into a :class:`torch.Tensor`.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">ml_dtypes</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="n">ml_dtypes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">ml_dtypes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">np_array</span><span class="o">.</span><span class="n">dtype</span>
            <span class="k">if</span> <span class="n">dt</span> <span class="o">==</span> <span class="n">ml_dtypes</span><span class="o">.</span><span class="n">bfloat16</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">np_array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">bfloat16</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">np_array</span><span class="p">)</span></div>


<div class="viewcode-block" id="GraphBuilder.rename_names">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.rename_names">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rename_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_to_rename</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">with_existing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Renames some names in the graph and its subgraphs.&quot;&quot;&quot;</span>
        <span class="n">set_inputs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">set_outputs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">name_to_rename</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Name </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2"> not found</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">assert</span> <span class="n">with_existing</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span>
                <span class="n">v</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Name </span><span class="si">{</span><span class="n">v</span><span class="si">!r}</span><span class="s2"> already taken</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sequence</span><span class="p">(</span>
                <span class="n">k</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Renaming not implemented for sequence </span><span class="si">{</span><span class="n">k</span><span class="si">!r}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="s2">&quot;NONE&quot;</span> <span class="ow">in</span> <span class="n">k</span> <span class="ow">or</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">set_outputs</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Renaming not implemented for output </span><span class="si">{</span><span class="n">k</span><span class="si">!r}</span><span class="s2"> yet</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">with_existing</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_type</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_device</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_device</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_shape</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_shape</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rank</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_shape</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">set_inputs</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">inp</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
                            <span class="n">inp</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">v</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;rename_names_input&quot;</span><span class="p">)</span>
                            <span class="k">break</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;GraphBuilder.rename_names&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict_sources</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants_computed_</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">constants_computed_</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants_computed_</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants_computed_</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants_</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">constants_</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants_</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants_</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants_node_</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">constants_node_</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants_node_</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants_node_</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_torch_value</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_known_torch_value</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_torch_value</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_torch_value</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_sequences</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_known_sequences</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_sequences</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_sequences</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_value_shape</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_registered_users</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_registered_users</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_registered_users</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_registered_users</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_renaming</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_norename</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_norename</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="n">to_rename</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">name_to_rename</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_rename_in_nodes</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">to_rename</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">to_rename</span><span class="p">:</span>
                    <span class="n">new_input</span> <span class="o">=</span> <span class="p">[</span><span class="n">name_to_rename</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">]</span>
                    <span class="k">del</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">[:]</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_input</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">_rename_in_nodes</span><span class="p">(</span><span class="n">att</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="n">to_rename</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">to_rename</span><span class="p">:</span>
                        <span class="n">to_rename</span> <span class="o">-=</span> <span class="p">{</span><span class="n">o</span><span class="p">}</span>

        <span class="n">_rename_in_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">to_rename</span><span class="p">)</span></div>


<div class="viewcode-block" id="GraphBuilder.shadowing_names">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.shadowing_names">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">shadowing_names</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">NodeProto</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">existing</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">shadow_context</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the names being shadowed in one subgraphs.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">existing</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">shadow_context</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="p">),</span> <span class="s2">&quot;existing must be None if nodes is None&quot;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shadowing_names</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span>
                <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initializers_dict</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="p">,</span>
                <span class="nb">set</span><span class="p">(),</span>
            <span class="p">)</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">existing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">shadow_context</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="s2">&quot;existing must not be None if nodes is not None&quot;</span>
        <span class="n">shadow</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">shadow_context</span> <span class="o">=</span> <span class="n">shadow_context</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">existing</span> <span class="o">=</span> <span class="n">existing</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">not_empty</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span> <span class="k">if</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">intersection</span> <span class="o">=</span> <span class="n">not_empty</span> <span class="o">&amp;</span> <span class="n">existing</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_empty</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;One input in </span><span class="si">{</span><span class="n">not_empty</span><span class="si">}</span><span class="s2">, node=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;was not found in </span><span class="si">{</span><span class="n">existing</span><span class="si">}</span><span class="se">\n</span><span class="s2">--</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attribute</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">att</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">AttributeProto</span><span class="o">.</span><span class="n">GRAPH</span><span class="p">:</span>
                    <span class="n">g</span> <span class="o">=</span> <span class="n">att</span><span class="o">.</span><span class="n">g</span>
                    <span class="n">shadow</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">input</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">shadow_context</span>
                    <span class="n">shadow</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">initializer</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">shadow_context</span>
                    <span class="n">shadow</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">sparse_initializer</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">shadow_context</span>
                    <span class="n">shadow</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shadowing_names</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="n">existing</span><span class="p">,</span> <span class="n">existing</span><span class="p">)</span>

            <span class="n">not_empty</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span> <span class="k">if</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">shadow</span> <span class="o">|=</span> <span class="n">not_empty</span> <span class="o">&amp;</span> <span class="n">shadow_context</span>
            <span class="n">existing</span> <span class="o">|=</span> <span class="n">not_empty</span>
        <span class="k">return</span> <span class="n">shadow</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">extract_input_names_from_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">input_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_name</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">input_names</span><span class="p">:</span>
                    <span class="n">input_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="n">input_names</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extract_input_names_from_args</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">input_names</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extract_input_names_from_args</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">step</span><span class="p">]))</span>
        <span class="n">dedup_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">unique</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">input_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unique</span><span class="p">:</span>
                <span class="n">dedup_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">unique</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dedup_names</span>

<div class="viewcode-block" id="GraphBuilder.evaluate_dimension_equality_with_constraints">
<a class="viewcode-back" href="../../../api/xbuilder/index.html#experimental_experiment.xbuilder.GraphBuilder.evaluate_dimension_equality_with_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">evaluate_dimension_equality_with_constraints</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks expressions with dimensions.</span>

<span class="sd">        First supported expression:</span>

<span class="sd">        * ``f(&quot;dim&quot;, &quot;d1&quot;, &quot;+&quot;, &quot;d2&quot;)  -&gt;  dimension == args[0] + args[2]``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span><span class="p">:</span>
                <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d2</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">dimension</span> <span class="o">==</span> <span class="n">d1</span> <span class="o">+</span> <span class="n">d2</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">exp</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">d1</span><span class="si">}</span><span class="s2">+</span><span class="si">{</span><span class="n">d2</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">if</span> <span class="n">dimension</span> <span class="o">==</span> <span class="n">exp</span> <span class="ow">or</span> <span class="p">(</span>
                        <span class="n">dimension</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraints_</span> <span class="ow">and</span> <span class="n">exp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraints_</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
                    <span class="p">):</span>
                        <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">simplify_two_expressions</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">)</span><span class="si">{</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unable to evaluate expression with dimension=</span><span class="si">{</span><span class="n">dimension</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;args=</span><span class="si">{</span><span class="n">args</span><span class="si">!r}</span><span class="s2">, constraints=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">constraints_</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_debug_msg</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>
</div>

</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2023-2024
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../../../_static/documentation_options.js?v=b617ff6d"></script>
    <script src="../../../_static/doctools.js?v=fd6eb6e6"></script>
    <script src="../../../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <script src="../../../_static/scripts/furo.js?v=46bd48cc"></script>
    </body>
</html>