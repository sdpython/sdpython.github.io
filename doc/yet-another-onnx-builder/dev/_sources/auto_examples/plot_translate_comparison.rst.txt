
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/plot_translate_comparison.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_plot_translate_comparison.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_plot_translate_comparison.py:


.. _l-plot-translate-comparison:

Comparing the four ONNX translation APIs
=========================================

:func:`translate <yobx.translate.translate>` converts an
:class:`onnx.ModelProto` into Python source code that, when executed,
recreates the same model.  Four output APIs are available:

* ``"onnx"`` — uses :mod:`onnx.helper` (``oh.make_node``, ``oh.make_graph``, …)
  via :class:`~yobx.translate.inner_emitter.InnerEmitter`.
* ``"onnx-short"`` — same as ``"onnx"`` but replaces large initializers with
  random values to keep the snippet compact, via
  :class:`~yobx.translate.inner_emitter.InnerEmitterShortInitializer`.
* ``"light"`` — fluent ``start(…).vin(…).…`` chain,
  via :class:`~yobx.translate.light_emitter.LightEmitter`.
* ``"builder"`` — ``GraphBuilder``-based function wrapper,
  via :class:`~yobx.translate.builder_emitter.BuilderEmitter`.

This example builds a small model, translates it with every API, shows the
generated code, and verifies that the ``"onnx"`` snippet can be re-executed to
reproduce the original model.

.. GENERATED FROM PYTHON SOURCE LINES 25-32

.. code-block:: Python


    import numpy as np
    import onnx
    import onnx.helper as oh
    import onnx.numpy_helper as onh
    from yobx.translate import translate, translate_header








.. GENERATED FROM PYTHON SOURCE LINES 33-38

Build the model
----------------

We use ``Z = Relu(X @ W + b)`` as a running example:
a single ``Gemm`` followed by ``Relu``.

.. GENERATED FROM PYTHON SOURCE LINES 38-62

.. code-block:: Python


    TFLOAT = onnx.TensorProto.FLOAT
    INT64 = onnx.TensorProto.INT64

    W = onh.from_array(np.random.randn(8, 5).astype(np.float32), name="W")
    b = onh.from_array(np.random.randn(5).astype(np.float32), name="b")

    model = oh.make_model(
        oh.make_graph(
            [
                oh.make_node("Gemm", ["X", "W", "b"], ["T"]),
                oh.make_node("Relu", ["T"], ["Z"]),
            ],
            "gemm_relu",
            [oh.make_tensor_value_info("X", TFLOAT, [None, 8])],
            [oh.make_tensor_value_info("Z", TFLOAT, [None, 5])],
            [W, b],
        ),
        opset_imports=[oh.make_opsetid("", 17)],
        ir_version=9,
    )

    print(f"Model: {len(model.graph.node)} node(s), {len(model.graph.initializer)} initializer(s)")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Model: 2 node(s), 2 initializer(s)




.. GENERATED FROM PYTHON SOURCE LINES 63-69

1. ``"onnx"`` API — full initializer values
---------------------------------------------

The generated code uses :func:`onnx.helper.make_node`,
:func:`onnx.helper.make_graph`, and :func:`onnx.helper.make_model`.
Every initializer is serialised as an exact ``np.array(…)`` literal.

.. GENERATED FROM PYTHON SOURCE LINES 69-74

.. code-block:: Python


    code_onnx = translate(model, api="onnx")
    print("=== api='onnx' ===")
    print(code_onnx)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    === api='onnx' ===
    opset_imports = [
        oh.make_opsetid('', 17),
    ]
    inputs = []
    outputs = []
    nodes = []
    initializers = []
    sparse_initializers = []
    functions = []
    initializers.append(
        onh.from_array(
            np.array([[-1.1209279298782349, -1.475879192352295, 0.7659515142440796, -1.9382845163345337, 0.7472808957099915], [-0.38791191577911377, -0.5324187278747559, 0.7259331941604614, -0.7740516066551208, 0.4695434868335724], [1.2658747434616089, -0.20211660861968994, -0.9061779975891113, 0.8427619934082031, -1.4290515184402466], [0.36033275723457336, -0.2884273827075958, -0.4514875113964081, 1.2076146602630615, -1.4256458282470703], [0.17482441663742065, 0.3230871856212616, -0.08487619459629059, -0.8436151742935181, 0.7282646298408508], [0.21995623409748077, -1.6461528539657593, -0.42157214879989624, -1.7322736978530884, -0.5463308095932007], [-0.22367605566978455, 0.8089298009872437, 0.049691930413246155, 0.45511528849601746, -0.9685255885124207], [0.7713680267333984, -0.06445358693599701, -0.5142852663993835, 1.982190489768982, -1.1821553707122803]], dtype=np.float32),
            name='W'
        )
    )
    initializers.append(
        onh.from_array(
            np.array([-0.8883059024810791, -0.5963954329490662, 0.38960638642311096, 1.4881913661956787, 0.7142752408981323], dtype=np.float32),
            name='b'
        )
    )
    inputs.append(oh.make_tensor_value_info('X', onnx.TensorProto.FLOAT, shape=(None, 8)))
    nodes.append(
        oh.make_node(
            'Gemm',
            ['X', 'W', 'b'],
            ['T']
        )
    )
    nodes.append(
        oh.make_node(
            'Relu',
            ['T'],
            ['Z']
        )
    )
    outputs.append(oh.make_tensor_value_info('Z', onnx.TensorProto.FLOAT, shape=(None, 5)))
    graph = oh.make_graph(
        nodes,
        'gemm_relu',
        inputs,
        outputs,
        initializers,
        sparse_initializer=sparse_initializers,
    )
    model = oh.make_model(
        graph,
        functions=functions,
        opset_imports=opset_imports,
        ir_version=9,
    )




.. GENERATED FROM PYTHON SOURCE LINES 75-81

2. ``"onnx-short"`` API — large initializers replaced by random values
-----------------------------------------------------------------------

Identical to ``"onnx"`` except that initializers with more than 16 elements
are replaced by ``np.random.randn(…)`` / ``np.random.randint(…)`` calls.
This keeps the snippet readable when dealing with large weight tensors.

.. GENERATED FROM PYTHON SOURCE LINES 81-86

.. code-block:: Python


    code_short = translate(model, api="onnx-short")
    print("=== api='onnx-short' ===")
    print(code_short)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    === api='onnx-short' ===
    opset_imports = [
        oh.make_opsetid('', 17),
    ]
    inputs = []
    outputs = []
    nodes = []
    initializers = []
    sparse_initializers = []
    functions = []
    value = np.random.randn(8, 5).astype(np.float32)
    initializers.append(
        onh.from_array(
            np.array(value, dtype=np.float32),
            name='W'
        )
    )
    initializers.append(
        onh.from_array(
            np.array([-0.8883059024810791, -0.5963954329490662, 0.38960638642311096, 1.4881913661956787, 0.7142752408981323], dtype=np.float32),
            name='b'
        )
    )
    inputs.append(oh.make_tensor_value_info('X', onnx.TensorProto.FLOAT, shape=(None, 8)))
    nodes.append(
        oh.make_node(
            'Gemm',
            ['X', 'W', 'b'],
            ['T']
        )
    )
    nodes.append(
        oh.make_node(
            'Relu',
            ['T'],
            ['Z']
        )
    )
    outputs.append(oh.make_tensor_value_info('Z', onnx.TensorProto.FLOAT, shape=(None, 5)))
    graph = oh.make_graph(
        nodes,
        'gemm_relu',
        inputs,
        outputs,
        initializers,
        sparse_initializer=sparse_initializers,
    )
    model = oh.make_model(
        graph,
        functions=functions,
        opset_imports=opset_imports,
        ir_version=9,
    )




.. GENERATED FROM PYTHON SOURCE LINES 87-88

Size comparison between the two onnx variants:

.. GENERATED FROM PYTHON SOURCE LINES 88-92

.. code-block:: Python


    print(f"\nFull code length  : {len(code_onnx):>6} characters")
    print(f"Short code length : {len(code_short):>6} characters")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    Full code length  :   1909 characters
    Short code length :   1114 characters




.. GENERATED FROM PYTHON SOURCE LINES 93-97

3. ``"light"`` API — fluent chain
-----------------------------------

The output is a single method-chain expression (``start(…).vin(…).…``).

.. GENERATED FROM PYTHON SOURCE LINES 97-102

.. code-block:: Python


    code_light = translate(model, api="light")
    print("=== api='light' ===")
    print(code_light)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    === api='light' ===
    (
        start(opset=17)
        .cst(np.array([[-1.1209279298782349, -1.475879192352295, 0.7659515142440796, -1.9382845163345337, 0.7472808957099915], [-0.38791191577911377, -0.5324187278747559, 0.7259331941604614, -0.7740516066551208, 0.4695434868335724], [1.2658747434616089, -0.20211660861968994, -0.9061779975891113, 0.8427619934082031, -1.4290515184402466], [0.36033275723457336, -0.2884273827075958, -0.4514875113964081, 1.2076146602630615, -1.4256458282470703], [0.17482441663742065, 0.3230871856212616, -0.08487619459629059, -0.8436151742935181, 0.7282646298408508], [0.21995623409748077, -1.6461528539657593, -0.42157214879989624, -1.7322736978530884, -0.5463308095932007], [-0.22367605566978455, 0.8089298009872437, 0.049691930413246155, 0.45511528849601746, -0.9685255885124207], [0.7713680267333984, -0.06445358693599701, -0.5142852663993835, 1.982190489768982, -1.1821553707122803]], dtype=np.float32))
        .rename('W')
        .cst(np.array([-0.8883059024810791, -0.5963954329490662, 0.38960638642311096, 1.4881913661956787, 0.7142752408981323], dtype=np.float32))
        .rename('b')
        .vin('X', elem_type=onnx.TensorProto.FLOAT, shape=(None, 8))
        .bring('X', 'W', 'b')
        .Gemm()
        .rename('T')
        .bring('T')
        .Relu()
        .rename('Z')
        .bring('Z')
        .vout(elem_type=onnx.TensorProto.FLOAT, shape=(None, 5))
        .to_onnx()
    )




.. GENERATED FROM PYTHON SOURCE LINES 103-107

4. ``"builder"`` API — GraphBuilder
-------------------------------------

The output uses ``GraphBuilder`` to wrap the graph nodes in a Python function.

.. GENERATED FROM PYTHON SOURCE LINES 107-112

.. code-block:: Python


    code_builder = translate(model, api="builder")
    print("=== api='builder' ===")
    print(code_builder)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    === api='builder' ===

    def gemm_relu(
        op: "GraphBuilder",
        X: "FLOAT[None, 8]",
    ):
        W = np.array([[-1.1209279298782349, -1.475879192352295, 0.7659515142440796, -1.9382845163345337, 0.7472808957099915], [-0.38791191577911377, -0.5324187278747559, 0.7259331941604614, -0.7740516066551208, 0.4695434868335724], [1.2658747434616089, -0.20211660861968994, -0.9061779975891113, 0.8427619934082031, -1.4290515184402466], [0.36033275723457336, -0.2884273827075958, -0.4514875113964081, 1.2076146602630615, -1.4256458282470703], [0.17482441663742065, 0.3230871856212616, -0.08487619459629059, -0.8436151742935181, 0.7282646298408508], [0.21995623409748077, -1.6461528539657593, -0.42157214879989624, -1.7322736978530884, -0.5463308095932007], [-0.22367605566978455, 0.8089298009872437, 0.049691930413246155, 0.45511528849601746, -0.9685255885124207], [0.7713680267333984, -0.06445358693599701, -0.5142852663993835, 1.982190489768982, -1.1821553707122803]], dtype=np.float32)
        b = np.array([-0.8883059024810791, -0.5963954329490662, 0.38960638642311096, 1.4881913661956787, 0.7142752408981323], dtype=np.float32)
        T = op.Gemm(X, W, b, outputs=['T'])
        Z = op.Relu(T, outputs=['Z'])
        op.Identity(Z, outputs=["Z"])
        return Z

    g = GraphBuilder({'': 17}, ir_version=9)
    g.make_tensor_input("X", onnx.TensorProto.FLOAT, (None, 8))
    gemm_relu(g.op, "X")
    g.make_tensor_output("Z", onnx.TensorProto.FLOAT, (None, 5), is_dimension=False, indexed=False)
    model = g.to_onnx()




.. GENERATED FROM PYTHON SOURCE LINES 113-118

Round-trip verification
-----------------------

The ``"onnx"`` snippet is fully self-contained and executable.
Running it should recreate a model with the same graph structure.

.. GENERATED FROM PYTHON SOURCE LINES 118-135

.. code-block:: Python


    header = translate_header("onnx")
    full_code = header + "\n" + code_onnx
    ns: dict = {}
    exec(compile(full_code, "<translate>", "exec"), ns)  # noqa: S102
    recreated = ns["model"]

    assert isinstance(recreated, onnx.ModelProto)
    assert len(recreated.graph.node) == len(
        model.graph.node
    ), f"Expected {len(model.graph.node)} nodes, got {len(recreated.graph.node)}"
    assert len(recreated.graph.initializer) == len(model.graph.initializer), (
        f"Expected {len(model.graph.initializer)} initializers, "
        f"got {len(recreated.graph.initializer)}"
    )
    print("\nRound-trip succeeded ✓")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    Round-trip succeeded ✓




.. GENERATED FROM PYTHON SOURCE LINES 136-142

Plot: code size by API
-----------------------

The bar chart compares the number of characters produced by each API for the
same model.  ``"onnx-short"`` is always ≤ ``"onnx"`` because it compresses
large initializers.

.. GENERATED FROM PYTHON SOURCE LINES 142-163

.. code-block:: Python


    import matplotlib.pyplot as plt  # noqa: E402

    api_labels = ["onnx", "onnx-short", "light", "builder"]
    code_sizes = [len(code_onnx), len(code_short), len(code_light), len(code_builder)]

    fig, ax = plt.subplots(figsize=(7, 4))
    bars = ax.bar(api_labels, code_sizes, color=["#4c72b0", "#dd8452", "#55a868", "#c44e52"])
    ax.set_ylabel("Generated code size (characters)")
    ax.set_title("ONNX translation: code size by API")
    for bar, size in zip(bars, code_sizes):
        ax.text(
            bar.get_x() + bar.get_width() / 2,
            bar.get_height() * 1.01,
            str(size),
            ha="center",
            va="bottom",
            fontsize=9,
        )
    plt.tight_layout()
    plt.show()



.. image-sg:: /auto_examples/images/sphx_glr_plot_translate_comparison_001.png
   :alt: ONNX translation: code size by API
   :srcset: /auto_examples/images/sphx_glr_plot_translate_comparison_001.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.169 seconds)


.. _sphx_glr_download_auto_examples_plot_translate_comparison.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_translate_comparison.ipynb <plot_translate_comparison.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_translate_comparison.py <plot_translate_comparison.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_translate_comparison.zip <plot_translate_comparison.zip>`


.. include:: plot_translate_comparison.recommendations


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
